<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Dispersed Volume - Prototype 1.3.1</title>
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #000; color: #fff; overflow: hidden; }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; }
        #canvas canvas { display: block; }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: 100; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
              padding: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
              max-width: 420px; width: 90%; transition: all 0.4s ease;
              max-height: 85vh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 320px; width: auto; padding: 16px;
                     max-height: calc(100vh - 40px); overflow-y: auto; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: 100;
                      text-decoration: none; color: #fff; transition: opacity 0.2s; }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 18px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: 11px; font-weight: 400; opacity: 0.5;
                    margin-top: 4px; letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: 8px 0; padding: 14px;
                 background: rgba(255,255,255,0.1); color: #fff;
                 border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
                 cursor: pointer; font-size: 12px; font-weight: 600;
                 transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.98); }

        button.small { padding: 8px; font-size: 10px; opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: 6px; margin: 8px 0;
                   display: flex; align-items: center; justify-content: center;
                   background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: 10px; opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: 11px; font-weight: 600; margin-top: 16px; display: block;
                text-transform: uppercase; letter-spacing: 0.8px; opacity: 0.7; }

        .hidden { display: none !important; }

        #controls { margin-top: 16px; padding-top: 16px;
                    border-top: 1px solid rgba(255,255,255,0.15); }

        .slider { width: 100%; height: 4px; border-radius: 2px;
                  background: rgba(255,255,255,0.15); outline: none;
                  -webkit-appearance: none; margin: 10px 0; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none;
                                         width: 18px; height: 18px; border-radius: 50%;
                                         background: #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%;
                                     background: #fff; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .value { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                 cursor: pointer; padding: 2px 6px; border-radius: 3px;
                 transition: background 0.2s; }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                       background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
                       color: #fff; padding: 2px 6px; border-radius: 3px; width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: 14px; }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: 8px; }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: 4px; align-items: center; }

        .arrow-btn { width: 20px; height: 20px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
                     border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: all 0.15s; line-height: 1; }
        .arrow-btn:hover { background: rgba(255,255,255,0.2); }
        .arrow-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: 9px; opacity: 0.3; margin-top: 10px; text-align: center;
                font-style: italic; }

        /* Custom scrollbar for UI */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: 100;
                          display: flex; gap: 8px; background: rgba(0,0,0,0.75);
                          backdrop-filter: blur(10px); padding: 8px; border-radius: 8px;
                          border: 1px solid rgba(255,255,255,0.2); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.1);
                     border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
                     color: #fff; font-size: 20px; cursor: pointer; transition: all 0.2s;
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: rgba(255,255,255,0.2); transform: none; }
        .shape-btn.active { background: rgba(255,255,255,0.3);
                            border-color: rgba(255,255,255,0.5); }

        #mode-3d-btn { width: auto; padding: 0 12px; font-size: 10px; margin-left: 8px;
                       border-left: 1px solid rgba(255,255,255,0.3); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: 100;
                           background: rgba(0,0,0,0.75); backdrop-filter: blur(10px);
                           padding: 8px 12px; border-radius: 6px;
                           border: 1px solid rgba(255,255,255,0.2);
                           font-size: 10px; cursor: pointer; transition: all 0.2s; }
        #version-selector:hover { background: rgba(0,0,0,0.85); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: 99;
                       background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
                       padding: 8px; border-radius: 6px;
                       border: 1px solid rgba(255,255,255,0.2);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: 8px 12px; cursor: pointer; font-size: 10px;
                       border-radius: 4px; margin: 2px 0; transition: all 0.2s;
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.1); }
        .version-item.current { background: rgba(255,255,255,0.15); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: 12px; }
        .video-control-btn { padding: 8px 12px; font-size: 10px; margin: 0; width: 100%; }

        .video-timeline { margin-top: 8px; }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 3px;
            transition: background 0.2s;
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(255,255,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }

        /* Screen Management UI - Separate left panel */
        #screen-manager-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 360px;
            width: 360px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        #screen-manager-panel.hidden { display: none; }
        #screen-manager-panel h2 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            opacity: 0.9;
            margin-bottom: 16px;
            font-weight: 600;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }
        .screen-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 16px;
            padding-right: 4px;
        }
        .screen-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.2s;
        }
        .screen-item:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.2);
        }
        .screen-item.selected {
            border-color: rgba(100,150,255,0.6);
            background: rgba(100,150,255,0.12);
            box-shadow: 0 0 12px rgba(100,150,255,0.2);
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-header .screen-num {
            font-weight: 600;
            font-size: 12px;
            color: rgba(255,255,255,0.9);
        }
        .screen-header .screen-delete {
            background: rgba(255,60,60,0.2);
            border: 1px solid rgba(255,60,60,0.4);
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
            color: rgba(255,255,255,0.8);
            font-weight: 600;
        }
        .screen-header .screen-delete:hover {
            background: rgba(255,60,60,0.4);
            border-color: rgba(255,60,60,0.6);
        }
        .screen-type-selector {
            display: flex;
            gap: 8px;
        }
        .screen-type-btn {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .screen-type-btn.active {
            background: rgba(100,150,255,0.25);
            border-color: rgba(100,150,255,0.6);
            color: rgba(255,255,255,1);
        }
        .screen-type-btn:hover {
            background: rgba(255,255,255,0.12);
        }
        .color-section {
            margin-top: 8px;
        }
        .color-section h4 {
            font-size: 9px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.05);
            border-color: rgba(255,255,255,0.3);
        }
        .color-option.active {
            border-color: rgba(100,150,255,0.9);
            box-shadow: 0 0 12px rgba(100,150,255,0.6);
            transform: scale(1.05);
        }
        .color-custom {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .color-custom input[type="color"] {
            width: 50px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
        }
        .color-custom input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .add-screen-btn {
            background: rgba(100,200,100,0.25);
            border: 1px solid rgba(100,200,100,0.4);
            margin-top: 8px;
            padding: 12px;
            width: 100%;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .add-screen-btn:hover {
            background: rgba(100,200,100,0.35);
            border-color: rgba(100,200,100,0.6);
        }
        .screen-manager-hint {
            font-size: 9px;
            opacity: 0.5;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 ‚Äî Video projection volum√©trique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn" data-shape="circle" title="Circle">‚óè</button>
        <button class="shape-btn active" data-shape="square" title="Square">‚ñ†</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">‚óÜ</button>
        <button class="shape-btn" data-shape="star" title="Star">‚òÖ</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>
    <div id="canvas"></div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 ‚Äî Image dispers√©e</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 ‚Äî Video dispers√©e</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 ‚Äî Luminance depth</div>
    </div>

    <!-- Screen Management Panel (Left side) -->
    <div id="screen-manager-panel" class="hidden">
        <h2>üé¨ Gestion des √âcrans</h2>
        <div class="screen-list" id="screen-list"></div>
        <button class="add-screen-btn" onclick="addNewScreen()">+ Ajouter un √âcran</button>
        <p class="screen-manager-hint">
            <strong>Raccourcis clavier:</strong><br>
            Touche A: Ajouter un √©cran<br>
            Suppr/Backspace: Supprimer s√©lection<br>
            1-7: S√©lectionner √©cran<br>
            G/R/E/S: Translate/Rotate/Scale/Size
        </p>
    </div>

    <div id="ui">
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">‚è∏ Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">‚ñº</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">‚ñº</button>
                        <span class="value" id="val-density" data-param="density">13X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="15" step="1" value="13">
                    <div class="center-mark" style="left: 42.9%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">‚ñº</button>
                        <span class="value" id="val-depth" data-param="depth">0.2X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="0.2" step="0.01" value="0.1">
                    <div class="center-mark" style="left: 50%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">‚ñº</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">‚ñº</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.8</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>GLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="glow" data-dir="down">‚ñº</button>
                        <span class="value" id="val-glow" data-param="glow">0.30</span>
                        <button class="arrow-btn" data-param="glow" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="glow" min="0.0" max="1.0" step="0.05" value="0.3">
                    <div class="center-mark" style="left: 30%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">‚ñº</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">‚ñº</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">‚ñº</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">‚ñº</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.1</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.1">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">‚ñº</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.80</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.80">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">‚ñº</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Drag to rotate ‚Ä¢ Scroll to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.2;
        let pointSize = 0.39;
        let particleDensity = 13;
        let brightness = 1.8;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'square'; // Mode carr√© par d√©faut
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.1;
        let saturation = 0.80;
        let hideBackground = false;
        let bgThreshold = 40;
        let glowIntensity = 0.3; // √âmissivit√©/glow des particules lumineuses

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Info mode - detailed screen information
        let infoMode = false;
        let infoSprites = [];

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Transform controls for manipulating screens
        let transformControls = null;
        let orbitControls = null;
        let selectedScreen = null;
        let allScreens = {}; // Store all screens by number

        // Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Magnetism settings
        const MAGNETISM_THRESHOLD = 0.05; // ~3 degrees in radians
        const MAGNETISM_ANGLES = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2];

        // Scale mode: 'uniform' (proportionnel) or 'free' (par axe)
        let scaleMode = 'free'; // Default to free mode (allows per-axis scaling)

        // FPS Camera controls (only when no screen selected)
        const cameraKeys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };
        const CAMERA_SPEED = 5; // Vitesse de d√©placement de la cam√©ra

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 15, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 0.2, step: 0.01, decimals: 2, suffix: 'X' }, // Plage 0-0.2 pour pr√©cision sur petites valeurs
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            glow: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' }, // √âmissivit√©/glow
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);

                    // Flow is real-time, glow needs regeneration
                    if (param === 'flow') {
                        flowIntensity = parseFloat(slider.value);
                    } else if (param === 'glow') {
                        glowIntensity = parseFloat(slider.value);
                        scheduleRegenerate();
                    } else {
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = '‚è∏ Pause';
            } else {
                video.pause();
                btn.textContent = '‚ñ∂ Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            // FPS Camera controls (only when no screen selected)
            if (!selectedScreen) {
                if (e.code === 'ArrowUp') {
                    e.preventDefault();
                    cameraKeys.forward = true;
                }
                if (e.code === 'ArrowDown') {
                    e.preventDefault();
                    cameraKeys.backward = true;
                }
                if (e.code === 'ArrowLeft') {
                    e.preventDefault();
                    cameraKeys.left = true;
                }
                if (e.code === 'ArrowRight') {
                    e.preventDefault();
                    cameraKeys.right = true;
                }
                if (e.code === 'Space' && !currentVideo) {
                    e.preventDefault();
                    cameraKeys.up = true;
                }
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    e.preventDefault();
                    cameraKeys.down = true;
                }
            }

            // Space: play/pause (only if video exists)
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }

            // I: toggle info mode
            if (e.code === 'KeyI') {
                e.preventDefault();
                toggleInfoMode();
            }

            // Number keys 1-7: Select screen (keyboard + numpad)
            if ((e.code >= 'Digit1' && e.code <= 'Digit7') || (e.code >= 'Numpad1' && e.code <= 'Numpad7')) {
                e.preventDefault();
                const screenNum = parseInt(e.code.replace('Digit', '').replace('Numpad', ''));
                selectScreen(screenNum);
            }

            // G: Translate mode
            if (e.code === 'KeyG' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('translate');
                console.log('Mode: TRANSLATE (d√©placement XYZ)');
            }

            // R: Rotate mode
            if (e.code === 'KeyR' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('rotate');
                console.log('Mode: ROTATE (rotation XYZ)');
            }

            // E: Scale mode
            if (e.code === 'KeyE' && selectedScreen) {
                e.preventDefault();
                // Cycle between scale modes
                if (transformControls.mode !== 'scale') {
                    // First press: activate scale mode
                    transformControls.setMode('scale');
                    scaleMode = 'free';
                    console.log('Mode: SCALE LIBRE (axe individuel) - Re-appuyez sur E pour mode uniforme');
                } else {
                    // Subsequent presses: toggle between free and uniform
                    scaleMode = scaleMode === 'free' ? 'uniform' : 'free';
                    console.log(`Mode: SCALE ${scaleMode === 'uniform' ? 'UNIFORME (proportionnel)' : 'LIBRE (axe individuel)'}`);
                }
            }

            // S: Size/Resize mode (when screen selected) OR Save positions (when no screen)
            if (e.code === 'KeyS' && !e.ctrlKey) {
                e.preventDefault();
                if (selectedScreen) {
                    // Activate SIZE mode (geometry resize)
                    transformControls.setMode('scale');
                    scaleMode = 'resize'; // Special mode for geometry resizing
                    console.log('Mode: REDIMENSIONNEMENT (change geometry, pas scale)');
                    console.log('Drag les handles pour changer les dimensions de l\'√©cran');
                } else {
                    saveAllPositions();
                }
            }

            // Escape: Deselect screen
            if (e.code === 'Escape' && selectedScreen) {
                e.preventDefault();
                deselectScreen();
            }

            // Ctrl+Z: Undo
            if (e.code === 'KeyZ' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                undo();
            }

            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.code === 'KeyZ' && e.ctrlKey && e.shiftKey) || (e.code === 'KeyY' && e.ctrlKey)) {
                e.preventDefault();
                redo();
            }

            // Delete or Backspace: Delete selected screen
            if ((e.code === 'Delete' || e.code === 'Backspace') && selectedScreen) {
                e.preventDefault();
                deleteScreen(selectedScreen);
            }

            // A: Add new screen
            if (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey) {
                e.preventDefault();
                addNewScreen();
            }
        });

        // Keyboard controls - keyup for FPS camera
        document.addEventListener('keyup', function(e) {
            if (!selectedScreen) {
                if (e.code === 'ArrowUp') {
                    cameraKeys.forward = false;
                }
                if (e.code === 'ArrowDown') {
                    cameraKeys.backward = false;
                }
                if (e.code === 'ArrowLeft') {
                    cameraKeys.left = false;
                }
                if (e.code === 'ArrowRight') {
                    cameraKeys.right = false;
                }
                if (e.code === 'Space') {
                    cameraKeys.up = false;
                }
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    cameraKeys.down = false;
                }
            }
        });

        // Transform control functions
        function selectScreen(num) {
            if (!allScreens[num]) {
                console.log(`√âcran ${num} n'existe pas`);
                return;
            }

            selectedScreen = num;
            transformControls.attach(allScreens[num]);

            // Set snap settings based on Shift key
            document.addEventListener('keydown', onShiftChange);
            document.addEventListener('keyup', onShiftChange);

            console.log(`=== √âCRAN ${num} S√âLECTIONN√â ===`);
            console.log('Commandes:');
            console.log('  G = Mode Translation');
            console.log('  R = Mode Rotation');
            console.log('  E = Mode Scale');
            console.log('  Maj enfonc√© = rotation 15¬∞, translation 1000');
            console.log('  √âchap = D√©s√©lectionner');
            console.log('  Ctrl+Z = Annuler | Ctrl+Shift+Z = Refaire');
            console.log('  Magn√©tisme auto : 0/90/180/270¬∞');
        }

        function deselectScreen() {
            if (selectedScreen) {
                console.log(`√âcran ${selectedScreen} d√©s√©lectionn√©`);
                transformControls.detach();
                selectedScreen = null;

                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }
        }

        function deleteScreen(num) {
            if (!allScreens[num]) {
                console.warn(`√âcran ${num} n'existe pas`);
                return;
            }

            // Save state for undo
            saveState();

            const screen = allScreens[num];

            // Detach transform controls if this screen is selected
            if (selectedScreen === num) {
                transformControls.detach();
                selectedScreen = null;
                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }

            // Remove from scene
            if (screen.parent) {
                screen.parent.remove(screen);
            }

            // Dispose geometry and material to free memory
            if (screen.geometry) screen.geometry.dispose();
            if (screen.material) {
                if (Array.isArray(screen.material)) {
                    screen.material.forEach(mat => mat.dispose());
                } else {
                    screen.material.dispose();
                }
            }

            // Remove from allScreens
            delete allScreens[num];

            console.log(`=== √âCRAN ${num} SUPPRIM√â ===`);

            // Update UI
            updateScreenList();
        }

        function addNewScreen() {
            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }

            // Save state for undo
            saveState();

            // Default dimensions (same as standard screen)
            const width = 450;
            const height = 450;

            // Create new screen plane with color surface
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080, // Gray by default
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Position offset from origin
            const offset = (newNum - 1) * 500;
            screen.position.set(offset, 0, 0);

            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = true; // Mark as color surface by default
            screen.userData.color = 0x808080; // Store color

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`=== √âCRAN ${newNum} CR√â√â ===`);
            console.log(`Position: (${offset}, 0, 0)`);
            console.log(`Dimensions: ${width} x ${height}`);
            console.log(`Type: Surface couleur unie (gris)`);

            // Update UI
            updateScreenList();
        }

        function updateScreenList() {
            const screenList = document.getElementById('screen-list');
            if (!screenList) return;

            screenList.innerHTML = '';

            Object.keys(allScreens).sort((a, b) => parseInt(a) - parseInt(b)).forEach(num => {
                const screen = allScreens[num];
                const isColorSurface = screen.userData.isColorSurface || false;
                const color = screen.userData.color || 0x808080;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'screen-item';
                if (selectedScreen == num) {
                    itemDiv.classList.add('selected');
                }

                // Header with number and delete button
                const headerDiv = document.createElement('div');
                headerDiv.className = 'screen-header';
                headerDiv.innerHTML = `
                    <span class="screen-num">√âcran ${num}</span>
                    <button class="screen-delete" onclick="deleteScreen(${num}); updateScreenList();">‚úï Supprimer</button>
                `;
                itemDiv.appendChild(headerDiv);

                // Type selector
                const typeSelectorDiv = document.createElement('div');
                typeSelectorDiv.className = 'screen-type-selector';
                typeSelectorDiv.innerHTML = `
                    <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vid√©o</button>
                    <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                `;
                itemDiv.appendChild(typeSelectorDiv);

                // Color picker (only if color surface)
                if (isColorSurface) {
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x1a1a1a, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris fonc√©' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-fonc√©' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris tr√®s clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris p√¢le' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cass√©' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    // Reset to current color if invalid
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                }

                screenList.appendChild(itemDiv);
            });
        }

        function setScreenType(num, isColorSurface) {
            const screen = allScreens[num];
            if (!screen) return;

            saveState();

            screen.userData.isColorSurface = isColorSurface;

            // Detect if this is a volumetric screen (1-7) or a shape (>7)
            const isVolumetric = (num >= 1 && num <= 7);

            if (isColorSurface) {
                // Switch to color surface
                const color = screen.userData.color || 0x808080;

                if (isVolumetric) {
                    // For volumetric screens: create overlay plane to hide particles
                    if (!screen.userData.colorOverlay) {
                        // Get screen dimensions (approximate from bounding box)
                        const box = new THREE.Box3().setFromObject(screen);
                        const size = box.getSize(new THREE.Vector3());
                        const width = Math.max(size.x, size.y, size.z);
                        const height = Math.max(size.x, size.y, size.z);

                        // Create overlay mesh
                        const overlayGeometry = new THREE.PlaneGeometry(width * 1.2, height * 1.2);
                        const overlayMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);

                        // Position overlay at screen position (local space)
                        overlay.position.copy(screen.position);
                        overlay.rotation.copy(screen.rotation);
                        overlay.scale.copy(screen.scale);

                        screensGroup.add(overlay);
                        screen.userData.colorOverlay = overlay;
                    } else {
                        // Update existing overlay color
                        screen.userData.colorOverlay.material.color.setHex(color);
                        screen.userData.colorOverlay.visible = true;
                    }

                    // Hide volumetric particles
                    screen.visible = false;

                } else {
                    // For shapes: just change material color
                    screen.material.color.setHex(color);
                }
            } else {
                // Switch to video
                if (isVolumetric) {
                    // For volumetric screens: hide overlay, show particles
                    if (screen.userData.colorOverlay) {
                        screen.userData.colorOverlay.visible = false;
                    }
                    screen.visible = true;
                } else {
                    // For shapes: can't convert to video (not supported yet)
                    console.warn(`√âcran ${num}: Conversion forme ‚Üí vid√©o non support√©e`);
                }
            }

            updateScreenList();
            console.log(`√âcran ${num}: Type chang√© en ${isColorSurface ? 'Couleur' : 'Vid√©o'}`);
        }

        function setScreenColor(num, colorValue) {
            const screen = allScreens[num];
            if (!screen || !screen.userData.isColorSurface) return;

            saveState();

            screen.userData.color = colorValue;

            // Update color for volumetric overlay or direct material
            const isVolumetric = (num >= 1 && num <= 7);
            if (isVolumetric && screen.userData.colorOverlay) {
                screen.userData.colorOverlay.material.color.setHex(colorValue);
            } else if (screen.material) {
                screen.material.color.setHex(colorValue);
            }

            updateScreenList();
            console.log(`√âcran ${num}: Couleur chang√©e ‚Üí #${colorValue.toString(16).padStart(6, '0')}`);
        }

        function onShiftChange(e) {
            if (!transformControls || !selectedScreen) return;

            const isShiftPressed = e.shiftKey;

            if (transformControls.mode === 'rotate') {
                // Rotation par pas de 15¬∞ (en radians)
                transformControls.setRotationSnap(isShiftPressed ? THREE.MathUtils.degToRad(15) : null);
            } else if (transformControls.mode === 'translate') {
                // Translation snapping de 1000 unit√©s
                transformControls.setTranslationSnap(isShiftPressed ? 1000 : null);
            }
        }

        // Apply magnetism to rotation - snap to 0, 90, 180, 270 degrees when close
        function applyMagnetism(screen) {
            if (!screen) return;

            ['x', 'y', 'z'].forEach(axis => {
                const rotation = screen.rotation[axis];
                const normalized = ((rotation % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                for (let angle of MAGNETISM_ANGLES) {
                    if (Math.abs(normalized - angle) < MAGNETISM_THRESHOLD) {
                        screen.rotation[axis] = rotation - normalized + angle;
                        break;
                    }
                }
            });
        }

        function saveState() {
            const state = {};
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                state[num] = {
                    position: screen.position.clone(),
                    rotation: screen.rotation.clone(),
                    scale: screen.scale.clone()
                };
            });

            undoHistory.push(state);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Clear redo history when new action is made
            redoHistory = [];
        }

        function undo() {
            if (undoHistory.length === 0) {
                console.log('Rien √† annuler');
                return;
            }

            // Save current state to redo
            const currentState = {};
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState[num] = {
                    position: screen.position.clone(),
                    rotation: screen.rotation.clone(),
                    scale: screen.scale.clone()
                };
            });
            redoHistory.push(currentState);

            // Restore previous state
            const previousState = undoHistory.pop();
            Object.keys(previousState).forEach(num => {
                const screen = allScreens[num];
                const state = previousState[num];
                screen.position.copy(state.position);
                screen.rotation.copy(state.rotation);
                screen.scale.copy(state.scale);
            });

            console.log('Annul√© (Ctrl+Z)');
        }

        function redo() {
            if (redoHistory.length === 0) {
                console.log('Rien √† refaire');
                return;
            }

            // Save current to undo
            const currentState = {};
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState[num] = {
                    position: screen.position.clone(),
                    rotation: screen.rotation.clone(),
                    scale: screen.scale.clone()
                };
            });
            undoHistory.push(currentState);

            // Restore redo state
            const nextState = redoHistory.pop();
            Object.keys(nextState).forEach(num => {
                const screen = allScreens[num];
                const state = nextState[num];
                screen.position.copy(state.position);
                screen.rotation.copy(state.rotation);
                screen.scale.copy(state.scale);
            });

            console.log('Refait (Ctrl+Shift+Z)');
        }

        function saveAllPositions() {
            console.log('');
            console.log('='.repeat(60));
            console.log('SAUVEGARDE DES POSITIONS - COPIER-COLLER DANS LE CODE');
            console.log('='.repeat(60));
            console.log('');

            Object.keys(allScreens).sort().forEach(num => {
                const screen = allScreens[num];
                const pos = screen.position;
                const rot = screen.rotation;
                const scale = screen.scale;

                console.log(`// √âcran ${num}`);
                console.log(`screen${num}.position.set(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)});`);
                console.log(`screen${num}.rotation.set(${rot.x.toFixed(6)}, ${rot.y.toFixed(6)}, ${rot.z.toFixed(6)});`);
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    console.log(`screen${num}.scale.set(${scale.x.toFixed(3)}, ${scale.y.toFixed(3)}, ${scale.z.toFixed(3)});`);
                }
                console.log('');
            });

            console.log('='.repeat(60));
        }

        // Create text sprite for 3D labels
        function createTextSprite(text, parameters) {
            if (parameters === undefined) parameters = {};
            const fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Courier New";
            const fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
            const backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : { r: 0, g: 0, b: 0, a: 0.8 };
            const textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : { r: 255, g: 255, b: 255, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = fontsize + "px " + fontface;

            // Split text by lines
            const lines = text.split('\n');
            const lineHeight = fontsize * 1.2;

            // Measure max width
            let maxWidth = 0;
            lines.forEach(line => {
                const metrics = context.measureText(line);
                maxWidth = Math.max(maxWidth, metrics.width);
            });

            // Set canvas size
            canvas.width = maxWidth + 20;
            canvas.height = (lines.length * lineHeight) + 20;

            // Re-set font after canvas resize
            context.font = fontsize + "px " + fontface;
            context.textAlign = "left";
            context.textBaseline = "top";

            // Background
            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            context.fillStyle = "rgba(" + textColor.r + "," + textColor.g + "," + textColor.b + "," + textColor.a + ")";
            lines.forEach((line, i) => {
                context.fillText(line, 10, 10 + (i * lineHeight));
            });

            // Create sprite
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Scale sprite (canvas is in pixels, scale to world units)
            const scale = 0.5;
            sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);

            return sprite;
        }

        // Toggle detailed info mode - show 3D labels on screens
        function toggleInfoMode() {
            infoMode = !infoMode;

            if (infoMode) {
                console.log('[INFO MODE] ENABLED - Showing 3D labels on screens');

                if (screensGroup && screensGroup.children.length > 0) {
                    screensGroup.updateMatrixWorld(true);

                    // Get screen dimensions
                    const TARGET_WIDTH = 800;
                    const TARGET_HEIGHT = 450;
                    const scaleFactor = 0.5;
                    const screenW = TARGET_WIDTH * scaleFactor;
                    const screenH = TARGET_HEIGHT * scaleFactor;

                    // Create label for each screen
                    screensGroup.children.forEach((screen, index) => {
                        const screenNum = index + 1;
                        const pos = screen.position;
                        const rot = screen.rotation;
                        const box = new THREE.Box3().setFromObject(screen);

                        // Build text for this screen
                        let labelText = `ECRAN #${screenNum}\n`;
                        labelText += `${getScreenName(index)}\n`;
                        labelText += `\n`;
                        labelText += `POS: X=${pos.x.toFixed(1)} Y=${pos.y.toFixed(1)} Z=${pos.z.toFixed(1)}\n`;
                        labelText += `ROT: X=${(rot.x * 180 / Math.PI).toFixed(0)}¬∞ Y=${(rot.y * 180 / Math.PI).toFixed(0)}¬∞ Z=${(rot.z * 180 / Math.PI).toFixed(0)}¬∞\n`;
                        labelText += `\n`;
                        labelText += `EDGES:\n`;
                        labelText += `TOP: Y=${box.max.y.toFixed(1)}\n`;
                        labelText += `BOTTOM: Y=${box.min.y.toFixed(1)}\n`;
                        labelText += `LEFT: X=${box.min.x.toFixed(1)}\n`;
                        labelText += `RIGHT: X=${box.max.x.toFixed(1)}\n`;
                        labelText += `FRONT: Z=${box.max.z.toFixed(1)}\n`;
                        labelText += `BACK: Z=${box.min.z.toFixed(1)}\n`;
                        labelText += `\n`;
                        labelText += `TYPE: ${getScreenType(rot)}\n`;
                        labelText += `FACE: ${getFaceDirection(rot)}`;

                        // Create sprite
                        const sprite = createTextSprite(labelText, {
                            fontsize: 14,
                            backgroundColor: { r: 0, g: 0, b: 0, a: 0.9 },
                            textColor: { r: 0, g: 255, b: 255, a: 1.0 }
                        });

                        // Position sprite in front of screen center
                        const center = box.getCenter(new THREE.Vector3());

                        // Offset sprite forward based on screen orientation
                        const normal = new THREE.Vector3(0, 0, 1);
                        normal.applyEuler(screen.rotation);
                        sprite.position.copy(center).add(normal.multiplyScalar(50));

                        scene.add(sprite);
                        infoSprites.push(sprite);
                    });

                } else {
                    console.log('‚ö†Ô∏è  No screens found in screensGroup');
                }

                console.log('[INFO MODE] 3D labels displayed - Press I to hide');

            } else {
                // Remove all sprites
                infoSprites.forEach(sprite => {
                    scene.remove(sprite);
                    if (sprite.material.map) sprite.material.map.dispose();
                    sprite.material.dispose();
                });
                infoSprites = [];
                console.log('[INFO MODE] DISABLED');
            }
        }

        // Helper functions for descriptions
        function getScreenName(index) {
            const names = [
                'Wall Back Left (particles)',
                'Wall Back Right (particlesRight)',
                'Floor Rectangle (screen3)',
                null, // √âcran 4 supprim√©
                'Wall Front Left (wallOppA)',
                'Wall Front Right (wallOppB)'
            ];
            return names[index] || `Screen ${index + 1}`;
        }

        function getXDescription(x, screenW) {
            if (Math.abs(x) < 0.01) return 'left edge';
            if (Math.abs(x - screenW) < 0.01) return 'right edge';
            if (Math.abs(x - screenW/2) < 0.01) return 'centered';
            return x < screenW/2 ? 'left side' : 'right side';
        }

        function getYDescription(y, screenH) {
            if (Math.abs(y) < 0.01) return 'centered vertically';
            if (Math.abs(y + screenH/2) < 0.01) return 'bottom edge';
            if (Math.abs(y - screenH/2) < 0.01) return 'top edge';
            return y < 0 ? 'below center' : 'above center';
        }

        function getZDescription(z, screenH) {
            if (Math.abs(z) < 0.01) return 'back wall';
            if (Math.abs(z - screenH) < 0.01) return 'front wall';
            if (Math.abs(z - screenH/2) < 0.01) return 'middle depth';
            return z < screenH/2 ? 'closer to back' : 'closer to front';
        }

        function getRotXDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'vertical (no tilt)';
            if (Math.abs(deg + 90) < 1) return 'horizontal (floor)';
            if (Math.abs(deg - 90) < 1) return 'horizontal (ceiling)';
            return deg < 0 ? 'tilted down' : 'tilted up';
        }

        function getRotYDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'facing +Z (forward)';
            if (Math.abs(deg - 90) < 1) return 'facing +X (right)';
            if (Math.abs(deg + 90) < 1) return 'facing -X (left)';
            if (Math.abs(Math.abs(deg) - 180) < 1) return 'facing -Z (backward)';
            return 'angled';
        }

        function getRotZDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'not rolled';
            return 'rolled ' + deg.toFixed(1) + '¬∞';
        }

        function getFaceDirection(rotation) {
            const y = rotation.y * 180 / Math.PI;
            if (Math.abs(y) < 45) return '+Z (forward)';
            if (Math.abs(y - 90) < 45) return '+X (right)';
            if (Math.abs(y + 90) < 45) return '-X (left)';
            if (Math.abs(Math.abs(y) - 180) < 45) return '-Z (backward)';
            return 'angled';
        }

        function getScreenType(rotation) {
            const x = Math.abs(rotation.x * 180 / Math.PI);
            if (x < 45) return 'VERTICAL WALL';
            if (x > 135) return 'VERTICAL WALL (inverted)';
            return 'HORIZONTAL (floor/ceiling)';
        }

        function analyzeHinges(group) {
            const screens = group.children;
            if (screens.length < 2) return;

            // Common hinges to check
            const hingeChecks = [
                { name: 'Wall-Floor Hinge (left)', screen1: 0, screen2: 2, edge1: 'bottom', edge2: 'top', axis: 'Y' },
                { name: 'Wall-Floor Hinge (right)', screen1: 1, screen2: 3, edge1: 'bottom', edge2: 'top', axis: 'Y' },
                { name: 'Floor-FrontWall Hinge (left)', screen1: 2, screen2: 4, edge1: 'front', edge2: 'bottom', axis: 'Y' },
                { name: 'Floor-FrontWall Hinge (right)', screen1: 3, screen2: 5, edge1: 'front', edge2: 'bottom', axis: 'Y' },
                { name: 'BackWall Left-Right', screen1: 0, screen2: 1, edge1: 'right', edge2: 'left', axis: 'X' },
                { name: 'FrontWall Left-Right', screen1: 4, screen2: 5, edge1: 'right', edge2: 'left', axis: 'X' }
            ];

            hingeChecks.forEach(check => {
                if (check.screen1 < screens.length && check.screen2 < screens.length) {
                    const box1 = new THREE.Box3().setFromObject(screens[check.screen1]);
                    const box2 = new THREE.Box3().setFromObject(screens[check.screen2]);

                    let val1, val2, gap;
                    if (check.axis === 'Y') {
                        val1 = check.edge1 === 'bottom' ? box1.min.y : (check.edge1 === 'top' ? box1.max.y : box1.max.z);
                        val2 = check.edge2 === 'top' ? box2.max.y : (check.edge2 === 'bottom' ? box2.min.y : box2.min.y);
                    } else if (check.axis === 'X') {
                        val1 = check.edge1 === 'right' ? box1.max.x : box1.min.x;
                        val2 = check.edge2 === 'left' ? box2.min.x : box2.max.x;
                    } else {
                        val1 = box1.max.z;
                        val2 = box2.min.z;
                    }

                    gap = Math.abs(val1 - val2);
                    const status = gap < 0.1 ? '‚úÖ GOOD' : (gap < 1 ? '‚ö†Ô∏è  SMALL GAP' : '‚ùå GAP');

                    console.log(`  ${check.name}:`);
                    console.log(`    Edge 1 (${getScreenName(check.screen1)}): ${val1.toFixed(3)}`);
                    console.log(`    Edge 2 (${getScreenName(check.screen2)}): ${val2.toFixed(3)}`);
                    console.log(`    Gap: ${gap.toFixed(6)} ${status}`);
                    console.log('');
                }
            });
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            if (typeof THREE === 'undefined') {
                alert('THREE.js failed to load.');
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);

            // Calculate 16:9 aspect ratio dimensions
            const aspectRatio = 16 / 9;
            let canvasWidth, canvasHeight;

            if (window.innerWidth / window.innerHeight > aspectRatio) {
                // Window is wider than 16:9, fit to height
                canvasHeight = window.innerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // Window is taller than 16:9, fit to width
                canvasWidth = window.innerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }

            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasWidth, canvasHeight);
            document.getElementById('canvas').appendChild(renderer.domElement);

            // Add lighting for 3D mode
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -0.5);
            scene.add(directionalLight2);

            // OrbitControls for camera movement
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.target.set(0, 0, 0);

            // TransformControls for manipulating screens
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('world'); // Use world space to avoid X/Y inversion
            scene.add(transformControls);

            // When transforming, disable orbit controls
            transformControls.addEventListener('dragging-changed', function(event) {
                orbitControls.enabled = !event.value;

                // Apply magnetism when releasing (end of drag)
                if (!event.value && selectedScreen && allScreens[selectedScreen]) {
                    applyMagnetism(allScreens[selectedScreen]);
                }
            });

            // Save state when starting to drag
            transformControls.addEventListener('mouseDown', function() {
                if (selectedScreen) {
                    saveState();
                }
            });

            // Handle scale modes: uniform, free, and resize
            let lastResizeScale = {x: 1, y: 1, z: 1};
            transformControls.addEventListener('objectChange', function() {
                if (transformControls.mode === 'scale' && selectedScreen && allScreens[selectedScreen]) {
                    const screen = allScreens[selectedScreen];

                    if (scaleMode === 'uniform') {
                        // UNIFORM mode: proportional scaling
                        const avgScale = (screen.scale.x + screen.scale.y + screen.scale.z) / 3;
                        screen.scale.set(avgScale, avgScale, avgScale);
                    } else if (scaleMode === 'resize') {
                        // RESIZE mode: change geometry dimensions, not scale
                        // Only works if screen has a geometry (PlaneGeometry)
                        if (screen.geometry && screen.geometry.type === 'PlaneGeometry') {
                            const currentScale = {x: screen.scale.x, y: screen.scale.y, z: screen.scale.z};

                            // Detect which axis changed
                            const deltaX = currentScale.x / lastResizeScale.x;
                            const deltaY = currentScale.y / lastResizeScale.y;

                            if (deltaX !== 1 || deltaY !== 1) {
                                // Get current geometry dimensions
                                const currentWidth = screen.geometry.parameters.width;
                                const currentHeight = screen.geometry.parameters.height;

                                // Calculate new dimensions based on scale change
                                const newWidth = currentWidth * deltaX;
                                const newHeight = currentHeight * deltaY;

                                // Recreate geometry with new dimensions
                                screen.geometry.dispose();
                                screen.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionn√©: ${Math.round(newWidth)} x ${Math.round(newHeight)}`);
                            }
                        }
                    }
                    // FREE mode: do nothing, allow non-uniform scaling
                }
            });

            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 : -1;
                camera.position.z += delta * zoomSpeed * camera.position.z;
                camera.position.z = Math.max(50, Math.min(1000, camera.position.z));
            });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            animate();
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Show preview
                document.getElementById('preview').innerHTML = '<video src="' + url + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                document.getElementById('preview').classList.add('loaded');
                document.getElementById('preview').querySelector('video').play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 13;
                    document.getElementById('depth').value = 0.1;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.8;
                    document.getElementById('glow').value = 0.3;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');
                    updateValueDisplay('glow');

                    document.getElementById('load-section').classList.add('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    document.getElementById('shape-selector').classList.remove('hidden');
                    document.getElementById('screen-manager-panel').classList.remove('hidden');
                    updateScreenList(); // Update screen management UI
                }

                // Auto-play
                videoElement.play();
                generate(videoElement);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        function generate(video) {
            if (typeof THREE === 'undefined') {
                alert('THREE.js not loaded.');
                return;
            }

            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value); // Plage ajust√©e 0-0.2 pour plus de pr√©cision
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            glowIntensity = parseFloat(document.getElementById('glow').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Optimized: reduced resolution for better performance without visual quality loss
            const TARGET_WIDTH = 800;
            const TARGET_HEIGHT = 450;
            const step = Math.max(1, Math.floor(10 / particleDensity));

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            const positions = [];
            const colors = [];
            const initialZ = [];

            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 ‚Äî Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 ‚Äî Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent √† z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);

                        // v1.3.1 ‚Äî Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // v1.3.1 ‚Äî Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                const cullThreshold = minZ + zRange * depthCullPower;

                // Remove particles below threshold (make them black = invisible)
                for (let i = 0; i < initialZ.length; i++) {
                    const z = initialZ[i];
                    if (z < cullThreshold) {
                        // Set to pure black = invisible
                        colors[i * 3] = 0;
                        colors[i * 3 + 1] = 0;
                        colors[i * 3 + 2] = 0;
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // CRITICAL: Detach transform controls before clearing to avoid "object must be part of scene graph" error
            const wasScreenSelected = selectedScreen;
            if (transformControls && selectedScreen) {
                transformControls.detach();
            }

            // Clear group before adding new screens
            screensGroup.clear();

            if (is3DMode) {
                // 3D Mode: Use InstancedMesh with real 3D geometries
                const count = positions.length / 3;
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    flatShading: true,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0xffffff, // Couleur √©missive = blanc pour prendre la couleur des particules
                    emissiveIntensity: glowIntensity // Intensit√© contr√¥l√©e par le slider
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    instanceColors[i * 3] = colors[i * 3];
                    instanceColors[i * 3 + 1] = colors[i * 3 + 1];
                    instanceColors[i * 3 + 2] = colors[i * 3 + 2];
                }
                particles.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);

                // Optimization: reuse matrix and color objects
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    particles.setColorAt(i, reusableColor);
                }

                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Use Points with VIDEO texture
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));

                // Create video texture
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const shapeTexture = getShapeTexture(currentShape);

                material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    map: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
            }

            // Volum√©trie unilat√©rale : les particules sombres restent √† z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des √©crans : z=0 invariant au DEPTH SPREAD

            // √âcran 1 - Position de base
            particles.position.set(0, 0, 0);
            particles.rotation.set(0, 0, 0);

            // Add first screen to group
            screensGroup.add(particles);

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // Clone and position second screen to the right
            const particlesRight = particles.clone();

            // Ensure both screens share the same geometry and material
            particlesRight.geometry = particles.geometry;
            particlesRight.material = particles.material;

            // √âcran 2 - Position de base
            particlesRight.position.set(400, 0, 0);
            particlesRight.rotation.set(0, 0, 0);

            // Add second screen to group
            screensGroup.add(particlesRight);

            // === √âCRAN 3: SOL RECTANGLE (largeur double = screenW x screenH) ===
            // Cr√©er une g√©om√©trie rectangulaire : largeur = screenW, hauteur = screenH
            // L'image garde sa taille normale et "d√©passe" de l'√©cran (comme les autres)
            const screen3Positions = [];
            const screen3Colors = [];
            const screen3InitialZ = [];

            // Dimensions du rectangle : Largeur compl√®te (toutes les particules), hauteur normale
            const halfH = screenH / 2; // Demi-hauteur pour centrage (112.5)

            // Filtrer les particules : TOUTES en largeur (pas de filtre sur X), hauteur normale
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];

                // Rectangle : TOUTE la largeur (pas de condition sur X), hauteur filtr√©e
                if (y >= -halfH && y <= halfH) {
                    screen3Positions.push(x, y, z);
                    screen3Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    screen3InitialZ.push(initialZ[i]);
                }
            }

            let screen3;
            if (is3DMode) {
                // Mode 3D : cr√©er InstancedMesh avec les particules du rectangle
                const count3 = screen3Positions.length / 3;
                let baseGeometry3;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry3 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry3 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry3 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen3 = new THREE.InstancedMesh(baseGeometry3, material, count3);
                screen3.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors3 = new Float32Array(count3 * 3);
                for (let i = 0; i < count3; i++) {
                    instanceColors3[i * 3] = screen3Colors[i * 3];
                    instanceColors3[i * 3 + 1] = screen3Colors[i * 3 + 1];
                    instanceColors3[i * 3 + 2] = screen3Colors[i * 3 + 2];
                }
                screen3.instanceColor = new THREE.InstancedBufferAttribute(instanceColors3, 3);

                for (let i = 0; i < count3; i++) {
                    reusableMatrix.setPosition(
                        screen3Positions[i * 3],
                        screen3Positions[i * 3 + 1],
                        screen3Positions[i * 3 + 2]
                    );
                    screen3.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen3Colors[i * 3], screen3Colors[i * 3 + 1], screen3Colors[i * 3 + 2]);
                    screen3.setColorAt(i, reusableColor);
                }

                screen3.instanceMatrix.needsUpdate = true;
                screen3.userData.initialZ = screen3InitialZ;
                screen3.userData.positions = screen3Positions;
                screen3.userData.is3D = true;

            } else {
                // Mode 2D : cr√©er Points avec les particules du rectangle
                const geometry3 = new THREE.BufferGeometry();
                geometry3.setAttribute('position', new THREE.Float32BufferAttribute(screen3Positions, 3));
                geometry3.setAttribute('color', new THREE.Float32BufferAttribute(screen3Colors, 3));
                geometry3.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen3InitialZ, 1));

                screen3 = new THREE.Points(geometry3, material);
            }

            // Position et orientation de base
            screen3.position.set(200.858, -112.500, 112.500);
            screen3.rotation.set(1.570796, 0.000000, 0.000000); // 90¬∞ sur X
            screen3.scale.set(1, 1, 1); // PAS de scale, geometry filtr√©e

            screensGroup.add(screen3);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // Clone left wall screen for opposite wall A
            const wallOppA = particles.clone();
            wallOppA.geometry = particles.geometry;
            wallOppA.material = particles.material;

            // √âcran 5 - Position de base
            wallOppA.position.set(0, 0, 225);
            wallOppA.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180¬∞ pour faire face vers -Z

            screensGroup.add(wallOppA);

            // Clone right wall screen for opposite wall B
            const wallOppB = particlesRight.clone();
            wallOppB.geometry = particles.geometry;
            wallOppB.material = particles.material;

            // √âcran 6 - Position de base
            wallOppB.position.set(400, 0, 225);
            wallOppB.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180¬∞ pour faire face vers -Z

            screensGroup.add(wallOppB);

            // === √âCRAN 7: panneau lat√©ral CARR√â (largeur = hauteur) ===
            // Cr√©er une g√©om√©trie carr√©e : largeur = hauteur = screenH
            // L'image garde sa taille normale et "d√©passe" de l'√©cran (comme les autres)
            const screen7Positions = [];
            const screen7Colors = [];
            const screen7InitialZ = [];

            // R√©utilise halfH d√©j√† d√©clar√© pour l'√©cran 3 (screenH / 2 = 112.5)
            // Filtrer les particules pour faire un carr√© : X et Y entre -halfH et +halfH
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];

                // Carr√© centr√© : -112.5 <= X <= 112.5 ET -112.5 <= Y <= 112.5
                if (x >= -halfH && x <= halfH && y >= -halfH && y <= halfH) {
                    screen7Positions.push(x, y, z);
                    screen7Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    screen7InitialZ.push(initialZ[i]);
                }
            }

            let screen7;
            if (is3DMode) {
                // Mode 3D : cr√©er InstancedMesh avec les particules du carr√©
                const count7 = screen7Positions.length / 3;
                let baseGeometry7;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry7 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry7 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry7 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen7 = new THREE.InstancedMesh(baseGeometry7, material, count7);
                screen7.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors7 = new Float32Array(count7 * 3);
                for (let i = 0; i < count7; i++) {
                    instanceColors7[i * 3] = screen7Colors[i * 3];
                    instanceColors7[i * 3 + 1] = screen7Colors[i * 3 + 1];
                    instanceColors7[i * 3 + 2] = screen7Colors[i * 3 + 2];
                }
                screen7.instanceColor = new THREE.InstancedBufferAttribute(instanceColors7, 3);

                for (let i = 0; i < count7; i++) {
                    reusableMatrix.setPosition(
                        screen7Positions[i * 3],
                        screen7Positions[i * 3 + 1],
                        screen7Positions[i * 3 + 2]
                    );
                    screen7.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen7Colors[i * 3], screen7Colors[i * 3 + 1], screen7Colors[i * 3 + 2]);
                    screen7.setColorAt(i, reusableColor);
                }

                screen7.instanceMatrix.needsUpdate = true;
                screen7.userData.initialZ = screen7InitialZ;
                screen7.userData.positions = screen7Positions;
                screen7.userData.is3D = true;

            } else {
                // Mode 2D : cr√©er Points avec les particules du carr√©
                const geometry7 = new THREE.BufferGeometry();
                geometry7.setAttribute('position', new THREE.Float32BufferAttribute(screen7Positions, 3));
                geometry7.setAttribute('color', new THREE.Float32BufferAttribute(screen7Colors, 3));
                geometry7.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen7InitialZ, 1));

                screen7 = new THREE.Points(geometry7, material);
            }

            // Position et orientation de base (coordonn√©es ajust√©es par l'utilisateur)
            screen7.position.set(599.938, -0.064, 112.546);
            screen7.rotation.set(0, -1.570796, 0); // -90¬∞ en Y
            screen7.scale.set(1, 1, 1); // IMPORTANT: pas de scale, l'image garde sa taille normale

            screensGroup.add(screen7);

            // Store volumetric screens (1-7) and preserve custom shapes (>7)
            const customShapes = {};
            if (allScreens) {
                // Preserve shapes created by user (numbers > 7)
                Object.keys(allScreens).forEach(key => {
                    const num = parseInt(key);
                    if (num > 7) {
                        customShapes[num] = allScreens[num];
                    }
                });
            }

            // Update volumetric screens 1-7
            allScreens = {
                1: particles,           // Wall back left
                2: particlesRight,      // Wall back right
                3: screen3,             // Floor rectangle (largeur double)
                5: wallOppA,            // Wall front left
                6: wallOppB,            // Wall front right
                7: screen7,             // Side panel (carr√©)
                ...customShapes         // Restore custom shapes
            };

            // CRITICAL: Reattach transform controls to the same screen after regeneration
            if (transformControls && wasScreenSelected && allScreens[wasScreenSelected]) {
                selectedScreen = wasScreenSelected;
                transformControls.attach(allScreens[wasScreenSelected]);
            }

            console.log('');
            console.log('=== CONTR√îLES 3D DISPONIBLES ===');
            console.log('Touches 1-7 : S√©lectionner un √©cran');
            console.log('G : Mode Translation');
            console.log('R : Mode Rotation');
            console.log('E : Mode Scale');
            console.log('Maj enfonc√© : rotation 15¬∞, translation 1000');
            console.log('√âchap : D√©s√©lectionner');
            console.log('Ctrl+Z : Annuler | Ctrl+Shift+Z : Refaire');
            console.log('S : Sauvegarder positions');
            console.log('Magn√©tisme auto √† 0/90/180/270¬∞');
            console.log('================================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 13;
            document.getElementById('depth').value = 0.1;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('glow').value = 0.3;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.80;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.80;
            hideBackground = false;
            bgThreshold = 40;
            glowIntensity = 0.3;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('glow');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            if (currentVideo.paused) return;

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // v1.3.1 ‚Äî Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent √† z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Skip if hideBlack and below threshold (but keep same particle count)
                        if (hideBlack && maxColor < blackThreshold) {
                            newColors.push(0, 0, 0);
                        } else {
                            // v1.3.1 ‚Äî Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply brightness boost
                            let finalR = rNorm * brightness;
                            let finalG = gNorm * brightness;
                            let finalB = bNorm * brightness;

                            // Professional emissive effect: brighter particles glow more (non-linear power curve)
                            if (glowIntensity > 0) {
                                // Calculate luminance of the pixel
                                const pixelLuminance = 0.299 * finalR + 0.587 * finalG + 0.114 * finalB;

                                // Power curve: bright pixels get boosted more (quadratic for smooth glow)
                                const emissiveBoost = Math.pow(pixelLuminance, 2.0) * glowIntensity;

                                // Add emissive glow to bright particles
                                finalR += emissiveBoost * finalR;
                                finalG += emissiveBoost * finalG;
                                finalB += emissiveBoost * finalB;
                            }

                            // Update color with brightness + emissive
                            newColors.push(
                                Math.min(1.0, finalR),
                                Math.min(1.0, finalG),
                                Math.min(1.0, finalB)
                            );
                        }
                    }
                }
            }

            // v1.3.1 ‚Äî Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                const cullThreshold = minZ + zRange * depthCullPower;

                // Remove particles below threshold (make them black = invisible)
                for (let i = 0; i < newDepths.length; i++) {
                    const z = newDepths[i];
                    if (z < cullThreshold) {
                        // Set to pure black = invisible
                        newColors[i * 3] = 0;
                        newColors[i * 3 + 1] = 0;
                        newColors[i * 3 + 2] = 0;
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation
                if (particles.userData.initialZ) {
                    for (let i = 0; i < newDepths.length; i++) {
                        particles.userData.initialZ[i] = newDepths[i];
                    }
                }

                // CRITICAL: Also update screen 7 if it exists (3D mode)
                if (allScreens[7] && allScreens[7].instanceColor) {
                    const screen7 = allScreens[7];
                    const colors7 = screen7.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen7.userData.initialZ) {
                                        screen7.userData.initialZ[screen7Index] = newDepths[particleIndex];
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen7.instanceColor.needsUpdate = true;
                }

                // CRITICAL: Also update screen 3 if it exists (3D mode)
                if (allScreens[3] && allScreens[3].instanceColor) {
                    const screen3 = allScreens[3];
                    const colors3 = screen3.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 3 rectangle (full width, normal height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, only Y)
                                if (py >= -halfH && py <= halfH) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen3.userData.initialZ) {
                                        screen3.userData.initialZ[screen3Index] = newDepths[particleIndex];
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen3.instanceColor.needsUpdate = true;
                }

            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        initialZArray[i] = newDepths[i];
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (2D mode)
                if (allScreens[7] && allScreens[7].geometry && allScreens[7].geometry.attributes.color) {
                    const screen7 = allScreens[7];
                    const geom7 = screen7.geometry;
                    const colors7 = geom7.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom7.attributes.initialZ) {
                                        geom7.attributes.initialZ.array[screen7Index] = newDepths[particleIndex];
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom7.attributes.color.needsUpdate = true;
                    if (geom7.attributes.initialZ) {
                        geom7.attributes.initialZ.needsUpdate = true;
                    }
                }

                // CRITICAL: Also update screen 3 if it exists (2D mode)
                if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.color) {
                    const screen3 = allScreens[3];
                    const geom3 = screen3.geometry;
                    const colors3 = geom3.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 3 rectangle (full width, normal height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, only Y)
                                if (py >= -halfH && py <= halfH) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom3.attributes.initialZ) {
                                        geom3.attributes.initialZ.array[screen3Index] = newDepths[particleIndex];
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom3.attributes.color.needsUpdate = true;
                    if (geom3.attributes.initialZ) {
                        geom3.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Animation with subtle breathing movement and video texture updates
        function animate() {
            requestAnimationFrame(animate);

            time += 0.001 * breathSpeed;

            // Update particle colors from current video frame (both 2D and 3D modes)
            if (currentVideo) {
                updateColorsFromVideo();
            }

            // Update video texture
            if (videoTexture && currentVideo) {
                videoTexture.needsUpdate = true;
            }

            if (particles && flowOffsets) {
                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {
                        // Optimization: reuse matrix object instead of creating new one
                        const epsilon = 0.3 * breathSpeed;

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            const newZ = initialZs[i] + breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 7 if it has its own geometry (3D mode)
                    if (allScreens[7] && allScreens[7].userData && allScreens[7].userData.is3D) {
                        const screen7 = allScreens[7];
                        const initialZs7 = screen7.userData.initialZ;
                        const positions7 = screen7.userData.positions;

                        if (initialZs7 && positions7 && initialZs7.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs7.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs7[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions7[i * 3] + flowX,
                                    positions7[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen7.setMatrixAt(i, reusableMatrix);
                            }
                            screen7.instanceMatrix.needsUpdate = true;
                        }
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (3D mode)
                    if (allScreens[3] && allScreens[3].userData && allScreens[3].userData.is3D) {
                        const screen3 = allScreens[3];
                        const initialZs3 = screen3.userData.initialZ;
                        const positions3 = screen3.userData.positions;

                        if (initialZs3 && positions3 && initialZs3.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs3.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs3[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions3[i * 3] + flowX,
                                    positions3[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen3.setMatrixAt(i, reusableMatrix);
                            }
                            screen3.instanceMatrix.needsUpdate = true;
                        }
                    }

                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        positions[i * 3 + 2] = initialZs[i] + breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;

                    // CRITICAL: Also update screen 7 if it has its own geometry (2D mode)
                    if (allScreens[7] && allScreens[7].geometry && allScreens[7].geometry.attributes.position) {
                        const screen7 = allScreens[7];
                        const geom7 = screen7.geometry;
                        const positions7 = geom7.attributes.position.array;
                        const initialZs7 = geom7.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom7.userData.initialPositions) {
                            geom7.userData.initialPositions = new Float32Array(positions7.length);
                            for (let i = 0; i < positions7.length; i++) {
                                geom7.userData.initialPositions[i] = positions7[i];
                            }
                        }

                        const initialPositions7 = geom7.userData.initialPositions;

                        for (let i = 0; i < positions7.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions7[i * 3] = initialPositions7[i * 3] + flowX;
                            positions7[i * 3 + 1] = initialPositions7[i * 3 + 1] + flowY;
                            positions7[i * 3 + 2] = initialZs7[i] + breathOffset;
                        }

                        geom7.attributes.position.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (2D mode)
                    if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.position) {
                        const screen3 = allScreens[3];
                        const geom3 = screen3.geometry;
                        const positions3 = geom3.attributes.position.array;
                        const initialZs3 = geom3.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom3.userData.initialPositions) {
                            geom3.userData.initialPositions = new Float32Array(positions3.length);
                            for (let i = 0; i < positions3.length; i++) {
                                geom3.userData.initialPositions[i] = positions3[i];
                            }
                        }

                        const initialPositions3 = geom3.userData.initialPositions;

                        for (let i = 0; i < positions3.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions3[i * 3] = initialPositions3[i * 3] + flowX;
                            positions3[i * 3 + 1] = initialPositions3[i * 3 + 1] + flowY;
                            positions3[i * 3 + 2] = initialZs3[i] + breathOffset;
                        }

                        geom3.attributes.position.needsUpdate = true;
                    }
                }
            }

            // FPS Camera movement (only when no screen selected)
            if (!selectedScreen && camera) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0; // Mouvement horizontal uniquement (pas de mont√©e/descente automatique)
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                right.normalize();

                if (cameraKeys.forward) {
                    camera.position.addScaledVector(forward, CAMERA_SPEED);
                }
                if (cameraKeys.backward) {
                    camera.position.addScaledVector(forward, -CAMERA_SPEED);
                }
                if (cameraKeys.left) {
                    camera.position.addScaledVector(right, -CAMERA_SPEED);
                }
                if (cameraKeys.right) {
                    camera.position.addScaledVector(right, CAMERA_SPEED);
                }
                if (cameraKeys.up) {
                    camera.position.y += CAMERA_SPEED;
                }
                if (cameraKeys.down) {
                    camera.position.y -= CAMERA_SPEED;
                }
            }

            // Update orbit controls
            if (orbitControls) {
                orbitControls.update();
            }

            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Maintain 16:9 aspect ratio
            const aspectRatio = 16 / 9;
            let canvasWidth, canvasHeight;

            if (window.innerWidth / window.innerHeight > aspectRatio) {
                // Window is wider than 16:9, fit to height
                canvasHeight = window.innerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // Window is taller than 16:9, fit to width
                canvasWidth = window.innerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                scheduleRegenerate();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                if (currentVideo) generate(currentVideo);
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        window.onload = init;
    </script>
</body>
</html>
