<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Dispersed Volume - Prototype 1.3.1</title>
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #000; color: #fff; overflow: hidden; }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; }
        #canvas canvas { display: block; }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: 100; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
              padding: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
              max-width: 420px; width: 90%; transition: all 0.4s ease;
              max-height: 85vh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 320px; width: auto; padding: 16px;
                     max-height: calc(100vh - 40px); overflow-y: auto; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: 100;
                      text-decoration: none; color: #fff; transition: opacity 0.2s; }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 18px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: 11px; font-weight: 400; opacity: 0.5;
                    margin-top: 4px; letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: 8px 0; padding: 14px;
                 background: rgba(255,255,255,0.1); color: #fff;
                 border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
                 cursor: pointer; font-size: 12px; font-weight: 600;
                 transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.98); }

        button.small { padding: 8px; font-size: 10px; opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: 6px; margin: 8px 0;
                   display: flex; align-items: center; justify-content: center;
                   background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: 10px; opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: 11px; font-weight: 600; margin-top: 16px; display: block;
                text-transform: uppercase; letter-spacing: 0.8px; opacity: 0.7; }

        .hidden { display: none !important; }

        #controls { margin-top: 16px; padding-top: 16px;
                    border-top: 1px solid rgba(255,255,255,0.15); }

        .slider { width: 100%; height: 4px; border-radius: 2px;
                  background: rgba(255,255,255,0.15); outline: none;
                  -webkit-appearance: none; margin: 10px 0; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none;
                                         width: 18px; height: 18px; border-radius: 50%;
                                         background: #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%;
                                     background: #fff; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .value { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                 cursor: pointer; padding: 2px 6px; border-radius: 3px;
                 transition: background 0.2s; }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                       background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
                       color: #fff; padding: 2px 6px; border-radius: 3px; width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: 14px; }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: 8px; }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: 4px; align-items: center; }

        .arrow-btn { width: 20px; height: 20px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
                     border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: all 0.15s; line-height: 1; }
        .arrow-btn:hover { background: rgba(255,255,255,0.2); }
        .arrow-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: 9px; opacity: 0.3; margin-top: 10px; text-align: center;
                font-style: italic; }

        /* Custom scrollbar for UI */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: 100;
                          display: flex; gap: 8px; background: rgba(0,0,0,0.75);
                          backdrop-filter: blur(10px); padding: 8px; border-radius: 8px;
                          border: 1px solid rgba(255,255,255,0.2); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.1);
                     border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
                     color: #fff; font-size: 20px; cursor: pointer; transition: all 0.2s;
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: rgba(255,255,255,0.2); transform: none; }
        .shape-btn.active { background: rgba(255,255,255,0.3);
                            border-color: rgba(255,255,255,0.5); }

        #mode-3d-btn { width: auto; padding: 0 12px; font-size: 10px; margin-left: 8px;
                       border-left: 1px solid rgba(255,255,255,0.3); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: 100;
                           background: rgba(0,0,0,0.75); backdrop-filter: blur(10px);
                           padding: 8px 12px; border-radius: 6px;
                           border: 1px solid rgba(255,255,255,0.2);
                           font-size: 10px; cursor: pointer; transition: all 0.2s; }
        #version-selector:hover { background: rgba(0,0,0,0.85); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: 99;
                       background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
                       padding: 8px; border-radius: 6px;
                       border: 1px solid rgba(255,255,255,0.2);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: 8px 12px; cursor: pointer; font-size: 10px;
                       border-radius: 4px; margin: 2px 0; transition: all 0.2s;
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.1); }
        .version-item.current { background: rgba(255,255,255,0.15); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: 12px; }
        .video-control-btn { padding: 8px 12px; font-size: 10px; margin: 0; width: 100%; }

        .video-timeline { margin-top: 8px; }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 3px;
            transition: background 0.2s;
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(255,255,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }
    </style>
</head>
<body>
    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 — Video projection volumétrique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn active" data-shape="circle" title="Circle">●</button>
        <button class="shape-btn" data-shape="square" title="Square">■</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">◆</button>
        <button class="shape-btn" data-shape="star" title="Star">★</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>
    <div id="canvas"></div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 — Image dispersée</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 — Video dispersée</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 — Luminance depth</div>
    </div>

    <div id="ui">
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">⏸ Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">▼</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">▼</button>
                        <span class="value" id="val-density" data-param="density">13X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="15" step="1" value="13">
                    <div class="center-mark" style="left: 42.9%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">▼</button>
                        <span class="value" id="val-depth" data-param="depth">0.2X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="3.0" step="0.1" value="0.2">
                    <div class="center-mark" style="left: 6.7%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">▼</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">▼</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.8</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">▼</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">▼</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">▼</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.1</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.1">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">▼</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.80</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.80">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Drag to rotate • Scroll to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.2;
        let pointSize = 0.39;
        let particleDensity = 13;
        let brightness = 1.8;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'circle';
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.1;
        let saturation = 0.80;
        let hideBackground = false;
        let bgThreshold = 40;

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Info mode - detailed screen information
        let infoMode = false;
        let infoSprites = [];

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 15, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: 'X' },
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = parseFloat(slider.value);
                    } else {
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = '⏸ Pause';
            } else {
                video.pause();
                btn.textContent = '▶ Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Spacebar to play/pause, I key for info mode
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }
            // I key to toggle detailed info mode
            if (e.code === 'KeyI') {
                e.preventDefault();
                toggleInfoMode();
            }
        });

        // Create text sprite for 3D labels
        function createTextSprite(text, parameters) {
            if (parameters === undefined) parameters = {};
            const fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Courier New";
            const fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
            const backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : { r: 0, g: 0, b: 0, a: 0.8 };
            const textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : { r: 255, g: 255, b: 255, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = fontsize + "px " + fontface;

            // Split text by lines
            const lines = text.split('\n');
            const lineHeight = fontsize * 1.2;

            // Measure max width
            let maxWidth = 0;
            lines.forEach(line => {
                const metrics = context.measureText(line);
                maxWidth = Math.max(maxWidth, metrics.width);
            });

            // Set canvas size
            canvas.width = maxWidth + 20;
            canvas.height = (lines.length * lineHeight) + 20;

            // Re-set font after canvas resize
            context.font = fontsize + "px " + fontface;
            context.textAlign = "left";
            context.textBaseline = "top";

            // Background
            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            context.fillStyle = "rgba(" + textColor.r + "," + textColor.g + "," + textColor.b + "," + textColor.a + ")";
            lines.forEach((line, i) => {
                context.fillText(line, 10, 10 + (i * lineHeight));
            });

            // Create sprite
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Scale sprite (canvas is in pixels, scale to world units)
            const scale = 0.5;
            sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);

            return sprite;
        }

        // Toggle detailed info mode - show 3D labels on screens
        function toggleInfoMode() {
            infoMode = !infoMode;

            if (infoMode) {
                console.log('[INFO MODE] ENABLED - Showing 3D labels on screens');

                if (screensGroup && screensGroup.children.length > 0) {
                    screensGroup.updateMatrixWorld(true);

                    // Get screen dimensions
                    const TARGET_WIDTH = 800;
                    const TARGET_HEIGHT = 450;
                    const scaleFactor = 0.5;
                    const screenW = TARGET_WIDTH * scaleFactor;
                    const screenH = TARGET_HEIGHT * scaleFactor;

                    // Create label for each screen
                    screensGroup.children.forEach((screen, index) => {
                        const screenNum = index + 1;
                        const pos = screen.position;
                        const rot = screen.rotation;
                        const box = new THREE.Box3().setFromObject(screen);

                        // Build text for this screen
                        let labelText = `ECRAN #${screenNum}\n`;
                        labelText += `${getScreenName(index)}\n`;
                        labelText += `\n`;
                        labelText += `POS: X=${pos.x.toFixed(1)} Y=${pos.y.toFixed(1)} Z=${pos.z.toFixed(1)}\n`;
                        labelText += `ROT: X=${(rot.x * 180 / Math.PI).toFixed(0)}° Y=${(rot.y * 180 / Math.PI).toFixed(0)}° Z=${(rot.z * 180 / Math.PI).toFixed(0)}°\n`;
                        labelText += `\n`;
                        labelText += `EDGES:\n`;
                        labelText += `TOP: Y=${box.max.y.toFixed(1)}\n`;
                        labelText += `BOTTOM: Y=${box.min.y.toFixed(1)}\n`;
                        labelText += `LEFT: X=${box.min.x.toFixed(1)}\n`;
                        labelText += `RIGHT: X=${box.max.x.toFixed(1)}\n`;
                        labelText += `FRONT: Z=${box.max.z.toFixed(1)}\n`;
                        labelText += `BACK: Z=${box.min.z.toFixed(1)}\n`;
                        labelText += `\n`;
                        labelText += `TYPE: ${getScreenType(rot)}\n`;
                        labelText += `FACE: ${getFaceDirection(rot)}`;

                        // Create sprite
                        const sprite = createTextSprite(labelText, {
                            fontsize: 14,
                            backgroundColor: { r: 0, g: 0, b: 0, a: 0.9 },
                            textColor: { r: 0, g: 255, b: 255, a: 1.0 }
                        });

                        // Position sprite in front of screen center
                        const center = box.getCenter(new THREE.Vector3());

                        // Offset sprite forward based on screen orientation
                        const normal = new THREE.Vector3(0, 0, 1);
                        normal.applyEuler(screen.rotation);
                        sprite.position.copy(center).add(normal.multiplyScalar(50));

                        scene.add(sprite);
                        infoSprites.push(sprite);
                    });

                } else {
                    console.log('⚠️  No screens found in screensGroup');
                }

                console.log('[INFO MODE] 3D labels displayed - Press I to hide');

            } else {
                // Remove all sprites
                infoSprites.forEach(sprite => {
                    scene.remove(sprite);
                    if (sprite.material.map) sprite.material.map.dispose();
                    sprite.material.dispose();
                });
                infoSprites = [];
                console.log('[INFO MODE] DISABLED');
            }
        }

        // Helper functions for descriptions
        function getScreenName(index) {
            const names = [
                'Wall Back Left (particles)',
                'Wall Back Right (particlesRight)',
                'Floor Left (floorLeft)',
                'Floor Right (floorRight)',
                'Wall Front Left (wallOppA)',
                'Wall Front Right (wallOppB)'
            ];
            return names[index] || `Screen ${index + 1}`;
        }

        function getXDescription(x, screenW) {
            if (Math.abs(x) < 0.01) return 'left edge';
            if (Math.abs(x - screenW) < 0.01) return 'right edge';
            if (Math.abs(x - screenW/2) < 0.01) return 'centered';
            return x < screenW/2 ? 'left side' : 'right side';
        }

        function getYDescription(y, screenH) {
            if (Math.abs(y) < 0.01) return 'centered vertically';
            if (Math.abs(y + screenH/2) < 0.01) return 'bottom edge';
            if (Math.abs(y - screenH/2) < 0.01) return 'top edge';
            return y < 0 ? 'below center' : 'above center';
        }

        function getZDescription(z, screenH) {
            if (Math.abs(z) < 0.01) return 'back wall';
            if (Math.abs(z - screenH) < 0.01) return 'front wall';
            if (Math.abs(z - screenH/2) < 0.01) return 'middle depth';
            return z < screenH/2 ? 'closer to back' : 'closer to front';
        }

        function getRotXDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'vertical (no tilt)';
            if (Math.abs(deg + 90) < 1) return 'horizontal (floor)';
            if (Math.abs(deg - 90) < 1) return 'horizontal (ceiling)';
            return deg < 0 ? 'tilted down' : 'tilted up';
        }

        function getRotYDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'facing +Z (forward)';
            if (Math.abs(deg - 90) < 1) return 'facing +X (right)';
            if (Math.abs(deg + 90) < 1) return 'facing -X (left)';
            if (Math.abs(Math.abs(deg) - 180) < 1) return 'facing -Z (backward)';
            return 'angled';
        }

        function getRotZDescription(radians) {
            const deg = radians * 180 / Math.PI;
            if (Math.abs(deg) < 1) return 'not rolled';
            return 'rolled ' + deg.toFixed(1) + '°';
        }

        function getFaceDirection(rotation) {
            const y = rotation.y * 180 / Math.PI;
            if (Math.abs(y) < 45) return '+Z (forward)';
            if (Math.abs(y - 90) < 45) return '+X (right)';
            if (Math.abs(y + 90) < 45) return '-X (left)';
            if (Math.abs(Math.abs(y) - 180) < 45) return '-Z (backward)';
            return 'angled';
        }

        function getScreenType(rotation) {
            const x = Math.abs(rotation.x * 180 / Math.PI);
            if (x < 45) return 'VERTICAL WALL';
            if (x > 135) return 'VERTICAL WALL (inverted)';
            return 'HORIZONTAL (floor/ceiling)';
        }

        function analyzeHinges(group) {
            const screens = group.children;
            if (screens.length < 2) return;

            // Common hinges to check
            const hingeChecks = [
                { name: 'Wall-Floor Hinge (left)', screen1: 0, screen2: 2, edge1: 'bottom', edge2: 'top', axis: 'Y' },
                { name: 'Wall-Floor Hinge (right)', screen1: 1, screen2: 3, edge1: 'bottom', edge2: 'top', axis: 'Y' },
                { name: 'Floor-FrontWall Hinge (left)', screen1: 2, screen2: 4, edge1: 'front', edge2: 'bottom', axis: 'Y' },
                { name: 'Floor-FrontWall Hinge (right)', screen1: 3, screen2: 5, edge1: 'front', edge2: 'bottom', axis: 'Y' },
                { name: 'BackWall Left-Right', screen1: 0, screen2: 1, edge1: 'right', edge2: 'left', axis: 'X' },
                { name: 'FrontWall Left-Right', screen1: 4, screen2: 5, edge1: 'right', edge2: 'left', axis: 'X' }
            ];

            hingeChecks.forEach(check => {
                if (check.screen1 < screens.length && check.screen2 < screens.length) {
                    const box1 = new THREE.Box3().setFromObject(screens[check.screen1]);
                    const box2 = new THREE.Box3().setFromObject(screens[check.screen2]);

                    let val1, val2, gap;
                    if (check.axis === 'Y') {
                        val1 = check.edge1 === 'bottom' ? box1.min.y : (check.edge1 === 'top' ? box1.max.y : box1.max.z);
                        val2 = check.edge2 === 'top' ? box2.max.y : (check.edge2 === 'bottom' ? box2.min.y : box2.min.y);
                    } else if (check.axis === 'X') {
                        val1 = check.edge1 === 'right' ? box1.max.x : box1.min.x;
                        val2 = check.edge2 === 'left' ? box2.min.x : box2.max.x;
                    } else {
                        val1 = box1.max.z;
                        val2 = box2.min.z;
                    }

                    gap = Math.abs(val1 - val2);
                    const status = gap < 0.1 ? '✅ GOOD' : (gap < 1 ? '⚠️  SMALL GAP' : '❌ GAP');

                    console.log(`  ${check.name}:`);
                    console.log(`    Edge 1 (${getScreenName(check.screen1)}): ${val1.toFixed(3)}`);
                    console.log(`    Edge 2 (${getScreenName(check.screen2)}): ${val2.toFixed(3)}`);
                    console.log(`    Gap: ${gap.toFixed(6)} ${status}`);
                    console.log('');
                }
            });
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            if (typeof THREE === 'undefined') {
                alert('THREE.js failed to load.');
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);

            // Calculate 16:9 aspect ratio dimensions
            const aspectRatio = 16 / 9;
            let canvasWidth, canvasHeight;

            if (window.innerWidth / window.innerHeight > aspectRatio) {
                // Window is wider than 16:9, fit to height
                canvasHeight = window.innerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // Window is taller than 16:9, fit to width
                canvasWidth = window.innerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }

            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasWidth, canvasHeight);
            document.getElementById('canvas').appendChild(renderer.domElement);

            // Add lighting for 3D mode
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -0.5);
            scene.add(directionalLight2);

            // Mouse control
            let isDrag = false;
            let prevMouse = { x: 0, y: 0 };

            renderer.domElement.onmousedown = function(e) {
                isDrag = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            };

            renderer.domElement.onmousemove = function(e) {
                if (!isDrag || !screensGroup) return;
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                screensGroup.rotation.y += dx * 0.005;
                screensGroup.rotation.x += dy * 0.005;
                prevMouse = { x: e.clientX, y: e.clientY };
            };

            document.onmouseup = function() {
                isDrag = false;
            };

            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 : -1;
                camera.position.z += delta * zoomSpeed * camera.position.z;
                camera.position.z = Math.max(50, Math.min(1000, camera.position.z));
            });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            animate();
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Show preview
                document.getElementById('preview').innerHTML = '<video src="' + url + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                document.getElementById('preview').classList.add('loaded');
                document.getElementById('preview').querySelector('video').play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 13;
                    document.getElementById('depth').value = 0.2;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.8;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');

                    document.getElementById('load-section').classList.add('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    document.getElementById('shape-selector').classList.remove('hidden');
                }

                // Auto-play
                videoElement.play();
                generate(videoElement);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        function generate(video) {
            if (typeof THREE === 'undefined') {
                alert('THREE.js not loaded.');
                return;
            }

            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value);
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Optimized: reduced resolution for better performance without visual quality loss
            const TARGET_WIDTH = 800;
            const TARGET_HEIGHT = 450;
            const step = Math.max(1, Math.floor(10 / particleDensity));

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            const positions = [];
            const colors = [];
            const initialZ = [];

            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 — Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);

                        // v1.3.1 — Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                const cullThreshold = minZ + zRange * depthCullPower;

                // Remove particles below threshold (make them black = invisible)
                for (let i = 0; i < initialZ.length; i++) {
                    const z = initialZ[i];
                    if (z < cullThreshold) {
                        // Set to pure black = invisible
                        colors[i * 3] = 0;
                        colors[i * 3 + 1] = 0;
                        colors[i * 3 + 2] = 0;
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // Clear group before adding new screens
            screensGroup.clear();

            if (is3DMode) {
                // 3D Mode: Use InstancedMesh with real 3D geometries
                const count = positions.length / 3;
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    flatShading: true,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x000000,
                    emissiveIntensity: 0.2
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    instanceColors[i * 3] = colors[i * 3];
                    instanceColors[i * 3 + 1] = colors[i * 3 + 1];
                    instanceColors[i * 3 + 2] = colors[i * 3 + 2];
                }
                particles.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);

                // Optimization: reuse matrix and color objects
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    particles.setColorAt(i, reusableColor);
                }

                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Use Points with VIDEO texture
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));

                // Create video texture
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const shapeTexture = getShapeTexture(currentShape);

                material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    map: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
            }

            // Volumétrie unilatérale : les particules sombres restent à z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des écrans : z=0 invariant au DEPTH SPREAD

            // Position first screen at origin (fixed)
            particles.position.set(0, 0, 0);

            // Add first screen to group
            screensGroup.add(particles);

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // Clone and position second screen to the right
            const particlesRight = particles.clone();

            // Ensure both screens share the same geometry and material
            particlesRight.geometry = particles.geometry;
            particlesRight.material = particles.material;

            // Position second screen to the right, touching the first (fixed spacing)
            particlesRight.position.set(screenW, 0, 0);

            // Add second screen to group
            screensGroup.add(particlesRight);

            // Create floor left as clone of particles
            const floorLeft = particles.clone();
            floorLeft.geometry = particles.geometry;
            floorLeft.material = particles.material;

            // Rotate to horizontal (lie flat on ground)
            floorLeft.rotation.x = -Math.PI / 2;

            // Position: hinge top edge of floor to bottom edge of wall
            // Floor center at z = screenH/2 to align with wall base
            floorLeft.position.set(0, wallBottomY, screenH / 2);

            // Add to group
            screensGroup.add(floorLeft);

            // Create floor right as clone of particlesRight
            const floorRight = particlesRight.clone();
            floorRight.geometry = particles.geometry;
            floorRight.material = particles.material;

            // Rotate to horizontal
            floorRight.rotation.x = -Math.PI / 2;

            // Position: hinge top edge of floor to bottom edge of wall
            // Floor center at z = screenH/2 to align with wall base
            floorRight.position.set(screenW, wallBottomY, screenH / 2);

            // Add to group
            screensGroup.add(floorRight);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // Clone left wall screen for opposite wall A
            const wallOppA = particles.clone();
            wallOppA.geometry = particles.geometry;
            wallOppA.material = particles.material;

            // Place it at the end of the floor (z = screenH), same Y center as wall
            wallOppA.position.set(0, 0, screenH);

            // Make it face inward (toward -Z)
            wallOppA.rotation.set(0, 0, 0);
            wallOppA.rotateY(Math.PI);

            screensGroup.add(wallOppA);

            // Clone right wall screen for opposite wall B
            const wallOppB = particlesRight.clone();
            wallOppB.geometry = particles.geometry;
            wallOppB.material = particles.material;

            wallOppB.position.set(screenW, 0, screenH);
            wallOppB.rotation.set(0, 0, 0);
            wallOppB.rotateY(Math.PI);

            screensGroup.add(wallOppB);

            // === ÉCRAN 7: panneau latéral collé sur le côté droit de l'écran 6 ===
            // Update world matrix pour avoir les positions réelles
            screensGroup.updateMatrixWorld(true);

            // Calculer la Box3 de l'écran 6 (wallOppB)
            const box6 = new THREE.Box3().setFromObject(wallOppB);

            console.log('=== ÉCRAN 7 PLACEMENT ===');
            console.log('Écran 6 (wallOppB) Box3:', {
                min: box6.min.toArray().map(v => v.toFixed(2)),
                max: box6.max.toArray().map(v => v.toFixed(2))
            });

            // Créer l'écran 7
            const screen7 = particles.clone();
            screen7.geometry = particles.geometry;
            screen7.material = particles.material;

            // Position initiale temporaire
            screen7.position.set(0, 0, 0);

            // Rotation: perpendiculaire à l'écran 6 (tourné de 90° par rapport à lui)
            // L'écran 6 a rotation Y = π, donc l'écran 7 doit avoir Y = π/2 ou -π/2
            screen7.rotation.set(0, Math.PI / 2, 0);

            // Ajouter temporairement pour calculer sa Box3
            screensGroup.add(screen7);
            screensGroup.updateMatrixWorld(true);

            // Calculer sa Box3 actuelle
            const box7 = new THREE.Box3().setFromObject(screen7);

            console.log('Écran 7 Box3 (avant placement):', {
                min: box7.min.toArray().map(v => v.toFixed(2)),
                max: box7.max.toArray().map(v => v.toFixed(2))
            });

            // PLACEMENT PRÉCIS : coller l'écran 7 sur le côté droit de l'écran 6
            // - Son min.x collé au max.x de l'écran 6
            // - Son centre Y aligné avec le centre Y de l'écran 6
            // - Son centre Z aligné avec le centre Z de l'écran 6

            const center6 = new THREE.Vector3();
            const center7 = new THREE.Vector3();
            box6.getCenter(center6);
            box7.getCenter(center7);

            const deltaX = box6.max.x - box7.min.x;
            const deltaY = center6.y - center7.y;
            const deltaZ = center6.z - center7.z;

            console.log('Deltas à appliquer:', {
                deltaX: deltaX.toFixed(2),
                deltaY: deltaY.toFixed(2),
                deltaZ: deltaZ.toFixed(2)
            });

            // Appliquer les deltas
            screen7.position.add(new THREE.Vector3(deltaX, deltaY, deltaZ));

            // Vérification finale
            screensGroup.updateMatrixWorld(true);
            const box7Final = new THREE.Box3().setFromObject(screen7);

            console.log('Écran 7 Box3 (après placement):', {
                min: box7Final.min.toArray().map(v => v.toFixed(2)),
                max: box7Final.max.toArray().map(v => v.toFixed(2))
            });
            console.log('Écran 7 position finale:', screen7.position.toArray().map(v => v.toFixed(2)));
            console.log('=========================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 13;
            document.getElementById('depth').value = 0.2;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.80;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.80;
            hideBackground = false;
            bgThreshold = 40;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            if (currentVideo.paused) return;

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // v1.3.1 — Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Skip if hideBlack and below threshold (but keep same particle count)
                        if (hideBlack && maxColor < blackThreshold) {
                            newColors.push(0, 0, 0);
                        } else {
                            // v1.3.1 — Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Update color with brightness boost
                            newColors.push(
                                Math.min(1.0, rNorm * brightness),
                                Math.min(1.0, gNorm * brightness),
                                Math.min(1.0, bNorm * brightness)
                            );
                        }
                    }
                }
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                const cullThreshold = minZ + zRange * depthCullPower;

                // Remove particles below threshold (make them black = invisible)
                for (let i = 0; i < newDepths.length; i++) {
                    const z = newDepths[i];
                    if (z < cullThreshold) {
                        // Set to pure black = invisible
                        newColors[i * 3] = 0;
                        newColors[i * 3 + 1] = 0;
                        newColors[i * 3 + 2] = 0;
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation
                if (particles.userData.initialZ) {
                    for (let i = 0; i < newDepths.length; i++) {
                        particles.userData.initialZ[i] = newDepths[i];
                    }
                }
            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        initialZArray[i] = newDepths[i];
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                }
            }
        }

        // Animation with subtle breathing movement and video texture updates
        function animate() {
            requestAnimationFrame(animate);

            time += 0.001 * breathSpeed;

            // Update particle colors from current video frame (both 2D and 3D modes)
            if (currentVideo) {
                updateColorsFromVideo();
            }

            // Update video texture
            if (videoTexture && currentVideo) {
                videoTexture.needsUpdate = true;
            }

            if (particles && flowOffsets) {
                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {
                        // Optimization: reuse matrix object instead of creating new one
                        const epsilon = 0.3 * breathSpeed;

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            const newZ = initialZs[i] + breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }
                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        positions[i * 3 + 2] = initialZs[i] + breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;
                }
            }

            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Maintain 16:9 aspect ratio
            const aspectRatio = 16 / 9;
            let canvasWidth, canvasHeight;

            if (window.innerWidth / window.innerHeight > aspectRatio) {
                // Window is wider than 16:9, fit to height
                canvasHeight = window.innerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // Window is taller than 16:9, fit to width
                canvasWidth = window.innerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                scheduleRegenerate();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                if (currentVideo) generate(currentVideo);
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        window.onload = init;
    </script>
</body>
</html>
