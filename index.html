<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Dumbo</title>

    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="img/presences_rares_favicon_v2.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/presences_rares_favicon_v2.png">
    <link rel="apple-touch-icon" sizes="180x180" href="img/presences_rares_favicon_v2.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet">
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        :root {
            --textLeft: 240px;
            --textColW: 580px;
            --textTop: 150px;

            --logoSize: 104px;

            --playRight: 240px;
            --playBottom: 150px;

            --hoverTextShift: 90px;

            --clickTextExitX: 320px;
            --clickFadeMs: 320ms;
            --logoMoveMs: 420ms;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* ═══════════════════════════════════════════════════════════════
           GLOBAL MOBILE STYLES - Anti-comportements gênants
           ═══════════════════════════════════════════════════════════════ */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            touch-action: manipulation;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            /* Anti tap highlight */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            /* Prevent pull-to-refresh native sur body */
            overscroll-behavior: none;
            /* Safe areas iOS */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Désactiver sélection sur éléments interactifs */
        button, .play-button-container, .mute-button, #mobile-pause-btn, #mobile-joystick {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Focus sans outline intrusif */
        button:focus, *:focus {
            outline: none;
        }
        button:focus-visible {
            outline: 2px solid rgba(255,255,255,0.3);
            outline-offset: 2px;
        }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; }
        #canvas canvas { display: block; }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: 100; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
              padding: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
              max-width: 420px; width: 90%; transition: all 0.4s ease;
              max-height: 85vh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 320px; width: auto; padding: 16px;
                     max-height: calc(100vh - 40px); overflow-y: auto; cursor: move; user-select: none; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: 100;
                      text-decoration: none; color: #fff; transition: opacity 0.2s; }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 22px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: 11px; font-weight: 400; opacity: 0.5;
                    margin-top: 4px; letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: 8px 0; padding: 14px;
                 background: rgba(255,255,255,0.1); color: #fff;
                 border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
                 cursor: pointer; font-size: 12px; font-weight: 600;
                 transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.98); }

        button.small { padding: 8px; font-size: 10px; opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: 6px; margin: 8px 0;
                   display: flex; align-items: center; justify-content: center;
                   background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: 10px; opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: 11px; font-weight: 600; margin-top: 16px; display: block;
                text-transform: uppercase; letter-spacing: 0.8px; opacity: 0.7; }

        .hidden { display: none !important; }

        #controls { margin-top: 16px; padding-top: 16px;
                    border-top: 1px solid rgba(255,255,255,0.15); }

        .slider { width: 100%; height: 4px; border-radius: 2px;
                  background: rgba(255,255,255,0.15); outline: none;
                  -webkit-appearance: none; margin: 10px 0; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none;
                                         width: 18px; height: 18px; border-radius: 50%;
                                         background: #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%;
                                     background: #fff; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .value { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                 cursor: pointer; padding: 2px 6px; border-radius: 3px;
                 transition: background 0.2s; }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                       background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
                       color: #fff; padding: 2px 6px; border-radius: 3px; width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: 14px; }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: 8px; }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: 4px; align-items: center; }

        .arrow-btn { width: 20px; height: 20px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
                     border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: all 0.15s; line-height: 1; }
        .arrow-btn:hover { background: rgba(255,255,255,0.2); }
        .arrow-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: 9px; opacity: 0.3; margin-top: 10px; text-align: center;
                font-style: italic; }

        /* Custom scrollbar for UI */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: 100;
                          display: flex; gap: 8px; background: rgba(0,0,0,0.75);
                          backdrop-filter: blur(10px); padding: 8px; border-radius: 8px;
                          border: 1px solid rgba(255,255,255,0.2); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.1);
                     border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
                     color: #fff; font-size: 20px; cursor: pointer; transition: all 0.2s;
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: rgba(255,255,255,0.2); transform: none; }
        .shape-btn.active { background: rgba(255,255,255,0.3);
                            border-color: rgba(255,255,255,0.5); }

        #mode-3d-btn { width: auto; padding: 0 12px; font-size: 10px; margin-left: 8px;
                       border-left: 1px solid rgba(255,255,255,0.3); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: 100;
                           background: rgba(0,0,0,0.75); backdrop-filter: blur(10px);
                           padding: 8px 12px; border-radius: 6px;
                           border: 1px solid rgba(255,255,255,0.2);
                           font-size: 10px; cursor: pointer; transition: all 0.2s; }
        #version-selector:hover { background: rgba(0,0,0,0.85); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: 99;
                       background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
                       padding: 8px; border-radius: 6px;
                       border: 1px solid rgba(255,255,255,0.2);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: 8px 12px; cursor: pointer; font-size: 10px;
                       border-radius: 4px; margin: 2px 0; transition: all 0.2s;
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.1); }
        .version-item.current { background: rgba(255,255,255,0.15); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: 12px; }
        .video-control-btn { padding: 8px 12px; font-size: 10px; margin: 0; width: 100%; }

        .video-timeline { margin-top: 8px; }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 3px;
            transition: background 0.2s;
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(255,255,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }

        /* Screen Management UI - Sobre et professionnel */
        #screen-manager-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 300px;
            width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            cursor: move;
            user-select: none;
        }
        #screen-manager-panel.hidden { display: none; }
        #screen-manager-panel h2 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            opacity: 0.7;
            margin-bottom: 12px;
            font-weight: 600;
        }
        .screen-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 12px;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .screen-list::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        .screen-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .screen-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.2);
        }
        .screen-item.selected {
            border-color: rgba(100,150,255,0.5);
            background: rgba(100,150,255,0.08);
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-header .screen-num {
            font-weight: 600;
            font-size: 11px;
            color: rgba(255,255,255,0.9);
        }
        .screen-header .screen-delete {
            background: transparent;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            font-size: 20px;
            line-height: 20px;
            cursor: pointer;
            transition: all 0.2s;
            color: rgba(255,80,80,0.7);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .screen-header .screen-delete:hover {
            color: rgba(255,80,80,1);
            transform: scale(1.15);
        }
        .screen-type-selector {
            display: none; /* Retrait transformation forme→écran */
        }
        .screen-type-btn {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 6px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .screen-type-btn.active {
            background: rgba(100,150,255,0.2);
            border-color: rgba(100,150,255,0.5);
            color: rgba(255,255,255,1);
        }
        .screen-type-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .color-section {
            margin-top: 8px;
        }
        .color-section h4 {
            font-size: 9px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.05);
            border-color: rgba(255,255,255,0.3);
        }
        .color-option.active {
            border-color: rgba(100,150,255,0.9);
            box-shadow: 0 0 12px rgba(100,150,255,0.6);
            transform: scale(1.05);
        }
        .color-custom {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .color-custom input[type="color"] {
            width: 50px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
        }
        .color-custom input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .add-screen-btn {
            background: rgba(100,200,100,0.25);
            border: 1px solid rgba(100,200,100,0.4);
            margin-top: 8px;
            padding: 10px;
            width: 100%;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: all 0.2s;
        }
        .add-screen-btn:hover {
            background: rgba(100,200,100,0.35);
            border-color: rgba(100,200,100,0.6);
        }
        .screen-manager-hint {
            display: none; /* Retrait hints texte */
        }

        /* Cacher titre et version selector */
        #title-link, #version-selector, #version-menu {
            display: none !important;
        }

        /* Réduire taille interface réglages */
        #ui.loaded {
            max-width: 280px;
            padding: 12px;
        }

        /* FPS Settings Panel - Bottom Right (avoid overlap) */
        #fps-settings-panel {
            position: fixed;
            bottom: 20px;
            right: 360px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 350px;
            width: 350px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: white;
            font-size: 11px;
            cursor: move;
        }
        #fps-settings-panel.hidden { display: none !important; }
        #fps-settings-panel h3 {
            margin: 0 0 12px 0;
            font-size: 11px;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding-right: 25px;
        }
        .fps-param {
            margin-bottom: 5px;
        }
        .fps-param label {
            display: block;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .fps-param input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        .fps-param input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        .fps-param input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
        }
        .fps-param-value {
            display: inline-block;
            float: right;
            color: #00ff88;
            font-weight: 600;
            font-size: 11px;
        }
        #fps-export-btn {
            margin-top: 10px;
            width: 100%;
            padding: 8px;
            background: rgba(0,255,136,0.15);
            border: 1px solid #00ff88;
            border-radius: 4px;
            color: #00ff88;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #fps-export-btn:hover {
            background: rgba(0,255,136,0.25);
        }

        /* Video Paused Indicator */
        #video-paused-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background: rgba(255, 100, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid rgba(255, 150, 0, 0.8);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #video-paused-indicator.visible {
            opacity: 1;
        }

        /* Welcome Screen - Page d'accueil */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10001;
            transition: opacity 0.6s ease;
            overflow: hidden;
        }
        #welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #welcome-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 40%, rgba(0,0,0,0) 60%, transparent 100%);
            z-index: 1;
            pointer-events: none;
        }
        #welcome-video-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #welcome-video-bg.loaded {
            opacity: 1;
        }
        .welcome-content {
            position: absolute;
            left: var(--textLeft);
            top: 50%;
            transform: translateY(-50%);
            width: var(--textColW);
            max-width: 580px; /* ~60-65 caractères par ligne */
            z-index: 2;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity var(--clickFadeMs) ease;
        }
        body.hoverPlay .welcome-content {
            transform: translateY(-50%) translateX(var(--hoverTextShift));
        }
        body.clickedPlay .welcome-content {
            opacity: 0;
            transform: translateY(-50%) translateX(var(--clickTextExitX));
        }
        .welcome-project-name {
            font-family: 'Inter', sans-serif;
            font-size: 64px;
            font-weight: 700;
            letter-spacing: 8px;
            margin-bottom: 2px;
            color: rgba(255,255,255,0.98);
            line-height: 1.1;
            text-transform: uppercase;
            display: block;
        }
        .welcome-title {
            font-family: 'Inter', sans-serif;
            font-size: 22px;
            font-weight: 500;
            letter-spacing: 1.5px;
            margin-bottom: 40px;
            color: rgba(255,255,255,0.95);
            line-height: 1.4;
            text-transform: uppercase;
        }
        .welcome-subtitle-inline {
            font-size: 13px;
            font-weight: 300;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.60);
            text-transform: none;
        }
        .welcome-text {
            font-family: 'Inter', sans-serif;
            font-size: 15px;
            font-weight: 300;
            color: rgba(255,255,255,0.70);
            line-height: 1.9;
            margin-bottom: 20px;
            letter-spacing: 0.3px;
            text-align: justify;
        }
        .welcome-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        /* Phrase manifeste - style affirmé */
        .welcome-manifesto {
            font-family: 'Inter', sans-serif;
            font-size: 17px;
            font-weight: 400;
            color: rgba(255,255,255,0.95);
            line-height: 1.6;
            margin-bottom: 32px;
            letter-spacing: 0.2px;
            text-align: left;
        }
        .welcome-context {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255,255,255,0.35);
            line-height: 1.7;
            margin-top: 50px;
            padding-top: 25px;
            border-top: 1px solid rgba(255,255,255,0.08);
            letter-spacing: 0.3px;
        }
        .play-button-container {
            position: absolute;
            bottom: var(--playBottom);
            right: var(--playRight);
            cursor: pointer;
            z-index: 3;
            width: 208px;
            height: 209px;
            transition: opacity var(--clickFadeMs) ease;
        }
        body.clickedPlay .play-button-container {
            opacity: 0;
        }
        /* Desktop play visible, mobile play cache par defaut */
        .play-button-container.mobile-play {
            display: none;
        }
        .play-button-container.desktop-play {
            display: block;
        }
        .play-button-container .play-rond,
        .play-button-container .play-fleche {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .play-button-container .play-rond {
            width: 208px;
            height: 209px;
            animation: playRondRotate 6s linear infinite;
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-rond {
            transform: scale(1.05);
        }
        @keyframes playRondRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        body.hoverPlay .play-button-container .play-rond {
            animation: playRondRotateHover 6s linear infinite;
        }
        @keyframes playRondRotateHover {
            from { transform: rotate(0deg) scale(1.05); }
            to { transform: rotate(360deg) scale(1.05); }
        }
        .play-button-container .play-fleche {
            width: 80px;
            height: 105px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) translateX(4px);
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-fleche {
            transform: translate(-50%, -50%) translateX(4px) scale(1.08);
        }

        /* Logo container - PNG et WEBM */
        .welcome-logo-container {
            position: absolute;
            left: calc(var(--textLeft) / 2);
            top: 50%;
            transform: translate(-50%, -50%);
            width: var(--logoSize);
            height: var(--logoSize);
            z-index: 2;
            transition: all var(--logoMoveMs) cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Recentrage du logo lors du hover */
        body.hoverPlay .welcome-logo-container {
            left: calc((var(--textLeft) + var(--hoverTextShift)) / 2);
        }

        /* Centrage final lors du click */
        body.clickedPlay .welcome-logo-container {
            left: 50vw;
            top: 50vh;
        }

        .welcome-logo,
        .welcome-logo-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .welcome-logo {
            transition: opacity 0.2s ease;
        }

        .welcome-logo-video {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .welcome-logo-video.active {
            opacity: 1;
        }

        /* Pause Screen - Ultra Modern */
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.75);
            backdrop-filter: blur(30px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            cursor: pointer;
            transition: opacity 0.4s ease;
        }
        #pause-screen.active {
            display: flex;
        }
        .pause-content {
            max-width: 850px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(40px);
            border: none;
            border-radius: 0;
            padding: 60px 70px;
            text-align: left;
            box-shadow: 0 10px 60px rgba(0,0,0,0.6);
            pointer-events: all;
            cursor: default;
        }
        .pause-title {
            font-family: 'Inter', sans-serif;
            font-size: 26px;
            font-weight: 500;
            color: rgba(255,255,255,0.95);
            margin-bottom: 35px;
            letter-spacing: 1.2px;
            text-transform: uppercase;
        }
        .pause-text {
            font-family: 'Inter', sans-serif;
            font-size: 17px;
            font-weight: 300;
            color: rgba(255,255,255,0.70);
            line-height: 1.9;
            margin-bottom: 22px;
            letter-spacing: 0.3px;
        }
        .pause-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        /* Liste conceptuelle - sans décoration */
        .pause-conceptual-list {
            font-family: 'Inter', sans-serif;
            font-size: 17px;
            font-weight: 300;
            color: rgba(255,255,255,0.70);
            line-height: 2.2;
            margin: 22px 0;
            letter-spacing: 0.3px;
        }
        .pause-conceptual-list .list-intro {
            display: block;
            margin-bottom: 12px;
            line-height: 1.9;
        }
        .pause-conceptual-list .list-item {
            display: block;
            color: rgba(255,255,255,0.80);
        }
        .pause-meta {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255,255,255,0.35);
            line-height: 1.7;
            margin-top: 35px;
            padding-top: 25px;
            border-top: 1px solid rgba(255,255,255,0.08);
            letter-spacing: 0.3px;
        }
        .pause-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10000;
        }
        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            height: auto;
            justify-content: center;
            position: relative;
        }
        .volume-slider-container {
            height: 0;
            overflow: hidden;
            opacity: 0;
            transition: height 0.3s ease, opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .volume-control.active .volume-slider-container {
            height: 130px;
            opacity: 1;
        }
        .volume-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .volume-slider {
            width: 120px;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            transform: rotate(-90deg);
            transform-origin: center;
        }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: none;
        }
        .mute-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #ffffff;
            padding: 12px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .mute-button:hover {
            background: rgba(255,255,255,0.15);
        }
        .mute-button.muted {
            background: rgba(255,100,100,0.2);
            border-color: rgba(255,100,100,0.4);
        }
        .pause-credits {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255,255,255,0.3);
            font-style: italic;
        }

        /* Game Instructions (top-left) */
        .game-instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 18px 22px;
            font-size: 16px;
            color: rgba(255,255,255,0.95);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.6s ease;
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.4px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .game-instructions.hidden {
            opacity: 0;
        }
        .instruction-row {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 16px;
            line-height: 1.35;
        }
        .keys-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .game-instructions .key {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            padding: 10px 14px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.6);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: rgba(255,255,255,1);
            font-weight: 600;
            white-space: nowrap;
        }
        .arrows-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, auto);
            grid-template-rows: repeat(2, auto);
            gap: 2px;
        }
        .arrows-grid .key {
            padding: 6px 10px;
            font-size: 12px;
            line-height: 1;
        }
        .arrows-grid .key:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }
        .arrows-grid .key:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }
        .arrows-grid .key:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }
        .arrows-grid .key:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }
        .or-text {
            font-size: 13px;
            opacity: 0.7;
            font-style: italic;
        }

        /* Instructions in pause screen - positioned like game-instructions */
        .pause-instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 18px 22px;
            font-size: 16px;
            color: rgba(255,255,255,0.95);
            z-index: 10001;
            opacity: 1;
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.4px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .pause-instructions .instruction-row {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 16px;
            line-height: 1.35;
        }
        .pause-instructions .keys-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pause-instructions .key {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            padding: 10px 14px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.6);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: rgba(255,255,255,1);
            font-weight: 600;
            white-space: nowrap;
        }
        .pause-instructions .arrows-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, auto);
            grid-template-rows: repeat(2, auto);
            gap: 2px;
        }
        .pause-instructions .arrows-grid .key {
            padding: 6px 10px;
            font-size: 12px;
            line-height: 1;
        }
        .pause-instructions .arrows-grid .key:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }
        .pause-instructions .arrows-grid .key:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }
        .pause-instructions .arrows-grid .key:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }
        .pause-instructions .arrows-grid .key:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }
        .pause-instructions .or-text {
            font-size: 13px;
            opacity: 0.7;
            font-style: italic;
        }

        /* Initial Page Loader - visible immediately */
        #initial-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            z-index: 99999;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #initial-loader.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #loading-screen.active {
            display: flex;
            opacity: 1;
        }

        #loading-screen.hidden {
            opacity: 0;
        }

        .loading-video {
            width: 104px;
            height: 104px;
            opacity: 0.9;
            object-fit: contain;
        }

        /* Panel Close Button (X) */
        .panel-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        .panel-close-btn:hover {
            color: rgba(255,255,255,0.9);
            transform: scale(1.1);
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #00ff88;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #fps-counter .fps-value {
            font-size: 28px;
            font-weight: 700;
            display: block;
            line-height: 1;
            margin-bottom: 4px;
        }
        #fps-counter .fps-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        #fps-counter.low-fps {
            border-color: rgba(255, 100, 0, 0.5);
            color: #ff6400;
        }
        #fps-counter.critical-fps {
            border-color: rgba(255, 0, 0, 0.5);
            color: #ff0000;
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE UI COMPONENTS
           ═══════════════════════════════════════════════════════════════ */

        /* Pull-to-refresh indicator */
        #pull-to-refresh {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            z-index: 100000;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 0 0 12px 12px;
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            transition: transform 0.3s ease;
            display: none;
        }
        #pull-to-refresh.visible {
            display: block;
        }
        #pull-to-refresh.pulling {
            transform: translateX(-50%) translateY(0);
        }
        #pull-to-refresh .ptr-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        #pull-to-refresh.loading .ptr-spinner {
            animation: ptr-spin 0.8s linear infinite;
        }
        @keyframes ptr-spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Pause Button */
        #mobile-pause-btn {
            display: none;
            position: fixed;
            top: calc(20px + env(safe-area-inset-top));
            left: calc(20px + env(safe-area-inset-left));
            z-index: 10000;
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        #mobile-pause-btn:active {
            background: rgba(255,255,255,0.2);
            transform: scale(0.95);
        }

        /* Mobile Joystick */
        #mobile-joystick {
            display: none;
            position: fixed;
            bottom: calc(50px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: 9998;
            width: 120px;
            height: 120px;
            touch-action: none;
        }
        #mobile-joystick .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 50%;
        }
        #mobile-joystick .joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.25);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.15s;
        }
        #mobile-joystick.active .joystick-thumb {
            background: rgba(255,255,255,0.4);
        }

        /* Bouton Toggle Gyroscope */
        #gyro-toggle-btn {
            display: none;
            position: fixed;
            bottom: calc(50px + env(safe-area-inset-bottom));
            left: calc(20px + env(safe-area-inset-left));
            z-index: 9999;
            width: 48px;
            height: 48px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            padding: 0;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }
        #gyro-toggle-btn:active {
            background: rgba(255,255,255,0.2);
            transform: scale(0.95);
        }
        #gyro-toggle-btn.touch-mode {
            background: rgba(100,150,255,0.3);
            border-color: rgba(100,150,255,0.5);
        }
        #gyro-toggle-btn .gyro-icon,
        #gyro-toggle-btn .touch-icon {
            display: block;
        }
        #gyro-toggle-btn.touch-mode .gyro-icon {
            display: none;
        }
        #gyro-toggle-btn.touch-mode .touch-icon {
            display: block !important;
        }

        /* Mobile Instructions (remplace desktop instructions) */
        #mobile-instructions {
            display: none;
            position: fixed;
            top: calc(80px + env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0,0,0,0.65);
            backdrop-filter: blur(12px);
            padding: 14px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.08);
            text-align: left;
            font-size: 12px;
            color: rgba(255,255,255,0.85);
            max-width: 220px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #mobile-instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #mobile-instructions .instruction-line {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        #mobile-instructions .instruction-line:last-child {
            margin-bottom: 0;
        }
        #mobile-instructions .instruction-line.secondary {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
        }
        #mobile-instructions .instruction-svg {
            opacity: 0.7;
            flex-shrink: 0;
        }

        /* Gyroscope permission button */
        #gyro-permission-btn {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100001;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 30px 40px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }
        #gyro-permission-btn h3 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #fff;
        }
        #gyro-permission-btn p {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #gyro-permission-btn button {
            padding: 14px 32px;
            font-size: 14px;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            width: auto;
            margin: 0;
        }
        #gyro-permission-btn button:active {
            background: rgba(255,255,255,0.25);
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE RESPONSIVE STYLES
           ═══════════════════════════════════════════════════════════════ */
        @media (max-width: 768px), (pointer: coarse) {
            /* Variables mobiles */
            :root {
                --textLeft: clamp(20px, 5vw, 40px);
                --textColW: calc(100vw - clamp(40px, 10vw, 80px));
                --playRight: clamp(30px, 8vw, 60px);
                --playBottom: clamp(80px, 15vh, 120px);
                --logoSize: clamp(45px, 12vw, 55px); /* 1.5x plus petit */
                --hoverTextShift: 0px;
                --clickTextExitX: 100px;
            }

            /* Icone de chargement: meme taille que le logo */
            .loading-video {
                width: var(--logoSize) !important;
                height: var(--logoSize) !important;
            }

            /* Welcome screen mobile - hauteur dynamique, sans scrollbar */
            #welcome-screen {
                height: 100dvh;
                height: -webkit-fill-available;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none; /* Firefox */
                -ms-overflow-style: none; /* IE/Edge */
            }
            #welcome-screen::-webkit-scrollbar {
                display: none; /* Chrome/Safari */
            }

            /* Logo mobile: top center */
            .welcome-logo-container {
                left: 50% !important;
                top: calc(60px + env(safe-area-inset-top)) !important;
                transform: translate(-50%, 0) !important;
            }
            body.hoverPlay .welcome-logo-container {
                left: 50% !important;
                transform: translate(-50%, 0) !important;
            }
            body.clickedPlay .welcome-logo-container {
                left: 50vw !important;
                top: 50vh !important;
                transform: translate(-50%, -50%) !important;
            }

            /* Texte mobile: centre, forme plus proche du desktop */
            .welcome-content {
                left: 50% !important;
                top: calc(140px + env(safe-area-inset-top) + var(--logoSize)) !important;
                transform: translateX(-50%) !important;
                width: calc(100vw - 40px) !important;
                max-width: 500px !important;
                padding-right: 0;
                padding-bottom: 40px;
                text-align: left;
            }
            body.hoverPlay .welcome-content {
                transform: translateX(-50%) !important;
            }
            body.clickedPlay .welcome-content {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) !important;
            }

            /* Textes plus petits */
            .welcome-project-name {
                font-size: clamp(28px, 8vw, 42px);
                letter-spacing: 4px;
            }
            .welcome-title {
                font-size: clamp(14px, 4vw, 18px);
                margin-bottom: 24px;
            }
            .welcome-subtitle-inline {
                font-size: clamp(10px, 3vw, 12px);
            }
            .welcome-manifesto {
                font-size: clamp(14px, 3.5vw, 16px);
                margin-bottom: 20px;
            }
            .welcome-text {
                font-size: clamp(12px, 3vw, 14px);
                line-height: 1.7;
                margin-bottom: 16px;
            }
            .welcome-context {
                font-size: clamp(9px, 2.5vw, 11px);
                margin-top: 30px;
                padding-top: 20px;
            }

            /* Boutons play: mobile visible, desktop cache */
            .play-button-container.mobile-play {
                display: block !important;
                position: relative !important;
                bottom: auto !important;
                right: auto !important;
                margin: 50px auto 30px auto;
                width: clamp(90px, 22vw, 120px);
                height: clamp(90px, 22vw, 120px);
            }
            .play-button-container.desktop-play {
                display: none !important;
            }
            .play-button-container .play-rond {
                width: 100%;
                height: 100%;
            }
            .play-button-container .play-fleche {
                width: 40%;
                height: 50%;
            }

            /* Gradient adapté mobile */
            #welcome-screen::before {
                background: linear-gradient(to bottom,
                    rgba(0,0,0,0.9) 0%,
                    rgba(0,0,0,0.7) 20%,
                    rgba(0,0,0,0.4) 50%,
                    rgba(0,0,0,0.7) 80%,
                    rgba(0,0,0,0.95) 100%
                );
            }

            /* Afficher UI mobile */
            #mobile-pause-btn {
                display: flex;
            }
            #mobile-joystick {
                display: block;
            }
            #mobile-instructions {
                display: block;
            }

            /* Cacher UI desktop */
            .game-instructions,
            .pause-instructions {
                display: none !important;
            }

            /* Pause screen mobile - compact */
            .pause-content {
                max-width: 85vw;
                width: auto;
                padding: 22px 20px;
                margin: 15px;
                max-height: calc(100dvh - 280px);
                overflow-y: auto;
                font-size: 13px;
            }
            .pause-title {
                font-size: clamp(15px, 4vw, 18px);
                margin-bottom: 18px;
            }
            .pause-text {
                font-size: clamp(11px, 3vw, 13px);
                line-height: 1.6;
                margin-bottom: 14px;
            }
            .pause-conceptual-list {
                font-size: clamp(11px, 3vw, 13px);
                line-height: 1.8;
            }
            .pause-conceptual-list .list-intro {
                margin-bottom: 8px;
            }
            .pause-meta {
                font-size: clamp(8px, 2.5vw, 10px);
                margin-top: 20px;
                padding-top: 15px;
            }
            .pause-controls {
                bottom: calc(15px + env(safe-area-inset-bottom));
                right: calc(15px + env(safe-area-inset-right));
            }
            /* Cacher le volume sur mobile */
            .volume-control {
                display: none !important;
            }

            /* FPS counter plus discret sur mobile */
            #fps-counter {
                display: none;
            }

            /* Admin panels cachés sur mobile */
            #screen-manager-panel,
            #fps-settings-panel,
            #shape-selector,
            #version-selector,
            #ui {
                display: none !important;
            }
        }

        /* Très petits écrans */
        @media (max-width: 375px) {
            .welcome-content {
                padding-bottom: 180px;
            }
            .play-button-container {
                width: 90px;
                height: 90px;
            }
            #mobile-joystick {
                width: 100px;
                height: 100px;
            }
            #mobile-joystick .joystick-thumb {
                width: 40px;
                height: 40px;
            }
        }

        /* Paysage mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .welcome-logo-container {
                top: calc(20px + env(safe-area-inset-top)) !important;
                left: calc(60px + env(safe-area-inset-left)) !important;
                transform: translate(0, 0) !important;
            }
            .welcome-content {
                top: calc(20px + env(safe-area-inset-top)) !important;
                left: calc(150px + env(safe-area-inset-left)) !important;
                width: calc(60vw - 150px) !important;
                padding-bottom: 20px;
            }
            .play-button-container {
                right: calc(40px + env(safe-area-inset-right)) !important;
                bottom: 50% !important;
                transform: translateY(50%);
            }
            #mobile-joystick {
                left: calc(80px + env(safe-area-inset-left));
                transform: none;
                bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Initial black loader - visible immediately, removed when page is ready -->
    <div id="initial-loader"></div>

    <!-- ═══════════════════════════════════════════════════════════════
         MOBILE UI COMPONENTS
         ═══════════════════════════════════════════════════════════════ -->

    <!-- Pull-to-refresh indicator (welcome screen only) -->
    <div id="pull-to-refresh">
        <span class="ptr-spinner"></span>
        <span class="ptr-text">Relâchez pour actualiser</span>
    </div>

    <!-- Mobile Pause Button -->
    <button id="mobile-pause-btn" class="hidden" aria-label="Pause">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
        </svg>
    </button>

    <!-- Mobile Joystick -->
    <div id="mobile-joystick" class="hidden">
        <div class="joystick-base"></div>
        <div class="joystick-thumb"></div>
    </div>

    <!-- Bouton Toggle Gyroscope (bas gauche) -->
    <button id="gyro-toggle-btn" class="hidden" aria-label="Toggle Gyroscope">
        <svg class="gyro-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
            <line x1="12" y1="2" x2="12" y2="6"></line>
            <line x1="12" y1="18" x2="12" y2="22"></line>
            <line x1="2" y1="12" x2="6" y2="12"></line>
            <line x1="18" y1="12" x2="22" y2="12"></line>
        </svg>
        <svg class="touch-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
            <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v5"></path>
            <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v6"></path>
            <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"></path>
            <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"></path>
        </svg>
    </button>

    <!-- Mobile Instructions -->
    <div id="mobile-instructions" class="hidden">
        <div class="instruction-line">
            <svg class="instruction-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="3"></circle>
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
            </svg>
            <span>Inclinez pour regarder</span>
        </div>
        <div class="instruction-line secondary">
            <svg class="instruction-svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="4"></circle>
            </svg>
            <span>Joystick pour se deplacer</span>
        </div>
    </div>

    <!-- Gyroscope Permission Request (iOS) -->
    <div id="gyro-permission-btn">
        <h3>Activer le mouvement</h3>
        <p>Pour une expérience immersive, autorisez l'accès aux capteurs de mouvement.</p>
        <button onclick="requestGyroPermission()">Activer</button>
    </div>

    <!-- Game Instructions (top-left, visible when on floor Y=11) -->
    <div class="game-instructions hidden" id="game-instructions">
        <div class="instruction-row">
            <span class="key">Souris</span>
            <span>Regarder autour</span>
        </div>
        <div class="instruction-row">
            <div class="keys-group">
                <span class="key">ZQSD</span>
                <span class="or-text">ou</span>
                <div class="arrows-grid">
                    <span class="key">↑</span>
                    <span class="key">←</span>
                    <span class="key">↓</span>
                    <span class="key">→</span>
                </div>
            </div>
            <span>Se déplacer</span>
        </div>
        <div class="instruction-row">
            <span class="key">Molette</span>
            <span>Avancer / Reculer</span>
        </div>
        <div class="instruction-row">
            <span class="key">ESC</span>
            <span>Pause</span>
        </div>
    </div>

    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <video id="welcome-video-bg" autoplay loop muted playsinline>
            <source src="videos/background.mp4" type="video/mp4">
            <source src="videos/background.webm" type="video/webm">
        </video>

        <div class="welcome-logo-container" id="welcome-logo-container">
            <img src="img/presences_rares_logo.png" alt="Logo" class="welcome-logo" id="welcome-logo">
            <video class="welcome-logo-video" id="welcome-logo-video" loop muted playsinline preload="auto">
                <source src="videos/dumbo_icone_chargement.webm" type="video/webm">
            </video>
        </div>

        <div class="welcome-content" id="welcome-content">
            <span class="welcome-project-name">DUMBO</span>
            <h1 class="welcome-title">
                Présences aquatiques rares<br>
                <span class="welcome-subtitle-inline">Maquette de dispositif d'exposition</span>
            </h1>

            <p class="welcome-manifesto">
                Traduire des images scientifiques en formes exposables, sans les simplifier ni les fictionnaliser.
            </p>

            <p class="welcome-text">
                Ce projet explore comment des images réelles issues de captations sous-marines rares, souvent fragmentaires, instables ou difficilement lisibles, peuvent être traduites visuellement afin de rendre perceptible une présence vivante autrement inaccessible au public.
            </p>

            <p class="welcome-text">
                À partir de ces images, un protocole de transformation volumétrique est appliqué. Celui-ci ne vise ni la reconstitution fidèle du milieu aquatique, ni la production d'images spectaculaires, mais la conception de formes traduites, plus stables, plus proches et regardables dans le temps de l'exposition, tout en conservant leur ancrage documentaire.
            </p>

            <p class="welcome-text">
                L'espace que vous traversez n'est pas une exposition finale, mais une maquette spatiale et perceptive. Elle permet de tester l'échelle, la proximité, la temporalité et la relation du regard à ces formes, dans la perspective d'un futur dispositif d'exposition physique.
            </p>

            <p class="welcome-text">
                Cette maquette s'inscrit dans une réflexion sur la médiation scientifique : comment exposer des formes de vie rarement observables sans les simplifier, sans les fictionnaliser, et sans prétendre les rendre totalement accessibles.
            </p>

            <div class="welcome-context">
                Projet de recherche par le design — maquette non définitive<br>
                Images issues de sources scientifiques réelles<br>
                Traductions visuelles réalisées dans un cadre expérimental
            </div>

            <!-- Bouton Play mobile: dans le flux -->
            <div class="play-button-container mobile-play" id="play-button-mobile" onclick="handlePlayClick()">
                <img src="img/icone_play_rond.png" alt="Play" class="play-rond">
                <img src="img/icone_play_fleche.png" alt="Play" class="play-fleche">
            </div>
        </div>

        <!-- Bouton Play desktop: position absolute -->
        <div class="play-button-container desktop-play" id="play-button" onclick="handlePlayClick()">
            <img src="img/icone_play_rond.png" alt="Play" class="play-rond">
            <img src="img/icone_play_fleche.png" alt="Play" class="play-fleche">
        </div>
    </div>

    <!-- Pause Screen (ESC) -->
    <div id="pause-screen">
        <div class="pause-instructions">
            <div class="instruction-row">
                <span class="key">Souris</span>
                <span>Regarder autour</span>
            </div>
            <div class="instruction-row">
                <div class="keys-group">
                    <span class="key">ZQSD</span>
                    <span class="or-text">ou</span>
                    <div class="arrows-grid">
                        <span class="key">↑</span>
                        <span class="key">←</span>
                        <span class="key">↓</span>
                        <span class="key">→</span>
                    </div>
                </div>
                <span>Se déplacer</span>
            </div>
            <div class="instruction-row">
                <span class="key">Molette</span>
                <span>Avancer / Reculer</span>
            </div>
            <div class="instruction-row">
                <span class="key">ESC</span>
                <span>Pause</span>
            </div>
        </div>

        <div class="pause-content" onclick="event.stopPropagation()">
            <h2 class="pause-title">À propos de cette maquette</h2>

            <p class="pause-text">
                Cet espace numérique a été conçu comme un outil de simulation perceptive, permettant de tester comment des formes issues d'images scientifiques réelles peuvent être perçues lorsqu'elles sont traduites volumétriquement et mises en situation d'exposition.
            </p>

            <p class="pause-text">
                Les formes présentées ne sont ni des reconstitutions fidèles, ni des créations fictionnelles. Elles résultent d'un processus de traduction visuelle, appliqué à des captations existantes, afin de rendre perceptible une présence vivante tout en assumant les limites du réel et de l'image.
            </p>

            <div class="pause-conceptual-list">
                <span class="list-intro">Le choix d'une maquette web répond à des contraintes de temps et de moyens. Il permet néanmoins d'explorer des questions essentielles :</span>
                <span class="list-item">— distance et proximité du regard</span>
                <span class="list-item">— échelle et corporalité</span>
                <span class="list-item">— temporalité de l'observation</span>
                <span class="list-item">— relation entre image documentaire et forme exposée</span>
            </div>

            <p class="pause-text">
                Cette interface ne remplace pas une exposition physique. Elle en constitue une prévisualisation critique, destinée à nourrir la réflexion sur de futurs dispositifs de médiation.
            </p>

            <div class="pause-meta">
                Navigation libre — déplacement lent recommandé<br>
                Les contenus projetés peuvent évoluer au cours du projet
            </div>
        </div>

        <div class="pause-controls" onclick="event.stopPropagation()">
            <div class="volume-control" id="volume-control">
                <div class="volume-slider-container">
                    <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="30" oninput="updateVolume(this.value)">
                </div>
                <button class="mute-button" id="mute-button" onclick="toggleMute()" ontouchstart="showVolumeSlider()" onmouseenter="showVolumeSlider()">
                <svg id="mute-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    <line id="mute-slash" x1="2" y1="2" x2="22" y2="22" style="display:none;"></line>
                </svg>
            </button>
            </div>
        </div>

        <div class="pause-credits">Musique : Teimo (schluss) par Thomas Köner</div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <video class="loading-video" autoplay loop muted playsinline preload="auto">
            <source src="videos/dumbo_icone_chargement.webm" type="video/webm">
        </video>
    </div>

    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 — Video projection volumétrique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn" data-shape="circle" title="Circle">○</button>
        <button class="shape-btn active" data-shape="square" title="Square">□</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">◇</button>
        <button class="shape-btn" data-shape="star" title="Star">☆</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>

    <!-- Video Paused Indicator -->
    <div id="video-paused-indicator">VIDEO PAUSED</div>

    <!-- FPS Counter -->
    <div id="fps-counter">
        <span class="fps-value">60</span>
        <span class="fps-label">FPS</span>
    </div>

    <div id="canvas"></div>

    <!-- FPS Settings Panel (Bottom Left) -->
    <div id="fps-settings-panel" class="hidden">
        <button class="panel-close-btn" onclick="document.getElementById('fps-settings-panel').classList.add('hidden')" title="Fermer (F pour réafficher)">×</button>
        <h3>FPS & Verre Settings</h3>

        <div class="fps-param">
            <label>Vitesse touches <span class="fps-param-value" id="val-fps-speed">2.25</span></label>
            <input type="range" id="fps-speed" min="0.5" max="10" step="0.1" value="2.25">
        </div>

        <div class="fps-param">
            <label>Vitesse molette <span class="fps-param-value" id="val-fps-scroll">4.5</span></label>
            <input type="range" id="fps-scroll" min="0.5" max="15" step="0.5" value="4.5">
        </div>

        <div class="fps-param">
            <label>Accélération <span class="fps-param-value" id="val-fps-accel">0.10</span></label>
            <input type="range" id="fps-accel" min="0.05" max="1.0" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Décélération <span class="fps-param-value" id="val-fps-decel">0.30</span></label>
            <input type="range" id="fps-decel" min="0.05" max="1.0" step="0.05" value="0.3">
        </div>

        <div class="fps-param">
            <label>Hauteur caméra <span class="fps-param-value" id="val-fps-height">-96</span></label>
            <input type="range" id="fps-height" min="-150" max="-10" step="1" value="-96">
        </div>

        <div class="fps-param">
            <label>Gravité <span class="fps-param-value" id="val-fps-gravity">-1.50</span></label>
            <input type="range" id="fps-gravity" min="-3.0" max="-0.1" step="0.1" value="-1.5">
        </div>

        <div class="fps-param">
            <label>Hauteur yeux <span class="fps-param-value" id="val-fps-eye">30</span></label>
            <input type="range" id="fps-eye" min="5" max="100" step="1" value="30">
        </div>

        <div class="fps-param">
            <label>Sensibilité souris <span class="fps-param-value" id="val-fps-mouse">0.0010</span></label>
            <input type="range" id="fps-mouse" min="0.0005" max="0.01" step="0.0005" value="0.001">
        </div>

        <div class="fps-param">
            <label>Largeur hitbox <span class="fps-param-value" id="val-fps-hitbox-width">1</span></label>
            <input type="range" id="fps-hitbox-width" min="0.1" max="20" step="0.1" value="1">
        </div>

        <div class="fps-param">
            <label>Hauteur hitbox <span class="fps-param-value" id="val-fps-hitbox-height">10</span></label>
            <input type="range" id="fps-hitbox-height" min="1" max="100" step="1" value="10">
        </div>

        <div class="fps-param">
            <label>Opacité verre <span class="fps-param-value" id="val-glass-opacity">0.00</span></label>
            <input type="range" id="glass-opacity" min="0" max="1" step="0.05" value="0.00">
        </div>

        <div class="fps-param">
            <label>Rugosité verre <span class="fps-param-value" id="val-glass-roughness">0.10</span></label>
            <input type="range" id="glass-roughness" min="0" max="1" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Metalness verre <span class="fps-param-value" id="val-glass-metalness">0.20</span></label>
            <input type="range" id="glass-metalness" min="0" max="1" step="0.05" value="0.2">
        </div>

        <button id="fps-export-btn" style="grid-column: 1 / -1;">📋 Export (Ctrl+S)</button>
    </div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 — Image dispersée</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 — Video dispersée</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 — Luminance depth</div>
    </div>

    <!-- Screen Management Panel (Left side) -->
    <div id="screen-manager-panel">
        <button class="panel-close-btn" onclick="document.getElementById('screen-manager-panel').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <h2>Gestion des Écrans</h2>
        <div class="screen-list" id="screen-list"></div>
        <button class="add-screen-btn" onclick="addNewScreen()">+ Ajouter un Écran</button>
        <p class="screen-manager-hint">
            <strong>Raccourcis clavier:</strong><br>
            Touche A: Ajouter un écran<br>
            Suppr/Backspace: Supprimer sélection<br>
            Ctrl+C: Copier écran | Ctrl+V: Coller<br>
            1-7: Sélectionner écran<br>
            G/R/E/S: Translate/Rotate/Scale/Size
        </p>
    </div>

    <div id="ui">
        <button class="panel-close-btn" onclick="document.getElementById('ui').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">▼</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">▼</button>
                        <span class="value" id="val-density" data-param="density">15X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="30" step="1" value="15">
                    <div class="center-mark" style="left: 20.7%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">▼</button>
                        <span class="value" id="val-depth" data-param="depth">0.2X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="0.2" step="0.01" value="0.08">
                    <div class="center-mark" style="left: 50%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SMOOTHING</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="smoothing" data-dir="down">▼</button>
                        <span class="value" id="val-smoothing" data-param="smoothing">0.00</span>
                        <button class="arrow-btn" data-param="smoothing" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="smoothing" min="0.0" max="0.1" step="0.005" value="0.1">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">▼</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">▼</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.1</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.1">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>GLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="glow" data-dir="down">▼</button>
                        <span class="value" id="val-glow" data-param="glow">0.00</span>
                        <button class="arrow-btn" data-param="glow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="glow" min="0.0" max="1.0" step="0.05" value="0.0">
                    <div class="center-mark" style="left: 30%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">▼</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">▼</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">▼</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.8</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">▼</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.70</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.70">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Clic gauche + drag pour tourner • Molette pour avancer/reculer • Flèches: déplacement • P/M: monter/descendre • N: toggle UI</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        // ═══════════════════════════════════════════════════════════════
        // PERFORMANCE: Debug flag - mettre a false en production
        // ═══════════════════════════════════════════════════════════════
        const DEBUG_MODE = false;
        const dbg = DEBUG_MODE ? console.log.bind(console) : () => {};

        dbg('═══════════════════════════════════════════════════════════════');
        dbg('🚀 SCRIPT DÉMARRÉ - Début du chargement');
        dbg('═══════════════════════════════════════════════════════════════');

        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.2;
        let depthSmoothing = 0.1; // Seuil pour atténuer micro-mouvements (0 = aucun, 0.1 = élevé)
        let pointSize = 0.39;
        let particleDensity = 15;
        let brightness = 1.1;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'square'; // Mode carré par défaut
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // Multi-video system: each volumetric screen has its own video
        let screenVideos = {}; // {1: video_element, 2: video_element, 5: video_element, ...}
        let videoTextures = {}; // {1: texture, 2: texture, 5: texture, ...}

        // Mapping between visual screen numbers (allScreens) and screenVideos indices
        // SIMPLIFIED: Écran N → screenVideos[N] → ecranN.mp4
        const SCREEN_TO_VIDEO_MAP = {
            1: 1,  // Écran 1 → ecran1.mp4
            2: 2,  // Écran 2 → ecran2.mp4
            3: 3,  // Écran 3 → ecran3.mp4
            4: 4,  // Écran 4 → ecran4.mp4
            5: 5   // Écran 5 → ecran5.mp4
        };

        // Sampling canvases for each screen (for continuous video updates)
        let screenSamplingCanvases = {};  // {screenNum: {canvas, ctx, data}}

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.8;
        let saturation = 0.70;
        let hideBackground = false;
        let bgThreshold = 40;
        let glowIntensity = 0.0; // Émissivité/glow des particules lumineuses

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Particle density system - Safety cap to prevent performance issues
        const MAX_PARTICLES = 500000; // Cap maximum de particules par écran

        // FPS Counter variables
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let fpsCurrentFPS = 60;
        let fpsUpdateInterval = 500; // Update FPS display every 500ms

        // Cache DOM elements for FPS counter to avoid repeated queries
        // PERFORMANCE: DOM cache pour eviter les requetes dans animate()
        let fpsDOMCache = {
            counter: null,
            value: null,
            gameInstructions: null,
            videoPausedIndicator: null
        };

        // CubeCamera optimization: throttle updates
        let cubeCameraUpdateCounter = 0;
        const CUBE_CAMERA_UPDATE_INTERVAL = 3; // Update every 3 frames

        // PERFORMANCE: Raycast throttle et cache des sols
        let raycastCounter = 0;
        const RAYCAST_INTERVAL = 2; // Raycast every 2 frames
        let cachedFloorScreens = null;
        let lastGroundY = null; // Cache du dernier Y sol detecte

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // CRITICAL PERFORMANCE: Reusable objects for collision detection & camera movement
        const reusablePlayerBox = new THREE.Box3();
        const reusableWallBox = new THREE.Box3();
        const reusableRaycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const reusableForward = new THREE.Vector3();
        const reusableRight = new THREE.Vector3();
        const reusableUp = new THREE.Vector3(0, 1, 0);
        const reusablePrevPosition = new THREE.Vector3();

        // Scroll lissé (smooth scroll) - Effet très minimal
        let scrollVelocity = 0; // Vitesse de scroll actuelle
        const SCROLL_SMOOTHING = 0.56; // Facteur de lissage réduit de 30%
        const SCROLL_DECAY = 0.50; // Décroissance de la vitesse (plus bas = arrêt plus rapide)

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Transform controls for manipulating screens
        let transformControls = null;
        let selectedScreen = null;
        let allScreens = {}; // Store all screens by number
        let clipboardScreen = null; // Store copied screen data for copy/paste
        let screenLabels = {}; // Store screen number labels (sprites) for volumetric screens
        let screenOutlines = {}; // Store neon outlines for admin mode debug
        const VOLUMETRIC_SCREENS = [1, 2, 3, 4, 5, 6]; // Écrans volumétriques (renumérotés sans trous)

        // Free camera (no orbit controls, no pivot)
        let freeCameraEnabled = true;
        let fpsMode = false; // Mode Normal/Admin par défaut - Touche B pour activer mode FPS
        let bPressCount = 0; // Compteur d'appuis consécutifs sur B
        let bPressTimeout = null; // Timeout pour réinitialiser le compteur
        let showHitbox = false; // Affichage de la hitbox activé avec touche H
        let hitboxHelper = null; // Helper pour visualiser la hitbox
        let cameraYaw = 0; // Rotation horizontale (Y axis)
        let cameraPitch = 0; // Rotation verticale (X axis)
        let isMouseLocked = false;

        // FPS visual effects
        let headBobTimer = 0;
        const HEAD_BOB_SPEED = 0.15;
        const HEAD_BOB_AMOUNT = 0.8;
        const DEFAULT_FOV = 75;
        const SPRINT_FOV_INCREASE = 5;
        let currentFOV = DEFAULT_FOV;
        let targetFOV = DEFAULT_FOV;

        // FPS Physics (paramètres configurables via interface)
        let playerVelocityY = 0;
        let isOnGround = false;
        let currentSpeed = 0;
        const MIN_SPEED = 0;

        // FPS Settings Object (accessible globalement)
        var fpsSettings = {
            fpsCameraHeight: -96,       // Hauteur de spawn de la caméra
            fpsGravity: -1.5,           // Gravité
            fpsPlayerHeight: 25,        // Hauteur des yeux du joueur au-dessus du sol
            fpsMaxSpeed: 2.25,          // Vitesse maximale
            fpsAcceleration: 0.1,       // Vitesse d'accélération
            fpsDeceleration: 0.3,       // Vitesse de décélération
            fpsCollisionRadius: 0.5,    // Rayon de collision (réduit par 10)
            fpsHitboxWidth: 1,          // Largeur de la hitbox (réduit par 10)
            fpsHitboxHeight: 10,        // Hauteur de la hitbox (réduit par 10)
            fpsScrollSpeed: 4.5,        // Vitesse de déplacement à la molette
            fpsMouseSensitivity: 0.001, // Sensibilité souris
            // Glassmorphisme écran 10
            glassOpacity: 0.00,         // Opacité du verre
            glassRoughness: 0.1,        // Rugosité de surface
            glassMetalness: 0.2         // Aspect métallique
        };

        // Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Magnetism settings
        const MAGNETISM_THRESHOLD = 0.05; // ~3 degrees in radians
        const MAGNETISM_ANGLES = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2];

        // Scale mode: 'uniform' (proportionnel) or 'free' (par axe)
        let scaleMode = 'free'; // Default to free mode (allows per-axis scaling)

        // FPS Camera controls (only when no screen selected)
        const cameraKeys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            sprint: false
        };
        const CAMERA_SPEED = 3; // Vitesse de déplacement de la caméra (réduite)
        const CAMERA_SPRINT_MULTIPLIER = 2.5; // Multiplicateur pour la vitesse de sprint

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 30, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 0.2, step: 0.01, decimals: 2, suffix: 'X' }, // Plage 0-0.2 pour précision sur petites valeurs
            smoothing: { min: 0.0, max: 0.1, step: 0.005, decimals: 3, suffix: '' }, // Seuil atténuation micro-mouvements
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            glow: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' }, // Émissivité/glow
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);

                    // Flow is real-time, glow needs regeneration
                    if (param === 'flow') {
                        flowIntensity = parseFloat(slider.value);
                    } else if (param === 'glow') {
                        glowIntensity = parseFloat(slider.value);
                        scheduleRegenerate();
                    } else {
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = 'Pause';
            } else {
                video.pause();
                btn.textContent = 'Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Fonction pour vérifier et cacher les instructions (niveau global pour scroll + clavier)
        function checkHideInstructions() {
            if (instructionsHidden) return;

            // Conditions: au moins 2 touches distinctes OU au moins 3 scrolls
            if (uniqueKeysPressed.size >= REQUIRED_UNIQUE_KEYS || scrollCount >= REQUIRED_SCROLLS) {
                const instructionsElement = document.getElementById('game-instructions');
                if (instructionsElement) {
                    instructionsElement.classList.add('hidden');
                    instructionsHidden = true;
                }
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            // SPECTATOR MODE: Only allow movement keys and mode toggle
            if (fpsMode) {
                const allowedKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',  // WASD movement
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',  // Arrow keys
                    'ShiftLeft', 'ShiftRight',  // Sprint
                    'KeyB',  // Toggle to Admin mode
                    'Escape'  // Exit pointer lock
                ];

                if (!allowedKeys.includes(e.code)) {
                    // Block all other keys in Spectator mode
                    return;
                }

                // Track movement keys for instructions hiding
                const movementKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
                ];
                if (movementKeys.includes(e.code) && !instructionsHidden) {
                    uniqueKeysPressed.add(e.code);

                    // Vérifier si les conditions sont remplies (touches + scrolls)
                    checkHideInstructions();
                }
            }

            // Debug: log all Ctrl key combinations
            if (e.ctrlKey) {
                dbg('🎹 Touche Ctrl détectée:', e.code, 'ctrlKey:', e.ctrlKey, 'shiftKey:', e.shiftKey);
            }

            // Ctrl+Z: Undo (PRIORITY - check first!)
            if (e.code === 'KeyZ' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
                dbg('🔄 Ctrl+Z détecté - Exécution undo()');
                undo();
                return; // Stop here
            }

            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.code === 'KeyZ' && e.ctrlKey && e.shiftKey) || (e.code === 'KeyY' && e.ctrlKey)) {
                e.preventDefault();
                e.stopPropagation();
                dbg('🔄 Ctrl+Shift+Z ou Ctrl+Y détecté - Exécution redo()');
                redo();
                return; // Stop here
            }

            // Ctrl+S: Save positions to JSON file
            if (e.code === 'KeyS' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                dbg('💾 Ctrl+S détecté - Sauvegarde positions');
                savePositionsToFile();
                return; // Stop here
            }

            // Ctrl+C: Copy selected screen
            if (e.code === 'KeyC' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                dbg('📋 Ctrl+C détecté - Copie écran');
                copyScreen();
                return; // Stop here
            }

            // Ctrl+V: Paste screen (create duplicate)
            if (e.code === 'KeyV' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                dbg('📄 Ctrl+V détecté - Collage écran');
                pasteScreen();
                return; // Stop here
            }

            // FPS Camera controls (always active, even with screen selected)
            // Arrow keys always work; WASD only when no screen selected
            if (e.code === 'ArrowUp' || (e.code === 'KeyW' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.forward = true;
            }
            if (e.code === 'ArrowDown' || (e.code === 'KeyS' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.backward = true;
            }
            if (e.code === 'ArrowLeft' || (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.left = true;
            }
            if (e.code === 'ArrowRight' || (e.code === 'KeyD' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.right = true;
            }

            // O/L: Camera up/down (only in normal mode, not FPS mode)
            if (e.code === 'KeyO' && !fpsMode) {
                e.preventDefault();
                cameraKeys.up = true;
            }
            if (e.code === 'KeyL' && !fpsMode) {
                e.preventDefault();
                cameraKeys.down = true;
            }

            // Shift: Sprint (when no screen selected, works in both modes)
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !selectedScreen) {
                cameraKeys.sprint = true;
            }

            // Space: play/pause (only if video exists)
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }

            // Number keys 1-9: Select screen/shape (keyboard + numpad)
            if ((e.code >= 'Digit1' && e.code <= 'Digit9') || (e.code >= 'Numpad1' && e.code <= 'Numpad9')) {
                e.preventDefault();
                const screenNum = parseInt(e.code.replace('Digit', '').replace('Numpad', ''));
                selectScreen(screenNum);
            }

            // G: Translate mode
            if (e.code === 'KeyG' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('translate');
                dbg('Mode: TRANSLATE (déplacement XYZ)');
            }

            // R: Rotate mode
            if (e.code === 'KeyR' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('rotate');
                dbg('Mode: ROTATE (rotation XYZ)');
            }

            // E: Scale mode
            if (e.code === 'KeyE' && selectedScreen) {
                e.preventDefault();
                // Cycle between scale modes
                if (transformControls.mode !== 'scale') {
                    // First press: activate scale mode
                    transformControls.setMode('scale');
                    scaleMode = 'free';
                    dbg('Mode: SCALE LIBRE (axe individuel) - Re-appuyez sur E pour mode uniforme');
                } else {
                    // Subsequent presses: toggle between free and uniform
                    scaleMode = scaleMode === 'free' ? 'uniform' : 'free';
                    dbg(`Mode: SCALE ${scaleMode === 'uniform' ? 'UNIFORME (proportionnel)' : 'LIBRE (axe individuel)'}`);
                }
            }

            // S: Size/Resize mode (when screen selected) OR Save positions (when no screen)
            if (e.code === 'KeyS' && !e.ctrlKey) {
                e.preventDefault();
                if (selectedScreen) {
                    // Activate SIZE mode (geometry resize)
                    transformControls.setMode('scale');
                    scaleMode = 'resize'; // Special mode for geometry resizing
                    dbg('=== MODE: REDIMENSIONNEMENT (S) ===');
                    dbg('Modifie les positions des particules directement');
                    dbg('→ Surface change SANS affecter depth spread');
                    dbg('→ Idéal pour harmoniser les écrans volumétriques');
                    dbg('Drag les handles pour redimensionner');
                } else {
                    saveAllPositions();
                }
            }

            // Escape: Toggle pause screen in Spectator mode OR deselect in Admin mode
            if (e.code === 'Escape') {
                e.preventDefault();
                if (fpsMode && isPaused) {
                    // Already paused: close pause screen
                    resumeExperience();
                } else if (fpsMode && !isPaused) {
                    // Spectator mode: show pause screen
                    showPauseScreen();
                } else if (selectedScreen) {
                    // Admin mode: deselect screen
                    deselectScreen();
                }
            }

            // Delete or Backspace: Delete selected screen
            if ((e.code === 'Delete' || e.code === 'Backspace') && selectedScreen) {
                e.preventDefault();
                deleteScreen(selectedScreen);
            }

            // A: Add new screen
            if (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey) {
                e.preventDefault();
                addNewScreen();
            }

            // N: Toggle all interfaces
            if (e.code === 'KeyN') {
                e.preventDefault();
                toggleAllInterfaces();
            }

            // B: Toggle FPS mode (requires 5 consecutive presses)
            if (e.code === 'KeyB') {
                e.preventDefault();

                // Clear existing timeout
                if (bPressTimeout) {
                    clearTimeout(bPressTimeout);
                }

                // Increment counter
                bPressCount++;
                dbg(`🅱️ B appuyé ${bPressCount}/5 fois`);

                // Reset counter after 2 seconds of inactivity
                bPressTimeout = setTimeout(() => {
                    bPressCount = 0;
                    dbg('⏱️ Compteur B réinitialisé (timeout)');
                }, 2000);

                // Only toggle mode after 5 presses
                if (bPressCount < 5) {
                    return; // Not enough presses yet
                }

                // Reset counter and toggle mode
                bPressCount = 0;
                clearTimeout(bPressTimeout);
                fpsMode = !fpsMode;
                if (fpsMode) {
                    // ENTERING SPECTATOR MODE: Hide all interfaces
                    dbg('🎮 MODE SPECTATEUR (FPS) ACTIVÉ');
                    dbg('   - Cliquez sur le canvas pour activer PointerLock');
                    dbg('   - WASD pour se déplacer');
                    dbg('   - Shift pour sprinter');
                    dbg('   - ESC pour sortir du PointerLock');
                    dbg('   - B pour passer en mode ADMIN');
                    dbg('   - Interfaces désactivées en mode Spectateur');

                    // Hide all UI elements in Spectator mode
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('fps-counter')?.classList.add('hidden');

                    // Hide screen labels in Spectator mode
                    hideScreenLabels();

                    // Hide cursor in Spectator/FPS mode
                    document.body.style.cursor = 'none';

                    // Play background music in Spectator mode
                    playAudio();
                } else {
                    // ENTERING ADMIN MODE: Show all interfaces
                    dbg('🖱️ MODE ADMIN ACTIVÉ');

                    // Show screen labels in Admin mode
                    updateScreenLabels();

                    // Pause music in Admin mode
                    pauseAudio();
                    dbg('   - N pour afficher/cacher les interfaces');
                    dbg('   - B pour passer en mode SPECTATEUR');
                    dbg('   - F pour FPS Settings');
                    dbg('   - Toutes les touches actives');

                    // Release pointer lock if active
                    if (document.exitPointerLock) {
                        document.exitPointerLock();
                    }

                    // CRITICAL: Show cursor in Admin mode
                    document.body.style.cursor = 'default';
                    isMouseLocked = false;

                    // CRITICAL: In Admin mode, show ONLY FPS counter + screen numbers by default
                    // Other interfaces appear only when pressing N or their individual keys
                    document.getElementById('fps-counter')?.classList.remove('hidden');

                    // Hide all other interfaces by default
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('controls')?.classList.add('hidden');
                }
            }

            // H: Toggle hitbox visibility
            if (e.code === 'KeyH') {
                e.preventDefault();
                showHitbox = !showHitbox;
                if (showHitbox) {
                    dbg('👁️ HITBOX VISIBLE');
                } else {
                    dbg('🚫 HITBOX MASQUÉE');
                    // Remove hitbox helper if exists and dispose properly to prevent memory leak
                    if (hitboxHelper) {
                        scene.remove(hitboxHelper);
                        if (hitboxHelper.geometry) hitboxHelper.geometry.dispose();
                        if (hitboxHelper.material) hitboxHelper.material.dispose();
                        hitboxHelper = null;
                    }
                }
            }

            // Individual interface toggles (Admin mode only)
            if (!fpsMode) {
                // & (Digit1): Toggle UI (video + controls)
                if (e.key === '&' || e.code === 'Digit1') {
                    e.preventDefault();
                    const ui = document.getElementById('ui');
                    ui?.classList.toggle('hidden');
                    dbg(`🎥 Interface vidéo: ${ui?.classList.contains('hidden') ? 'cachée' : 'visible'}`);
                }

                // é (Digit2): Toggle screen manager
                if (e.key === 'é' || e.code === 'Digit2') {
                    e.preventDefault();
                    const screenManager = document.getElementById('screen-manager-panel');
                    screenManager?.classList.toggle('hidden');
                    dbg(`📺 Gestionnaire écrans: ${screenManager?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // " (Digit3): Toggle shape selector
                if (e.key === '"' || e.code === 'Digit3') {
                    e.preventDefault();
                    const shapeSelector = document.getElementById('shape-selector');
                    shapeSelector?.classList.toggle('hidden');
                    dbg(`🔷 Sélecteur formes: ${shapeSelector?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // ' (Digit4): Toggle FPS settings (replaces F key)
                if (e.key === "'" || e.code === 'Digit4') {
                    e.preventDefault();
                    const fpsSettings = document.getElementById('fps-settings-panel');
                    fpsSettings?.classList.toggle('hidden');
                    dbg(`⚙️ Paramètres FPS: ${fpsSettings?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }

                // ( (Digit5): Toggle FPS counter
                if (e.key === '(' || e.code === 'Digit5') {
                    e.preventDefault();
                    const fpsCounter = document.getElementById('fps-counter');
                    fpsCounter?.classList.toggle('hidden');
                    dbg(`📊 Compteur FPS: ${fpsCounter?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // - (Digit6 or Minus): Toggle controls (protocol settings)
                if (e.key === '-' || e.code === 'Digit6' || e.code === 'Minus') {
                    e.preventDefault();
                    const controls = document.getElementById('controls');
                    controls?.classList.toggle('hidden');
                    dbg(`🎛️ Réglages protocole: ${controls?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }
            }
        });

        // Keyboard controls - keyup for FPS camera
        document.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                cameraKeys.forward = false;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                cameraKeys.backward = false;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                cameraKeys.left = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                cameraKeys.right = false;
            }
            if (e.code === 'KeyO') {
                cameraKeys.up = false;
            }
            if (e.code === 'KeyL') {
                cameraKeys.down = false;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                cameraKeys.sprint = false;
            }

            // Réinitialiser le timer de maintien si touche relâchée
            const movementKeys = [
                'KeyW', 'KeyA', 'KeyS', 'KeyD',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
            ];
            if (movementKeys.includes(e.code)) {
                if (keyHoldTimer) {
                    clearTimeout(keyHoldTimer);
                    keyHoldTimer = null;
                }
                keyHoldStartTime = null;
            }
        });

        // Transform control functions
        function selectScreen(num) {
            if (!allScreens[num]) {
                dbg(`Écran ${num} n'existe pas`);
                return;
            }

            selectedScreen = num;
            transformControls.attach(allScreens[num]);

            // Set snap settings based on Shift key
            document.addEventListener('keydown', onShiftChange);
            document.addEventListener('keyup', onShiftChange);

            dbg(`=== ÉCRAN ${num} SÉLECTIONNÉ ===`);
            dbg('Commandes:');
            dbg('  G = Mode Translation');
            dbg('  R = Mode Rotation');
            dbg('  E = Mode Scale (classique, affecte depth spread)');
            dbg('  S = Mode Redimensionnement (modifie positions, préserve depth)');
            dbg('  Maj enfoncé = rotation 15°, translation 1000');
            dbg('  Échap = Désélectionner');
            dbg('  Ctrl+C = Copier | Ctrl+V = Coller (dupliquer)');
            dbg('  Ctrl+Z = Annuler | Ctrl+Shift+Z = Refaire');
            dbg('  Magnétisme auto : 0/90/180/270°');
        }

        function deselectScreen() {
            if (selectedScreen) {
                dbg(`Écran ${selectedScreen} désélectionné`);
                transformControls.detach();
                selectedScreen = null;

                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }
        }

        // Toggle all interfaces (touche N) - ONLY accessible in Admin mode
        function toggleAllInterfaces() {
            // CRITICAL: Only allow in Admin mode (not FPS/Spectator mode)
            if (fpsMode) {
                dbg('⚠️ Interfaces disponibles uniquement en mode Admin (appuyez sur B)');
                return;
            }

            const ui = document.getElementById('ui');
            const screenManager = document.getElementById('screen-manager-panel');
            const shapeSelector = document.getElementById('shape-selector');
            const fpsSettings = document.getElementById('fps-settings-panel');
            const fpsCounter = document.getElementById('fps-counter');
            const loadSection = document.getElementById('load-section');

            const isVisible = !ui.classList.contains('hidden');

            if (isVisible) {
                // Cacher les interfaces SAUF load-section si aucune vidéo n'est chargée
                if (currentVideo) {
                    ui.classList.add('hidden');
                } else {
                    // Si pas de vidéo, garder load-section visible mais cacher le reste
                    document.getElementById('controls')?.classList.add('hidden');
                }
                screenManager.classList.add('hidden');
                shapeSelector.classList.add('hidden');
                fpsSettings.classList.add('hidden');
                fpsCounter.classList.add('hidden');
                dbg('🙈 Interfaces cachées (N pour afficher)');
            } else {
                ui.classList.remove('hidden');
                screenManager.classList.remove('hidden');
                shapeSelector.classList.remove('hidden');
                fpsSettings.classList.remove('hidden');
                fpsCounter.classList.remove('hidden');
                // CRITICAL: Show controls if video is loaded
                if (currentVideo) {
                    document.getElementById('controls')?.classList.remove('hidden');
                }
                dbg('👁️ Interfaces affichées (N pour cacher)');
            }
        }

        function deleteScreen(num) {
            if (!allScreens[num]) {
                console.warn(`Écran ${num} n'existe pas`);
                return;
            }

            // Save state for undo
            saveState();

            const screen = allScreens[num];

            // Detach transform controls if this screen is selected
            if (selectedScreen === num) {
                transformControls.detach();
                selectedScreen = null;
                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }

            // Remove from scene
            if (screen.parent) {
                screen.parent.remove(screen);
            }

            // Dispose geometry and material to free memory
            if (screen.geometry) screen.geometry.dispose();
            if (screen.material) {
                if (Array.isArray(screen.material)) {
                    screen.material.forEach(mat => mat.dispose());
                } else {
                    screen.material.dispose();
                }
            }

            // Remove from allScreens
            delete allScreens[num];

            dbg(`=== ÉCRAN ${num} SUPPRIMÉ ===`);

            // Update UI
            updateScreenList();
        }

        // Screen numbering system for volumetric screens and shapes
        // color parameter: 'green' for volumetric screens, 'red' for forms/shapes
        function createScreenLabel(screenNumber, color = 'red') {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Choose color based on type
            const labelColor = color === 'green' ? '#00ff4c' : '#ff004c';

            // Draw number
            ctx.fillStyle = labelColor;
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Add glow effect
            ctx.shadowColor = labelColor;
            ctx.shadowBlur = 20;
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(50, 50, 1);

            return sprite;
        }

        // Create neon outline for screen/shape (admin debug mode)
        function createScreenOutline(screen) {
            // Get geometry - handle both regular meshes and instanced meshes
            let geometry = screen.geometry;
            if (!geometry) return null;

            // Create edge geometry for outline
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff004c, // Neon red
                linewidth: 1,
                transparent: true,
                opacity: 0.8
            });
            const outline = new THREE.LineSegments(edges, lineMaterial);

            // Copy transform from original screen
            outline.position.copy(screen.position);
            outline.rotation.copy(screen.rotation);
            outline.scale.copy(screen.scale);

            return outline;
        }

        function updateScreenLabels() {
            // Remove existing labels
            Object.values(screenLabels).forEach(label => {
                if (label.parent) label.parent.remove(label);
            });
            screenLabels = {};

            // Remove existing outlines
            Object.values(screenOutlines).forEach(outline => {
                if (outline && outline.parent) outline.parent.remove(outline);
            });
            screenOutlines = {};

            // Only show in Admin mode
            if (fpsMode) return;

            // Create labels and outlines for ALL screens and shapes
            Object.keys(allScreens).forEach(screenNum => {
                const screen = allScreens[screenNum];
                if (!screen) return;

                const num = parseInt(screenNum);
                const isVolumetric = VOLUMETRIC_SCREENS.includes(num);

                // Create label: green for volumetric screens, red for forms/shapes
                const labelColor = isVolumetric ? 'green' : 'red';
                const label = createScreenLabel(screenNum, labelColor);
                label.position.copy(screen.position);
                scene.add(label);
                screenLabels[screenNum] = label;

                // Create outline ONLY for forms/shapes (not volumetric screens)
                if (!isVolumetric) {
                    const outline = createScreenOutline(screen);
                    if (outline) {
                        scene.add(outline);
                        screenOutlines[screenNum] = outline;
                    }
                }
            });
        }

        function hideScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = false;
            });
            Object.values(screenOutlines).forEach(outline => {
                if (outline) outline.visible = false;
            });
        }

        function showScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = true;
            });
        }

        function addNewScreen() {
            dbg('🆕 addNewScreen() appelé - allScreens actuels:', Object.keys(allScreens));
            console.trace('Stack trace:'); // Pour voir qui appelle cette fonction

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }
            dbg('🆕 Nouveau numéro trouvé:', newNum);

            // Save state for undo
            saveState();

            // Default dimensions (same as standard screen)
            const width = 450;
            const height = 450;

            // Create new screen plane with color surface
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080, // Gray by default
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Position offset from origin
            const offset = (newNum - 1) * 500;
            screen.position.set(offset, 0, 0);

            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = true; // Mark as color surface by default
            screen.userData.color = 0x808080; // Store color

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            dbg(`=== ÉCRAN ${newNum} CRÉÉ ===`);
            dbg(`Position: (${offset}, 0, 0)`);
            dbg(`Dimensions: ${width} x ${height}`);
            dbg(`Type: Surface couleur unie (gris)`);

            // Update UI
            updateScreenList();
        }

        // Copy selected screen to clipboard
        function copyScreen() {
            if (!selectedScreen) {
                dbg('❌ Aucun écran sélectionné pour copier');
                return;
            }

            const screen = allScreens[selectedScreen];
            if (!screen) {
                dbg('❌ Écran non trouvé');
                return;
            }

            // Deep copy all screen properties
            clipboardScreen = {
                position: {
                    x: screen.position.x,
                    y: screen.position.y,
                    z: screen.position.z
                },
                rotation: {
                    x: screen.rotation.x,
                    y: screen.rotation.y,
                    z: screen.rotation.z
                },
                scale: {
                    x: screen.scale.x,
                    y: screen.scale.y,
                    z: screen.scale.z
                },
                isColorSurface: screen.userData.isColorSurface || false,
                color: screen.userData.color || 0x808080,
                geometryType: screen.geometry ? screen.geometry.type : 'PlaneGeometry',
                dimensions: null
            };

            // Copy geometry dimensions if available
            if (screen.geometry && screen.geometry.parameters) {
                const params = screen.geometry.parameters;
                if (params.width !== undefined && params.height !== undefined) {
                    clipboardScreen.dimensions = {
                        width: params.width,
                        height: params.height
                    };
                }
            }

            dbg(`📋 Écran ${selectedScreen} copié dans le presse-papiers`);
            dbg('   Dimensions:', clipboardScreen.dimensions);
            dbg('   Position:', clipboardScreen.position);
        }

        // Paste screen from clipboard (create duplicate)
        function pasteScreen() {
            if (!clipboardScreen) {
                dbg('❌ Presse-papiers vide - copiez d\'abord un écran (Ctrl+C)');
                return;
            }

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }

            // Save state for undo
            saveState();

            // Create geometry based on stored data
            let width = 450;
            let height = 450;
            if (clipboardScreen.dimensions) {
                width = clipboardScreen.dimensions.width;
                height = clipboardScreen.dimensions.height;
            }

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: clipboardScreen.color,
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Copy position, rotation, scale
            screen.position.set(
                clipboardScreen.position.x,
                clipboardScreen.position.y,
                clipboardScreen.position.z
            );
            screen.rotation.set(
                clipboardScreen.rotation.x,
                clipboardScreen.rotation.y,
                clipboardScreen.rotation.z
            );
            screen.scale.set(
                clipboardScreen.scale.x,
                clipboardScreen.scale.y,
                clipboardScreen.scale.z
            );

            // Copy metadata
            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = clipboardScreen.isColorSurface;
            screen.userData.color = clipboardScreen.color;

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            dbg(`✅ Écran ${newNum} créé par collage (duplicata)`);
            dbg(`   Position: (${screen.position.x.toFixed(3)}, ${screen.position.y.toFixed(3)}, ${screen.position.z.toFixed(3)})`);
            dbg(`   Dimensions: ${width} x ${height}`);

            // Update UI and select new screen
            updateScreenList();
            selectScreen(newNum);
        }

        function updateScreenList() {
            const screenList = document.getElementById('screen-list');
            if (!screenList) return;

            screenList.innerHTML = '';

            // Separate screens into two categories
            const videoScreens = [];
            const colorScreens = [];

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const isColorSurface = screen.userData.isColorSurface || false;

                if (isColorSurface) {
                    colorScreens.push(num);
                } else {
                    videoScreens.push(num);
                }
            });

            // Sort each category by number
            videoScreens.sort((a, b) => parseInt(a) - parseInt(b));
            colorScreens.sort((a, b) => parseInt(a) - parseInt(b));

            // Helper function to add section header
            const addSectionHeader = (title) => {
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    padding: 8px 0 4px 0;
                    font-size: 9px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    color: rgba(255,255,255,0.5);
                    margin-top: 8px;
                    border-top: 1px solid rgba(255,255,255,0.1);
                `;
                headerDiv.textContent = title;
                screenList.appendChild(headerDiv);
            };

            // Display video screens first
            if (videoScreens.length > 0) {
                addSectionHeader('Écrans vidéo');
                videoScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = false;
                const color = screen.userData.color || 0x808080;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'screen-item';
                if (selectedScreen == num) {
                    itemDiv.classList.add('selected');
                }

                // Click to select screen
                itemDiv.addEventListener('click', (e) => {
                    // Don't select if clicking delete button
                    if (!e.target.classList.contains('screen-delete')) {
                        selectScreen(num);
                        updateScreenList();
                    }
                });

                // Header with number and delete button
                const headerDiv = document.createElement('div');
                headerDiv.className = 'screen-header';
                headerDiv.innerHTML = `
                    <span class="screen-num">Écran ${num}</span>
                    <button class="screen-delete" onclick="event.stopPropagation(); deleteScreen(${num}); updateScreenList();">×</button>
                `;
                itemDiv.appendChild(headerDiv);

                // Type selector
                const typeSelectorDiv = document.createElement('div');
                typeSelectorDiv.className = 'screen-type-selector';
                typeSelectorDiv.innerHTML = `
                    <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vidéo</button>
                    <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                `;
                itemDiv.appendChild(typeSelectorDiv);

                // Color picker (only if color surface)
                if (isColorSurface) {
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x070707, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    // Reset to current color if invalid
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                }

                    screenList.appendChild(itemDiv);
                });
            }

            // Display color screens
            if (colorScreens.length > 0) {
                addSectionHeader('Formes colorées');
                colorScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = true;
                    const color = screen.userData.color || 0x808080;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'screen-item';
                    if (selectedScreen == num) {
                        itemDiv.classList.add('selected');
                    }

                    // Click to select screen
                    itemDiv.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('screen-delete')) {
                            selectScreen(num);
                            updateScreenList();
                        }
                    });

                    // Header with number and delete button
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'screen-header';
                    headerDiv.innerHTML = `
                        <span class="screen-num">Forme ${num}</span>
                        <button class="screen-delete" onclick="event.stopPropagation(); deleteScreen(${num}); updateScreenList();">×</button>
                    `;
                    itemDiv.appendChild(headerDiv);

                    // Type selector
                    const typeSelectorDiv = document.createElement('div');
                    typeSelectorDiv.className = 'screen-type-selector';
                    typeSelectorDiv.innerHTML = `
                        <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vidéo</button>
                        <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                    `;
                    itemDiv.appendChild(typeSelectorDiv);

                    // Color picker
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x070707, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                    screenList.appendChild(itemDiv);
                });
            }
        }

        function setScreenType(num, isColorSurface) {
            const screen = allScreens[num];
            if (!screen) return;

            saveState();

            screen.userData.isColorSurface = isColorSurface;

            // Detect if this is a volumetric screen (1-7) or a shape (>7)
            const isVolumetric = (num >= 1 && num <= 7);

            if (isColorSurface) {
                // Switch to color surface
                const color = screen.userData.color || 0x808080;

                if (isVolumetric) {
                    // For volumetric screens: create overlay plane to hide particles
                    if (!screen.userData.colorOverlay) {
                        // Get screen dimensions (approximate from bounding box)
                        const box = new THREE.Box3().setFromObject(screen);
                        const size = box.getSize(new THREE.Vector3());
                        const width = Math.max(size.x, size.y, size.z);
                        const height = Math.max(size.x, size.y, size.z);

                        // Create overlay mesh
                        const overlayGeometry = new THREE.PlaneGeometry(width * 1.2, height * 1.2);
                        const overlayMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);

                        // Position overlay at screen position (local space)
                        overlay.position.copy(screen.position);
                        overlay.rotation.copy(screen.rotation);
                        overlay.scale.copy(screen.scale);

                        screensGroup.add(overlay);
                        screen.userData.colorOverlay = overlay;
                    } else {
                        // Update existing overlay color
                        screen.userData.colorOverlay.material.color.setHex(color);
                        screen.userData.colorOverlay.visible = true;
                    }

                    // Hide volumetric particles
                    screen.visible = false;

                } else {
                    // For shapes: just change material color
                    screen.material.color.setHex(color);
                }
            } else {
                // Switch to video
                if (isVolumetric) {
                    // For volumetric screens: hide overlay, show particles
                    if (screen.userData.colorOverlay) {
                        screen.userData.colorOverlay.visible = false;
                    }
                    screen.visible = true;
                } else {
                    // For shapes: can't convert to video (not supported yet)
                    console.warn(`Écran ${num}: Conversion forme → vidéo non supportée`);
                }
            }

            updateScreenList();
            dbg(`Écran ${num}: Type changé en ${isColorSurface ? 'Couleur' : 'Vidéo'}`);
        }

        function setScreenColor(num, colorValue) {
            const screen = allScreens[num];
            if (!screen || !screen.userData.isColorSurface) return;

            saveState();

            screen.userData.color = colorValue;

            // Update color for volumetric overlay or direct material
            const isVolumetric = (num >= 1 && num <= 7);
            if (isVolumetric && screen.userData.colorOverlay) {
                screen.userData.colorOverlay.material.color.setHex(colorValue);
            } else if (screen.material) {
                screen.material.color.setHex(colorValue);
            }

            updateScreenList();
            dbg(`Écran ${num}: Couleur changée → #${colorValue.toString(16).padStart(6, '0')}`);
        }

        function onShiftChange(e) {
            if (!transformControls || !selectedScreen) return;

            const isShiftPressed = e.shiftKey;

            if (transformControls.mode === 'rotate') {
                // Rotation par pas de 15° (en radians)
                transformControls.setRotationSnap(isShiftPressed ? THREE.MathUtils.degToRad(15) : null);
            } else if (transformControls.mode === 'translate') {
                // Translation snapping de 1000 unités
                transformControls.setTranslationSnap(isShiftPressed ? 1000 : null);
            }
        }

        // Apply magnetism to rotation - snap to 0, 90, 180, 270 degrees when close
        function applyMagnetism(screen) {
            if (!screen) return;

            ['x', 'y', 'z'].forEach(axis => {
                const rotation = screen.rotation[axis];
                const normalized = ((rotation % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                for (let angle of MAGNETISM_ANGLES) {
                    if (Math.abs(normalized - angle) < MAGNETISM_THRESHOLD) {
                        screen.rotation[axis] = rotation - normalized + angle;
                        break;
                    }
                }
            });
        }

        // PROFESSIONAL UNDO/REDO SYSTEM - Complet et robuste
        function saveState() {
            const state = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            // Deep copy of ALL screen properties
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                state.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });

            undoHistory.push(state);
            dbg('💾 saveState() - État sauvegardé, écrans:', Object.keys(state.screens), 'historique:', undoHistory.length);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Clear redo history when new action is made
            redoHistory = [];
        }

        function undo() {
            dbg('🔄 undo() appelé - undoHistory.length:', undoHistory.length);

            if (undoHistory.length === 0) {
                dbg('❌ Rien à annuler (historique vide)');
                return;
            }

            // Save current state to redo BEFORE undoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            dbg('💾 État actuel sauvegardé dans redo, écrans:', Object.keys(currentState.screens));
            redoHistory.push(currentState);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }

            // Restore previous state
            const previousState = undoHistory.pop();
            dbg('⏮️ Restauration état précédent, écrans:', Object.keys(previousState.screens));

            // Restore all screens from previous state
            Object.keys(previousState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = previousState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (previousState.selectedScreen && allScreens[previousState.selectedScreen]) {
                selectScreen(previousState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            dbg('✅ Annulé (Ctrl+Z)');
        }

        function redo() {
            if (redoHistory.length === 0) {
                dbg('❌ Rien à refaire');
                return;
            }

            // Save current state to undo BEFORE redoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            undoHistory.push(currentState);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Restore next state
            const nextState = redoHistory.pop();

            // Restore all screens from next state
            Object.keys(nextState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = nextState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (nextState.selectedScreen && allScreens[nextState.selectedScreen]) {
                selectScreen(nextState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            dbg('✅ Refait (Ctrl+Shift+Z)');
        }

        function saveAllPositions() {
            dbg('');
            dbg('='.repeat(60));
            dbg('SAUVEGARDE DES POSITIONS - COPIER-COLLER DANS LE CODE');
            dbg('='.repeat(60));
            dbg('');

            Object.keys(allScreens).sort().forEach(num => {
                const screen = allScreens[num];
                const pos = screen.position;
                const rot = screen.rotation;
                const scale = screen.scale;

                dbg(`// Écran ${num}`);
                dbg(`screen${num}.position.set(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)});`);
                dbg(`screen${num}.rotation.set(${rot.x.toFixed(6)}, ${rot.y.toFixed(6)}, ${rot.z.toFixed(6)});`);
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    dbg(`screen${num}.scale.set(${scale.x.toFixed(3)}, ${scale.y.toFixed(3)}, ${scale.z.toFixed(3)});`);
                }
                dbg('');
            });

            dbg('='.repeat(60));
        }

        // Save positions to JSON file (Ctrl+S)
        function savePositionsToFile() {
            const data = {
                timestamp: new Date().toISOString(),
                screens: {}
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const screenData = {
                    position: {
                        x: parseFloat(screen.position.x.toFixed(3)),
                        y: parseFloat(screen.position.y.toFixed(3)),
                        z: parseFloat(screen.position.z.toFixed(3))
                    },
                    rotation: {
                        x: parseFloat(screen.rotation.x.toFixed(6)),
                        y: parseFloat(screen.rotation.y.toFixed(6)),
                        z: parseFloat(screen.rotation.z.toFixed(6))
                    },
                    scale: {
                        x: parseFloat(screen.scale.x.toFixed(3)),
                        y: parseFloat(screen.scale.y.toFixed(3)),
                        z: parseFloat(screen.scale.z.toFixed(3))
                    },
                    // Type and properties
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };

                // Save geometry dimensions if available
                if (screen.geometry && screen.geometry.parameters) {
                    const params = screen.geometry.parameters;
                    if (params.width !== undefined && params.height !== undefined) {
                        screenData.dimensions = {
                            width: parseFloat(params.width.toFixed(3)),
                            height: parseFloat(params.height.toFixed(3))
                        };
                    }
                    // Save geometry type
                    screenData.geometryType = screen.geometry.type || 'unknown';
                }

                data.screens[num] = screenData;
            });

            // Download as JSON file
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `screen-positions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            dbg('✅ Positions complètes (avec dimensions) sauvegardées dans le fichier JSON téléchargé');
            dbg(`📦 ${Object.keys(allScreens).length} écrans exportés`);
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            dbg('═══════════════════════════════════════════════════════');
            dbg('🔧 INIT() - Début de l\'initialisation');
            dbg('═══════════════════════════════════════════════════════');

            dbg('📦 Vérification THREE.js...');
            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded!');
                alert('THREE.js failed to load.');
                return;
            }
            dbg('✅ THREE.js chargé:', THREE.REVISION);

            dbg('🌍 Création de la scène...');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            dbg('✅ Scène créée');

            dbg('📦 Création du groupe d\'écrans...');
            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);
            dbg('✅ Groupe d\'écrans créé et ajouté à la scène');

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;
            dbg(`📐 Dimensions: ${canvasWidth}x${canvasHeight} (ratio: ${aspectRatio.toFixed(2)})`);

            dbg('📷 Création de la caméra...');
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            // Position de spawn au centre de la forme 11, à quelques unités au-dessus du sol
            // Sol de la forme 11: y = -111.773, on spawn à fpsCameraHeight
            camera.position.set(-274.876, fpsSettings.fpsCameraHeight, 112.79);
            dbg(`📍 Position caméra: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);

            // Orienter la caméra vers l'écran 7 puis tourner d'un quart de tour supplémentaire
            const lookAtTarget = new THREE.Vector3(599.938, fpsSettings.fpsCameraHeight, 112.546);
            camera.lookAt(lookAtTarget);
            dbg(`👀 Caméra regarde vers: (${lookAtTarget.x.toFixed(1)}, ${lookAtTarget.y.toFixed(1)}, ${lookAtTarget.z.toFixed(1)})`);

            // Calculer yaw et pitch initiaux basés sur l'orientation
            const direction = new THREE.Vector3();
            direction.subVectors(lookAtTarget, camera.position).normalize();
            cameraYaw = Math.atan2(direction.x, direction.z) + Math.PI; // +180° (quart de tour supplémentaire)
            cameraPitch = 0; // Vision horizontale
            dbg(`🎯 Orientation: yaw=${cameraYaw.toFixed(2)}, pitch=${cameraPitch.toFixed(2)}`);
            dbg('✅ Caméra configurée');

            dbg('🖼️ Création du renderer...');
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(canvasWidth, canvasHeight);
            // PERFORMANCE: Shadows desactives (tres couteux, pas necessaire pour particules)
            renderer.shadowMap.enabled = false;
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            dbg('✅ Renderer créé et configuré');

            dbg('📎 Ajout du canvas au DOM...');
            const canvasContainer = document.getElementById('canvas');
            if (!canvasContainer) {
                console.error('❌ Element #canvas introuvable dans le DOM!');
                return;
            }
            canvasContainer.appendChild(renderer.domElement);
            dbg('✅ Canvas ajouté au DOM');

            dbg('💡 Ajout des lumières...');
            // Lumière ambiante
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            dbg('✅ Lumière ambiante ajoutée');

            // FREE CAMERA: Pas d'OrbitControls, caméra complètement libre
            // Rotation avec clic droit + drag, mouvement avec flèches

            dbg('🎮 Configuration des TransformControls...');
            // TransformControls for manipulating screens
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('world'); // Use world space to avoid X/Y inversion
            scene.add(transformControls);
            dbg('✅ TransformControls configurés');

            // When transforming, disable free camera
            transformControls.addEventListener('dragging-changed', function(event) {
                freeCameraEnabled = !event.value;

                // Apply magnetism when releasing (end of drag)
                if (!event.value && selectedScreen && allScreens[selectedScreen]) {
                    applyMagnetism(allScreens[selectedScreen]);
                }
            });

            // Save state when starting to drag
            transformControls.addEventListener('mouseDown', function() {
                if (selectedScreen) {
                    saveState();
                }
            });

            // Handle scale modes: uniform, free, and resize
            let lastResizeScale = {x: 1, y: 1, z: 1};
            transformControls.addEventListener('objectChange', function() {
                if (transformControls.mode === 'scale' && selectedScreen && allScreens[selectedScreen]) {
                    const screen = allScreens[selectedScreen];

                    if (scaleMode === 'uniform') {
                        // UNIFORM mode: proportional scaling
                        const avgScale = (screen.scale.x + screen.scale.y + screen.scale.z) / 3;
                        screen.scale.set(avgScale, avgScale, avgScale);
                    } else if (scaleMode === 'resize') {
                        // RESIZE mode: change geometry dimensions, not scale
                        const currentScale = {x: screen.scale.x, y: screen.scale.y, z: screen.scale.z};

                        // Detect which axis changed
                        const deltaX = currentScale.x / lastResizeScale.x;
                        const deltaY = currentScale.y / lastResizeScale.y;
                        const deltaZ = currentScale.z / lastResizeScale.z;

                        if (deltaX !== 1 || deltaY !== 1 || deltaZ !== 1) {
                            // PlaneGeometry (color surfaces)
                            if (screen.geometry && screen.geometry.type === 'PlaneGeometry') {
                                // Get current geometry dimensions
                                const currentWidth = screen.geometry.parameters.width;
                                const currentHeight = screen.geometry.parameters.height;

                                // Calculate new dimensions based on scale change
                                const newWidth = currentWidth * deltaX;
                                const newHeight = currentHeight * deltaY;

                                // Recreate geometry with new dimensions
                                screen.geometry.dispose();
                                screen.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                dbg(`Redimensionné: ${Math.round(newWidth)} x ${Math.round(newHeight)}`);
                            }
                            // Volumetric screens (Points or InstancedMesh)
                            else if (screen.userData.positions || (screen.geometry && screen.geometry.attributes.position)) {
                                // Get positions array
                                let positions;
                                if (screen.userData.positions) {
                                    positions = screen.userData.positions;
                                } else {
                                    positions = screen.geometry.attributes.position.array;
                                }

                                // Multiply all positions by delta (resize without affecting depth spread)
                                for (let i = 0; i < positions.length; i += 3) {
                                    positions[i] *= deltaX;     // X
                                    positions[i + 1] *= deltaY; // Y
                                    positions[i + 2] *= deltaZ; // Z (depth)
                                }

                                // Update geometry based on type
                                if (screen.isPoints) {
                                    // Points: update position attribute
                                    screen.geometry.attributes.position.needsUpdate = true;
                                    screen.geometry.computeBoundingSphere();
                                } else if (screen.isInstancedMesh) {
                                    // InstancedMesh: update instance matrices
                                    const count = screen.count;
                                    for (let i = 0; i < count; i++) {
                                        reusableMatrix.setPosition(
                                            positions[i * 3],
                                            positions[i * 3 + 1],
                                            positions[i * 3 + 2]
                                        );
                                        screen.setMatrixAt(i, reusableMatrix);
                                    }
                                    screen.instanceMatrix.needsUpdate = true;
                                }

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                dbg(`Redimensionné (volumétrique): x${deltaX.toFixed(2)}, y${deltaY.toFixed(2)}, z${deltaZ.toFixed(2)}`);
                            }
                        }
                    }
                    // FREE mode: do nothing, allow non-uniform scaling
                }
            });

            // Free camera mouse controls (LEFT CLICK + drag)
            let isLeftMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.button === 0) { // Left click
                    isLeftMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', function(e) {
                if (e.button === 0) {
                    isLeftMouseDown = false;
                }
            });

            renderer.domElement.addEventListener('mousemove', function(e) {
                // PointerLock mode (FPS-style) - ONLY in Spectator mode
                if (isMouseLocked && freeCameraEnabled && fpsMode) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                }
                // Click+drag mode (Admin mode or fallback)
                else if (isLeftMouseDown && freeCameraEnabled && !selectedScreen) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            // PointerLock API setup for FPS-style controls (only in FPS mode)
            renderer.domElement.addEventListener('click', function() {
                if (!selectedScreen && freeCameraEnabled && fpsMode) {
                    renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                             renderer.domElement.mozRequestPointerLock ||
                                                             renderer.domElement.webkitRequestPointerLock;
                    renderer.domElement.requestPointerLock();
                }
            });

            // PointerLock change event
            document.addEventListener('pointerlockchange', lockChangeCallback, false);
            document.addEventListener('mozpointerlockchange', lockChangeCallback, false);
            document.addEventListener('webkitpointerlockchange', lockChangeCallback, false);

            function lockChangeCallback() {
                if (document.pointerLockElement === renderer.domElement ||
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    isMouseLocked = true;
                    dbg('🔒 PointerLock activé (ESC pour quitter)');
                } else {
                    isMouseLocked = false;
                    dbg('🔓 PointerLock désactivé');

                    // CRITICAL FIX: When pointer lock is released in Spectator mode, show pause screen
                    // This ensures ESC directly shows pause screen instead of requiring two presses
                    if (fpsMode && !isPaused) {
                        dbg('▶️ ESC détecté: Affichage du mode pause');
                        showPauseScreen();
                    }
                }
            }

            // Mouse wheel movement - SCROLL LISSÉ (smooth scroll)
            // Utiliser window pour recevoir les wheel events même sans focus sur le canvas
            window.addEventListener('wheel', function(e) {
                e.preventDefault();

                // Bloquer le scroll si en pause
                if (isPaused) return;

                // Compteur de scroll pour cacher les instructions
                if (fpsMode && !instructionsHidden) {
                    scrollCount++;
                    checkHideInstructions();
                }

                // Accumuler la vitesse de scroll (au lieu d'appliquer directement)
                const scrollSpeed = fpsSettings.fpsScrollSpeed;
                const delta = e.deltaY > 0 ? 1 : -1;
                scrollVelocity += -delta * scrollSpeed * SCROLL_SMOOTHING;
            }, { passive: false });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            // Display controls in console
            dbg('═══════════════════════════════════════════════════════');
            dbg('🏛️  SIMULATION MUSÉE - CONTRÔLES');
            dbg('═══════════════════════════════════════════════════════');
            dbg('');
            dbg('🔄 BASCULER ENTRE MODES:');
            dbg('   B            - Basculer MODE FPS ↔ MODE NORMAL');
            dbg('   N            - Afficher/Cacher interfaces (cachées par défaut)');
            dbg('   F            - Afficher/Cacher FPS Settings (bas gauche)');
            dbg('   Ctrl+S       - Exporter paramètres FPS dans console');
            dbg('');
            dbg('📍 MODE NORMAL (par défaut - ADMIN):');
            dbg('   Flèches/WASD - Déplacement horizontal');
            dbg('   O/L          - Monter/Descendre librement');
            dbg('   Clic gauche  - Rotation caméra');
            dbg('   Molette      - Zoom');
            dbg('');
            dbg('🎮 MODE FPS (touche B - SPECTATEUR):');
            dbg('   WASD/Flèches - Se déplacer');
            dbg('   Shift        - Sprint (x2.5)');
            dbg('   Clic canvas  - PointerLock (ESC pour quitter)');
            dbg('   Gravité      - Marche sur sols (écrans 6, 10, 11)');
            dbg('   Collisions   - Activées avec murs');
            dbg('   H            - Afficher/Masquer hitbox (debug)');
            dbg('');
            dbg('📍 Spawn: Centre forme 11, quelques unités au-dessus');
            dbg('🙈 Interfaces cachées - Appuyez sur N pour afficher');
            dbg('');
            dbg('🖱️ MODE NORMAL ACTIVÉ - Caméra libre');
            dbg('   Appuyez sur B pour activer le mode FPS/Spectateur');
            dbg('═══════════════════════════════════════════════════════');

            dbg('');
            dbg('🚀 Démarrage de la boucle d\'animation...');
            animate();

            // Initialize FPS counter DOM cache
            // PERFORMANCE: Cache tous les elements DOM utilises dans animate()
            fpsDOMCache.counter = document.getElementById('fps-counter');
            fpsDOMCache.value = fpsDOMCache.counter?.querySelector('.fps-value');
            fpsDOMCache.gameInstructions = document.getElementById('game-instructions');
            fpsDOMCache.videoPausedIndicator = document.getElementById('video-paused-indicator');

            dbg('═══════════════════════════════════════════════════════');
            dbg('✅ INIT() TERMINÉ AVEC SUCCÈS');
            dbg('═══════════════════════════════════════════════════════');
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Show preview
                document.getElementById('preview').innerHTML = '<video src="' + url + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                document.getElementById('preview').classList.add('loaded');
                document.getElementById('preview').querySelector('video').play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 13;
                    document.getElementById('depth').value = 0.1;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.1;
                    document.getElementById('glow').value = 0.0;
                    document.getElementById('contrast').value = 1.8;
                    document.getElementById('saturation').value = 0.70;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');
                    updateValueDisplay('glow');
                    updateValueDisplay('contrast');
                    updateValueDisplay('saturation');

                    // Keep both load-section and controls visible
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    // Interfaces visibility managed by mode system (Spectator/Admin)
                }

                // Auto-play
                videoElement.play();

                // Apply automatiquement (générer les particules)
                dbg('🎬 Apply automatique après chargement vidéo...');
                generate(videoElement); // updateScreenList() is called at the end of this function

                // Double-check: réappliquer après un court délai pour être sûr
                setTimeout(() => {
                    dbg('🎬 Apply automatique (2ème passe)...');
                    generate(videoElement);
                }, 100);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        /**
         * Calcule les paramètres de densité adaptatifs (step + résolution dynamique)
         * Density 1-15 : Comportement classique (step variable, résolution fixe 800x450)
         * Density 16-30 : Résolution progressive + step=1 pour plus de détails
         */
        function calculateDensityParams(density) {
            let step, TARGET_WIDTH, TARGET_HEIGHT;

            if (density <= 15) {
                // Mode classique (backward compatible)
                step = Math.max(1, Math.floor(10 / density));
                TARGET_WIDTH = 800;
                TARGET_HEIGHT = 450;
            } else {
                // Mode haute densité : augmentation progressive de la résolution
                step = 1; // Step fixé à 1
                const resolutionMultiplier = 1 + ((density - 15) / 30); // 1.0 à 1.5x
                TARGET_WIDTH = Math.floor(800 * resolutionMultiplier);
                TARGET_HEIGHT = Math.floor(450 * resolutionMultiplier);
            }

            return { step, TARGET_WIDTH, TARGET_HEIGHT };
        }

        // Helper function: Extract particle data from video for multi-video system
        function createParticleDataFromVideo(video) {
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create or reuse sampling canvas
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // Cover behavior: scale video to fill canvas
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9;

            let sourceWidth, sourceHeight, offsetX, offsetY;
            if (videoAspect > targetAspect) {
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw frame and get pixel data
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            const positions = [];
            const colors = [];
            const initialZ = [];
            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            const rgbToLumFactor = 1 / (3 * 255);

            // Contrast/Saturation flags (use global variables)
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with safety cap
            let particleCount = 0;
            outerLoopMulti: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }

                        // Safety cap: prevent performance issues
                        if (particleCount >= MAX_PARTICLES) {
                            console.warn(`⚠️ Multi-video: Cap MAX_PARTICLES atteint (${MAX_PARTICLES.toLocaleString()})`);
                            break outerLoopMulti;
                        }

                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        particleCount++;

                        let rNorm = r * 0.00392156862745098;
                        let gNorm = g * 0.00392156862745098;
                        let bNorm = b * 0.00392156862745098;

                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // Apply depth culling if enabled
            if (enableDepthCull && depthCullPower > 0) {
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }
                const zRange = maxZ - minZ;
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;
                    for (let i = 0; i < initialZ.length; i++) {
                        if (initialZ[i] < cullThreshold) {
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            return { positions, colors, initialZ, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor };
        }

        // === PANORAMIC VIDEO SYSTEM ===
        // Single panoramic video (9600x1080) projected across 5 screens
        // Each screen shows 1920x1080 (standard 16:9 HD)
        let panoramicVideo = null; // Single video for all screens
        const PANORAMIC_SCREENS = [1, 2, 3, 4, 5]; // Screens that show panoramic portions (excluding 6=floor)
        const PANORAMIC_WIDTH = 9600; // Total panoramic video width (5 x 1920)
        const PANORAMIC_HEIGHT = 1080; // Panoramic video height

        // Helper function: Extract particle data from a PORTION of the panoramic video
        // portionIndex: 0-based index (0=leftmost, 4=rightmost for 5 screens)
        // totalPortions: how many portions to divide the video into (5 for our case)
        function createParticleDataFromVideoPortion(video, portionIndex, totalPortions) {
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create sampling canvas
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // Calculate portion bounds in the panoramic video
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const portionWidth = videoWidth / totalPortions;

            // Source coordinates for this portion
            const sourceX = portionIndex * portionWidth;
            const sourceY = 0;
            const sourceWidth = portionWidth;
            const sourceHeight = videoHeight;

            // Draw only this portion of the video, scaled to fill the target canvas
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            const positions = [];
            const colors = [];
            const initialZ = [];
            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            const rgbToLumFactor = 1 / (3 * 255);

            // Contrast/Saturation flags
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with safety cap
            let particleCount = 0;
            outerLoopPanorama: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }

                        // Safety cap: prevent performance issues
                        if (particleCount >= MAX_PARTICLES) {
                            console.warn(`⚠️ Panorama portion ${portionIndex}: Cap MAX_PARTICLES atteint (${MAX_PARTICLES.toLocaleString()})`);
                            break outerLoopPanorama;
                        }

                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        particleCount++;

                        let rNorm = r * 0.00392156862745098;
                        let gNorm = g * 0.00392156862745098;
                        let bNorm = b * 0.00392156862745098;

                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // Apply depth culling if enabled
            if (enableDepthCull && depthCullPower > 0) {
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }
                const zRange = maxZ - minZ;
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;
                    for (let i = 0; i < initialZ.length; i++) {
                        if (initialZ[i] < cullThreshold) {
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            dbg(`🎬 Panorama portion ${portionIndex + 1}/${totalPortions}: ${particleCount.toLocaleString()} particules`);
            return { positions, colors, initialZ, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor };
        }

        function generate(video) {
            dbg('═══════════════════════════════════════════════════════');
            dbg('🎬 GENERATE() APPELÉ');
            dbg('═══════════════════════════════════════════════════════');
            dbg('📦 allScreens avant:', Object.keys(allScreens || {}));
            dbg('🎥 Vidéo:', video ? `${video.videoWidth}x${video.videoHeight}` : 'null');

            // PANORAMIC MODE: Check if panoramic video is available
            const isPanoramicMode = panoramicVideo !== null;
            if (isPanoramicMode) {
                dbg('🌅 MODE PANORAMIQUE ACTIVÉ');
                dbg(`   Vidéo: ${panoramicVideo.videoWidth}x${panoramicVideo.videoHeight}`);
                dbg(`   5 écrans × 1920px chacun = 9600px total`);
                video = panoramicVideo; // Use panoramic video as base
            } else if (screenVideos[1]) {
                dbg('🎬 Multi-video mode: Utilisation de video_01.mp4 pour génération');
                video = screenVideos[1];
            }

            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded in generate()!');
                alert('THREE.js not loaded.');
                return;
            }
            dbg('✅ THREE.js disponible');

            dbg('⚙️ Lecture des paramètres des sliders...');
            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value); // Plage ajustée 0-0.2 pour plus de précision
            depthSmoothing = parseFloat(document.getElementById('smoothing').value); // Seuil atténuation micro-mouvements
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            glowIntensity = parseFloat(document.getElementById('glow').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Adaptive density system: resolution increases with density > 15
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            } else {
                // Update canvas size if density changed (for density > 15)
                if (videoSamplingCanvas.width !== TARGET_WIDTH || videoSamplingCanvas.height !== TARGET_HEIGHT) {
                    videoSamplingCanvas.width = TARGET_WIDTH;
                    videoSamplingCanvas.height = TARGET_HEIGHT;
                }
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            let positions = [];
            let colors = [];
            let initialZ = [];
            let scaleFactor = 0.5;

            // === PANORAMIC MODE: Use portion-based generation for screen 1 ===
            if (isPanoramicMode) {
                dbg('🌅 Génération écran 1 depuis portion 0 (gauche) du panorama');
                const screen1Data = createParticleDataFromVideoPortion(panoramicVideo, 0, 5);
                positions = screen1Data.positions;
                colors = screen1Data.colors;
                initialZ = screen1Data.initialZ;
                scaleFactor = screen1Data.scaleFactor;
                dbg(`   ✅ ${(positions.length / 3).toLocaleString()} particules générées`);
            } else {
            // === STANDARD MODE: Inline generation ===

            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            dbg('🔍 Analyse de création des particules:');
            dbg(`   🎚️ DENSITÉ demandée: ${particleDensity}X`);
            dbg(`   📏 step: ${step}, TARGET: ${TARGET_WIDTH}x${TARGET_HEIGHT}`);
            dbg(`   🔢 Pixels à scanner: ~${Math.floor((TARGET_WIDTH / step) * (TARGET_HEIGHT / step))}`);
            dbg(`   🛡️ Cap MAX_PARTICLES: ${MAX_PARTICLES.toLocaleString()}`);
            dbg(`   🎨 hideBlack: ${hideBlack}, blackThreshold: ${blackThreshold}`);
            dbg(`   🖼️ hideBackground: ${hideBackground}, bgThreshold: ${bgThreshold || 'N/A'}`);
            dbg(`   💡 minLuminance trouvée: ${minLuminance.toFixed(3)}`);

            let totalPixelsScanned = 0;
            let pixelsWithAlpha = 0;
            let pixelsFilteredByBlack = 0;
            let pixelsFilteredByBackground = 0;
            let pixelsAdded = 0;
            let capReached = false;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            outerLoop: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    totalPixelsScanned++;
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        pixelsWithAlpha++;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            pixelsFilteredByBlack++;
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                pixelsFilteredByBackground++;
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Safety cap: prevent performance issues
                        if (pixelsAdded >= MAX_PARTICLES) {
                            capReached = true;
                            break outerLoop;
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 — Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        pixelsAdded++;

                        // v1.3.1 — Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            dbg('📊 Résultats de la génération:');
            dbg(`   📏 Pixels scannés: ${totalPixelsScanned}`);
            dbg(`   ✅ Pixels avec alpha > 30: ${pixelsWithAlpha}`);
            dbg(`   ⚫ Filtrés par hideBlack: ${pixelsFilteredByBlack}`);
            dbg(`   🖼️ Filtrés par hideBackground: ${pixelsFilteredByBackground}`);
            dbg(`   ✨ Particules AJOUTÉES: ${pixelsAdded.toLocaleString()}`);
            dbg(`   📦 positions.length: ${positions.length} (${(positions.length / 3).toLocaleString()} particules)`);
            if (capReached) {
                console.warn(`   ⚠️ CAP ATTEINT! Limite MAX_PARTICLES (${MAX_PARTICLES.toLocaleString()}) appliquée pour éviter lag.`);
            }
            } // END: Standard mode (else block)

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < initialZ.length; i++) {
                        const z = initialZ[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // CRITICAL: Preserve custom shapes (>23) before clearing
            const customShapesToPreserve = {};
            if (allScreens) {
                Object.keys(allScreens).forEach(key => {
                    const num = parseInt(key);
                    if (num > 23) {
                        customShapesToPreserve[num] = allScreens[num];
                        // Remove from screensGroup temporarily to avoid disposal
                        if (allScreens[num].parent === screensGroup) {
                            screensGroup.remove(allScreens[num]);
                        }
                    }
                });
            }
            dbg('💾 Formes personnalisées préservées (>23):', Object.keys(customShapesToPreserve));

            // CRITICAL: Detach transform controls before clearing to avoid "object must be part of scene graph" error
            const wasScreenSelected = selectedScreen;
            if (transformControls && selectedScreen) {
                transformControls.detach();
            }

            dbg('🧹 Nettoyage du groupe d\'écrans...');
            // Clear group before adding new screens (only default screens 1-7 now)
            screensGroup.clear();
            dbg('✅ Groupe nettoyé');

            dbg(`🎨 Mode de rendu: ${is3DMode ? '3D (InstancedMesh)' : '2D (Points)'}`);
            dbg(`📊 Nombre de particules: ${positions.length / 3}`);

            if (is3DMode) {
                dbg('🔷 Création des particules en mode 3D...');
                // 3D Mode: Use InstancedMesh with real 3D geometries
                const count = positions.length / 3;
                dbg(`   Count: ${count}`);
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    flatShading: true,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0xffffff, // Couleur émissive = blanc pour prendre la couleur des particules
                    emissiveIntensity: glowIntensity // Intensité contrôlée par le slider
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                dbg('✅ InstancedMesh créé:', particles);

                const instanceColors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    instanceColors[i * 3] = colors[i * 3];
                    instanceColors[i * 3 + 1] = colors[i * 3 + 1];
                    instanceColors[i * 3 + 2] = colors[i * 3 + 2];
                }
                particles.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);

                // Optimization: reuse matrix and color objects
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    particles.setColorAt(i, reusableColor);
                }

                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Use Points with VIDEO texture
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));

                // Create video texture
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const shapeTexture = getShapeTexture(currentShape);

                dbg('🔸 Création des particules en mode 2D...');
                material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    map: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
                dbg('✅ Points créés:', particles);
            }

            // Volumétrie unilatérale : les particules sombres restent à z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des écrans : z=0 invariant au DEPTH SPREAD

            // Écran 1 - Position de base
            particles.position.set(0, 0, 0);
            particles.rotation.set(0, 0, 0);

            // Add first screen to group
            dbg('➕ Ajout des particules au screensGroup...');
            screensGroup.add(particles);
            dbg('✅ Particules ajoutées au groupe');

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // === ÉCRAN 2: Generate from panorama portion 1 or video_02.mp4 ===
            let particlesRight;
            let screen2Data = null;
            if (isPanoramicMode) {
                dbg('🌅 Génération écran 2 depuis portion 1 du panorama');
                screen2Data = createParticleDataFromVideoPortion(panoramicVideo, 1, 5);
            } else if (screenVideos[2] && screenVideos[2] !== video) {
                dbg('🎬 Génération écran 2 depuis video_02.mp4');
                screen2Data = createParticleDataFromVideo(screenVideos[2]);
            }

            if (screen2Data) {

                if (is3DMode) {
                    const count2 = screen2Data.positions.length / 3;
                    let baseGeometry2;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry2 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry2 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry2 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    particlesRight = new THREE.InstancedMesh(baseGeometry2, material, count2);
                    particlesRight.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors2 = new Float32Array(count2 * 3);
                    for (let i = 0; i < count2; i++) {
                        instanceColors2[i * 3] = screen2Data.colors[i * 3];
                        instanceColors2[i * 3 + 1] = screen2Data.colors[i * 3 + 1];
                        instanceColors2[i * 3 + 2] = screen2Data.colors[i * 3 + 2];
                    }
                    particlesRight.instanceColor = new THREE.InstancedBufferAttribute(instanceColors2, 3);

                    for (let i = 0; i < count2; i++) {
                        reusableMatrix.setPosition(
                            screen2Data.positions[i * 3],
                            screen2Data.positions[i * 3 + 1],
                            screen2Data.positions[i * 3 + 2]
                        );
                        particlesRight.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen2Data.colors[i * 3], screen2Data.colors[i * 3 + 1], screen2Data.colors[i * 3 + 2]);
                        particlesRight.setColorAt(i, reusableColor);
                    }

                    particlesRight.instanceMatrix.needsUpdate = true;
                    particlesRight.userData.initialZ = screen2Data.initialZ;
                    particlesRight.userData.positions = screen2Data.positions;
                    particlesRight.userData.is3D = true;
                } else {
                    const geometry2 = new THREE.BufferGeometry();
                    geometry2.setAttribute('position', new THREE.Float32BufferAttribute(screen2Data.positions, 3));
                    geometry2.setAttribute('color', new THREE.Float32BufferAttribute(screen2Data.colors, 3));
                    geometry2.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen2Data.initialZ, 1));

                    particlesRight = new THREE.Points(geometry2, material);
                }
            } else {
                // Fallback: Clone screen 1 if no video available
                dbg('🎬 Écran 2: Clonage de l\'écran 1 (fallback)');
                particlesRight = particles.clone();
                particlesRight.geometry = particles.geometry;
                particlesRight.material = particles.material;
            }

            // Écran 2 - Position de base
            particlesRight.position.set(400, 0, 0);
            particlesRight.rotation.set(0, 0, 0);

            // Add second screen to group
            screensGroup.add(particlesRight);

            // === ÉCRAN 6: SOL - Utilise floorVideo si disponible ===
            let screen3Positions = [];
            let screen3Colors = [];
            let screen3InitialZ = [];

            if (floorVideo && floorVideo.videoWidth > 0) {
                // Utiliser la vidéo du sol
                dbg('🏠 Génération écran 6 (sol) depuis ecran_sol.webm');
                const floorData = createParticleDataFromVideo(floorVideo);
                if (floorData) {
                    // Multiplier X et Y par 2 pour surface doublée
                    for (let i = 0; i < floorData.positions.length / 3; i++) {
                        screen3Positions.push(floorData.positions[i * 3] * 2, floorData.positions[i * 3 + 1] * 2, floorData.positions[i * 3 + 2]);
                        screen3Colors.push(floorData.colors[i * 3], floorData.colors[i * 3 + 1], floorData.colors[i * 3 + 2]);
                        screen3InitialZ.push(floorData.initialZ[i]);
                    }
                }
            } else {
                // Fallback: Filtrer les particules de l'écran 1
                dbg('🏠 Génération écran 6 (sol) depuis écran 1 (fallback)');
                const halfH = screenH / 2;
                const halfH_screen3 = halfH / 2;

                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];

                    if (y >= -halfH_screen3 && y <= halfH_screen3) {
                        screen3Positions.push(x * 2, y * 2, z);
                        screen3Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                        screen3InitialZ.push(initialZ[i]);
                    }
                }
            }

            let screen3;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du rectangle
                const count3 = screen3Positions.length / 3;
                let baseGeometry3;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry3 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry3 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry3 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen3 = new THREE.InstancedMesh(baseGeometry3, material, count3);
                screen3.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors3 = new Float32Array(count3 * 3);
                for (let i = 0; i < count3; i++) {
                    instanceColors3[i * 3] = screen3Colors[i * 3];
                    instanceColors3[i * 3 + 1] = screen3Colors[i * 3 + 1];
                    instanceColors3[i * 3 + 2] = screen3Colors[i * 3 + 2];
                }
                screen3.instanceColor = new THREE.InstancedBufferAttribute(instanceColors3, 3);

                for (let i = 0; i < count3; i++) {
                    reusableMatrix.setPosition(
                        screen3Positions[i * 3],
                        screen3Positions[i * 3 + 1],
                        screen3Positions[i * 3 + 2]
                    );
                    screen3.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen3Colors[i * 3], screen3Colors[i * 3 + 1], screen3Colors[i * 3 + 2]);
                    screen3.setColorAt(i, reusableColor);
                }

                screen3.instanceMatrix.needsUpdate = true;
                screen3.userData.initialZ = screen3InitialZ;
                screen3.userData.positions = screen3Positions;
                screen3.userData.is3D = true;
                screen3.userData.screenNumber = 6; // Sol - anciennement 5 → 6

            } else {
                // Mode 2D : créer Points avec les particules du rectangle
                const geometry3 = new THREE.BufferGeometry();
                geometry3.setAttribute('position', new THREE.Float32BufferAttribute(screen3Positions, 3));
                geometry3.setAttribute('color', new THREE.Float32BufferAttribute(screen3Colors, 3));
                geometry3.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen3InitialZ, 1));

                screen3 = new THREE.Points(geometry3, material);
                screen3.userData.screenNumber = 6; // Sol - anciennement 5 → 6
            }

            // Position et orientation de base
            screen3.position.set(200.858, -112.500, 112.500);
            screen3.rotation.set(1.570796, 0.000000, 0.000000); // 90° sur X
            screen3.scale.set(1, 1, 1); // Pas de scale (positions déjà multipliées x2)

            screensGroup.add(screen3);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // === ÉCRAN 5 (allScreens[5]): Generate from panorama portion 4 or video_05.mp4 ===
            let wallOppA;
            let screen5Data = null;
            if (isPanoramicMode) {
                dbg('🌅 Génération écran 5 depuis portion 4 (droite) du panorama');
                screen5Data = createParticleDataFromVideoPortion(panoramicVideo, 4, 5);
            } else if (screenVideos[5]) {
                dbg('🎬 Génération écran 5 depuis video_05.mp4');
                screen5Data = createParticleDataFromVideo(screenVideos[5]);
            }

            if (screen5Data) {

                if (is3DMode) {
                    const count5 = screen5Data.positions.length / 3;
                    let baseGeometry5;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry5 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry5 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry5 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppA = new THREE.InstancedMesh(baseGeometry5, material, count5);
                    wallOppA.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors5 = new Float32Array(count5 * 3);
                    for (let i = 0; i < count5; i++) {
                        instanceColors5[i * 3] = screen5Data.colors[i * 3];
                        instanceColors5[i * 3 + 1] = screen5Data.colors[i * 3 + 1];
                        instanceColors5[i * 3 + 2] = screen5Data.colors[i * 3 + 2];
                    }
                    wallOppA.instanceColor = new THREE.InstancedBufferAttribute(instanceColors5, 3);

                    for (let i = 0; i < count5; i++) {
                        reusableMatrix.setPosition(
                            screen5Data.positions[i * 3],
                            screen5Data.positions[i * 3 + 1],
                            screen5Data.positions[i * 3 + 2]
                        );
                        wallOppA.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen5Data.colors[i * 3], screen5Data.colors[i * 3 + 1], screen5Data.colors[i * 3 + 2]);
                        wallOppA.setColorAt(i, reusableColor);
                    }

                    wallOppA.instanceMatrix.needsUpdate = true;
                    wallOppA.userData.initialZ = screen5Data.initialZ;
                    wallOppA.userData.positions = screen5Data.positions;
                    wallOppA.userData.is3D = true;
                    wallOppA.userData.screenNumber = 5; // Mur droit - anciennement 6 → 5
                } else {
                    const geometry5 = new THREE.BufferGeometry();
                    geometry5.setAttribute('position', new THREE.Float32BufferAttribute(screen5Data.positions, 3));
                    geometry5.setAttribute('color', new THREE.Float32BufferAttribute(screen5Data.colors, 3));
                    geometry5.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen5Data.initialZ, 1));

                    wallOppA = new THREE.Points(geometry5, material);
                }
            } else {
                // Fallback: Clone screen 1 if no video available
                dbg('🎬 Écran 5: Clonage de l\'écran 1 (fallback)');
                wallOppA = particles.clone();
                wallOppA.geometry = particles.geometry;
                wallOppA.material = particles.material;
            }

            // Écran 5 - Position de base
            wallOppA.position.set(0, 0, 225);
            wallOppA.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppA.userData.screenNumber) wallOppA.userData.screenNumber = 5; // Mur droit - anciennement 6 → 5

            screensGroup.add(wallOppA);

            // === ÉCRAN 6 (allScreens[4]): Generate from panorama portion 3 or video_06.mp4 ===
            let wallOppB;
            let screen6Data = null;
            if (isPanoramicMode) {
                dbg('🌅 Génération écran 4 depuis portion 3 du panorama');
                screen6Data = createParticleDataFromVideoPortion(panoramicVideo, 3, 5);
            } else if (screenVideos[4]) {
                dbg('🎬 Génération écran 4 depuis ecran4.mp4');
                screen6Data = createParticleDataFromVideo(screenVideos[4]);
            }

            if (screen6Data) {

                if (is3DMode) {
                    const count6 = screen6Data.positions.length / 3;
                    let baseGeometry6;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry6 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry6 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry6 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppB = new THREE.InstancedMesh(baseGeometry6, material, count6);
                    wallOppB.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors6 = new Float32Array(count6 * 3);
                    for (let i = 0; i < count6; i++) {
                        instanceColors6[i * 3] = screen6Data.colors[i * 3];
                        instanceColors6[i * 3 + 1] = screen6Data.colors[i * 3 + 1];
                        instanceColors6[i * 3 + 2] = screen6Data.colors[i * 3 + 2];
                    }
                    wallOppB.instanceColor = new THREE.InstancedBufferAttribute(instanceColors6, 3);

                    for (let i = 0; i < count6; i++) {
                        reusableMatrix.setPosition(
                            screen6Data.positions[i * 3],
                            screen6Data.positions[i * 3 + 1],
                            screen6Data.positions[i * 3 + 2]
                        );
                        wallOppB.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen6Data.colors[i * 3], screen6Data.colors[i * 3 + 1], screen6Data.colors[i * 3 + 2]);
                        wallOppB.setColorAt(i, reusableColor);
                    }

                    wallOppB.instanceMatrix.needsUpdate = true;
                    wallOppB.userData.initialZ = screen6Data.initialZ;
                    wallOppB.userData.positions = screen6Data.positions;
                    wallOppB.userData.is3D = true;
                    wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4
                } else {
                    const geometry6 = new THREE.BufferGeometry();
                    geometry6.setAttribute('position', new THREE.Float32BufferAttribute(screen6Data.positions, 3));
                    geometry6.setAttribute('color', new THREE.Float32BufferAttribute(screen6Data.colors, 3));
                    geometry6.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen6Data.initialZ, 1));

                    wallOppB = new THREE.Points(geometry6, material);
                }
            } else {
                // Fallback: Clone screen 2 if no video available
                dbg('🎬 Écran 4: Clonage de l\'écran 2 (fallback)');
                wallOppB = particlesRight.clone();
                wallOppB.geometry = particles.geometry;
                wallOppB.material = particles.material;
            }

            // Écran 4 (anciennement 6) - Position de base
            wallOppB.position.set(400, 0, 225);
            wallOppB.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppB.userData.screenNumber) wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4

            screensGroup.add(wallOppB);

            // === ÉCRAN 7 (allScreens[3]): Generate from panorama portion 2 or video_07.mp4 ===
            let screen7Positions, screen7Colors, screen7InitialZ;
            let useVideo7 = false;

            if (isPanoramicMode) {
                // Use panorama portion 2 (middle)
                dbg('🌅 Génération écran 3 depuis portion 2 (centre) du panorama');
                const screen7Data = createParticleDataFromVideoPortion(panoramicVideo, 2, 5);
                screen7Positions = screen7Data.positions;
                screen7Colors = screen7Data.colors;
                screen7InitialZ = screen7Data.initialZ;
                useVideo7 = true;
            } else if (screenVideos[3]) {
                // Use ecran3.mp4
                dbg('🎬 Génération écran 3 depuis ecran3.mp4');
                const screen7Data = createParticleDataFromVideo(screenVideos[3]);
                screen7Positions = screen7Data.positions;
                screen7Colors = screen7Data.colors;
                screen7InitialZ = screen7Data.initialZ;
                useVideo7 = true;
            } else {
                // Fallback: Filter from screen 1 video to create square
                dbg('🎬 Écran 3: Filtrage depuis l\'écran 1 (fallback)');
                screen7Positions = [];
                screen7Colors = [];
                screen7InitialZ = [];

                // Réutilise halfH déjà déclaré pour l'écran 3 (screenH / 2 = 112.5)
                // Filtrer les particules pour faire un carré : X et Y entre -halfH et +halfH
                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];

                    // Carré centré : -112.5 <= X <= 112.5 ET -112.5 <= Y <= 112.5
                    if (x >= -halfH && x <= halfH && y >= -halfH && y <= halfH) {
                        screen7Positions.push(x, y, z);
                        screen7Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                        screen7InitialZ.push(initialZ[i]);
                    }
                }
            }

            let screen7;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du carré
                const count7 = screen7Positions.length / 3;
                let baseGeometry7;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry7 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry7 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry7 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen7 = new THREE.InstancedMesh(baseGeometry7, material, count7);
                screen7.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors7 = new Float32Array(count7 * 3);
                for (let i = 0; i < count7; i++) {
                    instanceColors7[i * 3] = screen7Colors[i * 3];
                    instanceColors7[i * 3 + 1] = screen7Colors[i * 3 + 1];
                    instanceColors7[i * 3 + 2] = screen7Colors[i * 3 + 2];
                }
                screen7.instanceColor = new THREE.InstancedBufferAttribute(instanceColors7, 3);

                for (let i = 0; i < count7; i++) {
                    reusableMatrix.setPosition(
                        screen7Positions[i * 3],
                        screen7Positions[i * 3 + 1],
                        screen7Positions[i * 3 + 2]
                    );
                    screen7.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen7Colors[i * 3], screen7Colors[i * 3 + 1], screen7Colors[i * 3 + 2]);
                    screen7.setColorAt(i, reusableColor);
                }

                screen7.instanceMatrix.needsUpdate = true;
                screen7.userData.initialZ = screen7InitialZ;
                screen7.userData.positions = screen7Positions;
                screen7.userData.is3D = true;
                screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            } else {
                // Mode 2D : créer Points avec les particules du carré
                const geometry7 = new THREE.BufferGeometry();
                geometry7.setAttribute('position', new THREE.Float32BufferAttribute(screen7Positions, 3));
                geometry7.setAttribute('color', new THREE.Float32BufferAttribute(screen7Colors, 3));
                geometry7.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen7InitialZ, 1));

                screen7 = new THREE.Points(geometry7, material);
            }

            // Position et orientation de base (coordonnées ajustées par l'utilisateur)
            screen7.position.set(599.938, -0.064, 112.546);
            screen7.rotation.set(0, -1.570796, 0); // -90° en Y
            screen7.scale.set(1, 1, 1); // IMPORTANT: pas de scale, l'image garde sa taille normale
            if (!screen7.userData.screenNumber) screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            screensGroup.add(screen7);

            // ======================
            // ============================================================
            // HELPER: Matériau avec shader subtil pour MURS-FORMES uniquement
            // (gradient + dithering - amélioration qualité visuelle)
            // ============================================================
            function createWallFormMaterial(baseColorHex, gradientStrength = 0.03) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        baseColor: { value: new THREE.Color(baseColorHex) },
                        gradientStrength: { value: gradientStrength }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 baseColor;
                        uniform float gradientStrength;
                        varying vec2 vUv;

                        // Dithering Bayer 4x4 ultra subtil
                        float bayerDither4x4(vec2 screenPos) {
                            int x = int(mod(screenPos.x, 4.0));
                            int y = int(mod(screenPos.y, 4.0));
                            int index = x + y * 4;
                            float bayer[16];
                            bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                            bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                            bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                            bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                            return bayer[index];
                        }

                        void main() {
                            // Gradient vertical subtil (du haut vers le bas)
                            float gradient = vUv.y * gradientStrength;

                            // Dithering ultra fin (opacité 0.006)
                            float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                            // Couleur finale
                            vec3 finalColor = baseColor + vec3(gradient + dither);
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    side: THREE.DoubleSide
                });
            }

            // SCREEN 4: Custom shape (color surface) - FORME 7 (couleur unie)
            // ======================
            const width4 = 964.573;
            const height4 = 228.534;
            const geometry4 = new THREE.PlaneGeometry(width4, height4);

            const material4 = new THREE.MeshBasicMaterial({ color: 0x070707, side: THREE.DoubleSide });
            const screen4 = new THREE.Mesh(geometry4, material4);

            // Position et orientation (from user JSON)
            screen4.position.set(132.131, 109.022, 112.031);
            screen4.rotation.set(1.570796, 0, 0); // 90° on X
            screen4.scale.set(1, 1, 1);

            // Mark as color surface
            screen4.userData.screenNumber = 7; // Renuméroté: 4 → 7
            screen4.userData.isColorSurface = true;
            screen4.userData.color = 0x070707;

            screensGroup.add(screen4);

            // ======================
            // SCREEN 8: Custom shape (color surface) - beige/pink panel
            // ======================
            const width8 = 983.983;
            const height8 = 231.29;
            const geometry8 = new THREE.PlaneGeometry(width8, height8);
            const material8 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen8 = new THREE.Mesh(geometry8, material8);

            // Position et orientation (from user JSON)
            screen8.position.set(137.097, -6.589, -0.072);
            screen8.rotation.set(0, 0, 0);
            screen8.scale.set(1, 1, 1);

            // Mark as color surface
            screen8.userData.screenNumber = 8;
            screen8.userData.isColorSurface = true;
            screen8.userData.color = 0x000000;

            screensGroup.add(screen8);

            // ======================
            // SCREEN 9: Custom shape (color surface) - gray panel back
            // ======================
            const width9 = 983.983;
            const height9 = 231.29;
            const geometry9 = new THREE.PlaneGeometry(width9, height9);
            const material9 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen9 = new THREE.Mesh(geometry9, material9);
            screen9.position.set(137.097, -6.589, 226.306);
            screen9.rotation.set(0, 0, 0);
            screen9.scale.set(1, 1, 1);
            screen9.userData.screenNumber = 9;
            screen9.userData.isColorSurface = true;
            screen9.userData.color = 0x000000;
            screensGroup.add(screen9);

            // ======================
            // SCREEN 10: Custom shape (glassmorphisme) - transparent glass floor panel
            // ======================
            const width10 = 804.246;
            const height10 = 228.534;
            const geometry10 = new THREE.PlaneGeometry(width10, height10);
            const material10 = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: fpsSettings.glassMetalness,
                roughness: fpsSettings.glassRoughness,
                opacity: fpsSettings.glassOpacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 1.0
            });
            const screen10 = new THREE.Mesh(geometry10, material10);
            screen10.position.set(205.307, -111.773, 112.611);
            screen10.rotation.set(1.570796, 0, 0);
            screen10.scale.set(1, 1, 1);
            screen10.userData.screenNumber = 10;
            screen10.userData.isColorSurface = true;
            screen10.userData.isGlass = true; // Marquer comme verre
            screen10.userData.color = 0xaaaaaa;
            screen10.visible = true; // Écran 10 visible
            screen10.renderOrder = 1000; // Rendre après les objets opaques
            screensGroup.add(screen10);

            // ======================
            // SCREEN 11: Custom shape (color surface) - dark green small panel (sol avec ombre fake)
            // ======================
            const width11 = 155.945;
            const height11 = 228.534;
            const geometry11 = new THREE.PlaneGeometry(width11, height11);

            // Shader spécial pour sol avec ombre fake mur-sol (dégradé radial subtil)
            const material11 = new THREE.ShaderMaterial({
                uniforms: {
                    baseColor: { value: new THREE.Color(0x0A0A0A) },
                    gradientStrength: { value: 0.03 },
                    shadowStrength: { value: 0.025 } // 2.5% assombrissement aux bords
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float gradientStrength;
                    uniform float shadowStrength;
                    varying vec2 vUv;

                    float bayerDither4x4(vec2 screenPos) {
                        int x = int(mod(screenPos.x, 4.0));
                        int y = int(mod(screenPos.y, 4.0));
                        int index = x + y * 4;
                        float bayer[16];
                        bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                        bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                        bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                        bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                        return bayer[index];
                    }

                    void main() {
                        // Gradient vertical
                        float gradient = vUv.y * gradientStrength;

                        // Ombre fake mur-sol : dégradé radial depuis les bords
                        vec2 center = vec2(0.5, 0.5);
                        float distFromCenter = distance(vUv, center);
                        float shadow = smoothstep(0.3, 0.7, distFromCenter) * shadowStrength;

                        // Dithering
                        float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                        // Couleur finale (assombrie aux bords)
                        vec3 finalColor = baseColor + vec3(gradient + dither) - vec3(shadow);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const screen11 = new THREE.Mesh(geometry11, material11);
            screen11.position.set(-274.876, -111.773, 112.79);
            screen11.rotation.set(1.570796, 0, 0);
            screen11.scale.set(1, 1, 1);
            screen11.userData.screenNumber = 11;
            screen11.userData.isColorSurface = true;
            screen11.userData.color = 0x0A0A0A;
            screensGroup.add(screen11);

            // ======================
            // SCREEN 12: Custom shape (color surface) - dark green vertical panel
            // ======================
            const width12 = 235.076;
            const height12 = 231.29;
            const geometry12 = new THREE.PlaneGeometry(width12, height12);
            const material12 = createWallFormMaterial(0x060606); // Shader subtil pour mur-forme
            const screen12 = new THREE.Mesh(geometry12, material12);
            screen12.position.set(-348.048, -6.589, 115.234);
            screen12.rotation.set(0, 1.570796, 0);
            screen12.scale.set(1, 1, 1);
            screen12.userData.screenNumber = 12;
            screen12.userData.isColorSurface = true;
            screen12.userData.color = 0x060606;
            screensGroup.add(screen12);

            // ======================
            // SCREEN 14: Custom shape (color surface) - FORME 13 (couleur unie presque noire)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width14 = 96.102;
            const height14 = 231.269; // Ajusté pour bas = -111.773
            const geometry14 = new THREE.PlaneGeometry(width14, height14);
            const material14 = new THREE.MeshBasicMaterial({ color: 0x070707, side: THREE.DoubleSide });
            const screen14 = new THREE.Mesh(geometry14, material14);
            screen14.position.set(-197.183, 3.862, 178.672); // Y ajusté
            screen14.rotation.set(0, 1.570796, 0);
            screen14.scale.set(1, 1, 1);
            screen14.userData.screenNumber = 13; // Renuméroté: 14 → 13
            screen14.userData.isColorSurface = true;
            screen14.userData.color = 0x070707;
            screensGroup.add(screen14);

            // ======================
            // SCREEN 15: Custom shape (color surface) - FORME 14 (couleur unie presque noire)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width15 = 96.102;
            const height15 = 231.187; // Ajusté pour bas = -111.773
            const geometry15 = new THREE.PlaneGeometry(width15, height15);
            const material15 = new THREE.MeshBasicMaterial({ color: 0x070707, side: THREE.DoubleSide });
            const screen15 = new THREE.Mesh(geometry15, material15);
            screen15.position.set(-197.107, 3.821, 47.768); // Y ajusté
            screen15.rotation.set(0, 1.570796, 0);
            screen15.scale.set(1, 1, 1);
            screen15.userData.screenNumber = 14; // Renuméroté: 15 → 14
            screen15.userData.isColorSurface = true;
            screen15.userData.color = 0x070707;
            screensGroup.add(screen15);

            // ======================
            // SCREEN 16: Custom shape (color surface) - FORME 15 (couleur unie presque noire)
            // ======================
            const width16 = 163.506;
            const height16 = 239.079;
            const geometry16 = new THREE.PlaneGeometry(width16, height16);
            const material16 = new THREE.MeshBasicMaterial({ color: 0x070707, side: THREE.DoubleSide });
            const screen16 = new THREE.Mesh(geometry16, material16);
            screen16.position.set(-197.04, 27.158, 110.291);
            screen16.rotation.set(1.570796, 1.570796, 0);
            screen16.scale.set(1, 1, 1);
            screen16.userData.screenNumber = 15; // Renuméroté: 16 → 15
            screen16.userData.isColorSurface = true;
            screen16.userData.color = 0x070707;
            screensGroup.add(screen16);

            // ======================
            // SCREEN 17: Custom shape (color surface) - gray thin panel (FORME 16)
            // Config mise à jour selon spécifications
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width17 = 96.102;
            const height17 = 221.302; // Ajusté: ancien haut (109.529) - sol (-111.773)
            const geometry17 = new THREE.PlaneGeometry(width17, height17);
            const material17 = createWallFormMaterial(0x0A0A0A); // Noir foncé
            const screen17 = new THREE.Mesh(geometry17, material17);
            screen17.position.set(-200.734, -1.122, 47.768); // Y ajusté pour bas = -111.773
            screen17.rotation.set(0, 1.570796, 0);
            screen17.scale.set(1, 1, 1);
            screen17.userData.screenNumber = 16; // Renuméroté: 17 → 16
            screen17.userData.isColorSurface = true;
            screen17.userData.color = 0x0A0A0A;
            screensGroup.add(screen17);

            // ======================
            // SCREEN 18: Custom shape (color surface) - gray thin panel (FORME 17)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width18 = 96.102;
            const height18 = 226.947; // Ajusté: ancien haut (115.174) - sol (-111.773)
            const geometry18 = new THREE.PlaneGeometry(width18, height18);
            const material18 = createWallFormMaterial(0x0A0A0A); // Noir foncé
            const screen18 = new THREE.Mesh(geometry18, material18);
            screen18.position.set(-200.734, 1.7, 178.493); // Y ajusté pour bas = -111.773
            screen18.rotation.set(0, 1.570796, 0);
            screen18.scale.set(1, 1, 1);
            screen18.userData.screenNumber = 17; // Renuméroté: 18 → 17
            screen18.userData.isColorSurface = true;
            screen18.userData.color = 0x0A0A0A;
            screensGroup.add(screen18);

            // ======================
            // SCREEN 21: Custom shape (color surface) - gray horizontal panel (FORME 18)
            // ======================
            const width21 = 163.506;
            const height21 = 239.079;
            const geometry21 = new THREE.PlaneGeometry(width21, height21);
            const material21 = createWallFormMaterial(0x0A0A0A); // Noir foncé
            const screen21 = new THREE.Mesh(geometry21, material21);
            screen21.position.set(-200.871, 27.391, 110.392);
            screen21.rotation.set(1.570796, 1.570796, 0);
            screen21.scale.set(1, 1, 1);
            screen21.userData.screenNumber = 18; // Renuméroté: 21 → 18 (après suppression forme 18)
            screen21.userData.isColorSurface = true;
            screen21.userData.color = 0x0A0A0A;
            screensGroup.add(screen21);

            // ======================
            // FORME 19: Gray floor panel (sol gris)
            // ======================
            const width19 = 163.506;
            const height19 = 239.079;
            const geometry19 = new THREE.PlaneGeometry(width19, height19);
            const material19 = createWallFormMaterial(0x060606); // Même couleur que forme 22
            const screen19 = new THREE.Mesh(geometry19, material19);
            screen19.position.set(-279.053, -54.612, 110.34);
            screen19.rotation.set(1.570796, 0, 0);
            screen19.scale.set(1, 1, 1);
            screen19.userData.screenNumber = 19;
            screen19.userData.isColorSurface = true;
            screen19.userData.color = 0x060606;
            screensGroup.add(screen19);

            // ======================
            // FORME 20: Gray thin vertical panel 1
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width20 = 3.246;
            const height20 = 131.518; // Ajusté: ancien haut (19.745) - sol (-111.773)
            const geometry20 = new THREE.PlaneGeometry(width20, height20);
            const material20 = createWallFormMaterial(0x0A0A0A); // Noir foncé
            const screen20 = new THREE.Mesh(geometry20, material20);
            screen20.position.set(-199.153, -46.014, 95.645); // Y ajusté pour bas = -111.773
            screen20.rotation.set(-3.141593, 0, -3.141593);
            screen20.scale.set(1, 1, 1);
            screen20.userData.screenNumber = 20;
            screen20.userData.isColorSurface = true;
            screen20.userData.color = 0x0A0A0A;
            screensGroup.add(screen20);

            // ======================
            // FORME 21: Gray thin vertical panel 2
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width21b = 3.576;
            const height21b = 131.518; // Ajusté: ancien haut (19.745) - sol (-111.773)
            const geometry21b = new THREE.PlaneGeometry(width21b, height21b);
            const material21b = createWallFormMaterial(0x0A0A0A); // Noir foncé
            const screen21b = new THREE.Mesh(geometry21b, material21b);
            screen21b.position.set(-198.975, -46.014, 130.621); // Y ajusté pour bas = -111.773
            screen21b.rotation.set(-3.141593, 0, -3.141593);
            screen21b.scale.set(1, 1, 1);
            screen21b.userData.screenNumber = 21;
            screen21b.userData.isColorSurface = true;
            screen21b.userData.color = 0x0A0A0A;
            screensGroup.add(screen21b);

            // ======================
            // FORME 22: Dark panel back
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width22 = 235.076;
            const height22 = 60.24; // Ajusté pour bas = -111.773
            const geometry22 = new THREE.PlaneGeometry(width22, height22);
            const material22 = createWallFormMaterial(0x060606); // Noir foncé
            const screen22 = new THREE.Mesh(geometry22, material22);
            screen22.position.set(-315.617, -81.653, 180.248); // Y ajusté
            screen22.rotation.set(-3.141593, 0, -3.141593);
            screen22.scale.set(1, 1, 1);
            screen22.userData.screenNumber = 22;
            screen22.userData.isColorSurface = true;
            screen22.userData.color = 0x060606;
            screensGroup.add(screen22);

            // ======================
            // FORME 23: Dark panel front
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width23 = 235.076;
            const height23 = 60.24; // Ajusté pour bas = -111.773
            const geometry23 = new THREE.PlaneGeometry(width23, height23);
            const material23 = createWallFormMaterial(0x060606); // Noir foncé
            const screen23 = new THREE.Mesh(geometry23, material23);
            screen23.position.set(-315.617, -81.653, 48.644); // Y ajusté
            screen23.rotation.set(-3.141593, 0, -3.141593);
            screen23.scale.set(1, 1, 1);
            screen23.userData.screenNumber = 23;
            screen23.userData.isColorSurface = true;
            screen23.userData.color = 0x060606;
            screensGroup.add(screen23);

            // Restore custom shapes (>23) - both in allScreens and screensGroup
            dbg('🔄 Restauration des formes personnalisées (>23):', Object.keys(customShapesToPreserve));
            Object.keys(customShapesToPreserve).forEach(key => {
                const shape = customShapesToPreserve[key];
                screensGroup.add(shape); // Re-add to scene
                allScreens[key] = shape; // CRITICAL: Re-add to allScreens to prevent orphaning
                dbg(`  ✓ Forme #${key} réajoutée à la scène et à allScreens`);
            });

            // Update volumetric screens & shapes - RENUMÉROTÉS (1-23)
            // ÉCRANS volumétriques: 1-6 | FORMES: 7-23
            allScreens = {
                1: particles,           // ÉCRAN: Wall back left (volumetric)
                2: particlesRight,      // ÉCRAN: Wall back right (volumetric)
                3: screen7,             // ÉCRAN: Side panel (volumetric)
                4: wallOppB,            // ÉCRAN: Wall front right (volumetric)
                5: wallOppA,            // ÉCRAN: Wall front left (volumetric)
                6: screen3,             // ÉCRAN: Floor rectangle (volumetric)
                7: screen4,             // FORME: Ceiling gray panel
                8: screen8,             // FORME: Center gray panel
                9: screen9,             // FORME: Back gray panel
                10: screen10,           // FORME: Floor lighter green panel
                11: screen11,           // FORME: Small dark green panel
                12: screen12,           // FORME: Dark green vertical panel
                13: screen14,           // FORME: Dark green thin panel 1
                14: screen15,           // FORME: Dark green thin panel 2
                15: screen16,           // FORME: Dark green horizontal panel
                16: screen17,           // FORME: Gray thin panel 1
                17: screen18,           // FORME: Gray thin panel 2
                18: screen21,           // FORME: Gray horizontal panel
                19: screen19,           // FORME: Gray floor panel
                20: screen20,           // FORME: Gray thin vertical panel 1
                21: screen21b,          // FORME: Gray thin vertical panel 2
                22: screen22,           // FORME: Dark panel back
                23: screen23,           // FORME: Dark panel front
                ...customShapesToPreserve // Restore custom shapes (>23)
            };
            dbg('✅ Tous les écrans (1-23 + custom):', Object.keys(allScreens));

            // CRITICAL: Update screen list UI immediately after allScreens is populated
            updateScreenList();
            dbg('🎨 Interface de gestion des écrans mise à jour');

            // Update screen number labels for volumetric screens (Admin mode only)
            updateScreenLabels();
            dbg('🔢 Numéros des écrans volumétriques mis à jour');

            // CRITICAL: Reattach transform controls to the same screen after regeneration
            if (transformControls && wasScreenSelected && allScreens[wasScreenSelected]) {
                selectedScreen = wasScreenSelected;
                transformControls.attach(allScreens[wasScreenSelected]);
            }

            dbg('');
            dbg('=== CONTRÔLES 3D DISPONIBLES ===');
            dbg('Touches 1-9 : Sélectionner un écran/forme');
            dbg('G : Mode Translation');
            dbg('R : Mode Rotation');
            dbg('E : Mode Scale');
            dbg('Maj enfoncé : rotation 15°, translation 1000');
            dbg('Échap : Désélectionner');
            dbg('Ctrl+Z : Annuler | Ctrl+Shift+Z : Refaire');
            dbg('S : Sauvegarder positions');
            dbg('Magnétisme auto à 0/90/180/270°');
            dbg('================================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }

            dbg('🏁 generate() terminé - allScreens final:', Object.keys(allScreens));
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 13;
            document.getElementById('depth').value = 0.1;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('glow').value = 0.3;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.80;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.80;
            hideBackground = false;
            bgThreshold = 40;
            glowIntensity = 0.3;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('glow');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            // PERFORMANCE: Utilise le cache DOM
            const pausedIndicator = fpsDOMCache.videoPausedIndicator;
            if (currentVideo.paused) {
                if (pausedIndicator && !pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.add('visible');
                }
                return;
            } else {
                if (pausedIndicator && pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.remove('visible');
                }
            }

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            // MODE PANORAMIQUE: Écran 1 = portion 0 (gauche) de la vidéo
            if (panoramicVideo && currentVideo === panoramicVideo) {
                // Extraire la portion gauche (0/5) de la vidéo panoramique
                const portionWidth = videoWidth / 5;
                offsetX = 0; // Portion 0 = tout à gauche
                offsetY = 0;
                sourceWidth = portionWidth;
                sourceHeight = videoHeight;
            } else if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // v1.3.1 — Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Calculate colors with effects
                        {
                            // v1.3.1 — Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply brightness boost
                            let finalR = rNorm * brightness;
                            let finalG = gNorm * brightness;
                            let finalB = bNorm * brightness;

                            // Professional emissive effect: brighter particles glow more (non-linear power curve)
                            if (glowIntensity > 0) {
                                // Calculate luminance of the pixel
                                const pixelLuminance = 0.299 * finalR + 0.587 * finalG + 0.114 * finalB;

                                // Power curve: bright pixels get boosted more (quadratic for smooth glow)
                                const emissiveBoost = Math.pow(pixelLuminance, 2.0) * glowIntensity;

                                // Add emissive glow to bright particles
                                finalR += emissiveBoost * finalR;
                                finalG += emissiveBoost * finalG;
                                finalB += emissiveBoost * finalB;
                            }

                            // Update color with brightness + emissive
                            newColors.push(
                                Math.min(1.0, finalR),
                                Math.min(1.0, finalG),
                                Math.min(1.0, finalB)
                            );
                        }
                    }
                }
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < newDepths.length; i++) {
                        const z = newDepths[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            newColors[i * 3] = 0;
                            newColors[i * 3 + 1] = 0;
                            newColors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation with smoothing
                if (particles.userData.initialZ) {
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = particles.userData.initialZ[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            particles.userData.initialZ[i] = newDepth;
                        }
                        // else: keep old depth (reduces micro-movements/noise)
                    }
                }

                // CRITICAL: Also update screen 7 if it exists (3D mode) - now at position 3
                // SKIP if multi-video system has a dedicated video for this screen
                // SKIP in panoramic mode (updateMultiScreenColors handles it with the correct portion)
                if (allScreens[3] && allScreens[3].instanceColor && !screenVideos[SCREEN_TO_VIDEO_MAP[3]] && !panoramicVideo) {
                    const screen7 = allScreens[3];
                    const colors7 = screen7.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen7.userData.initialZ) {
                                        const oldDepth = screen7.userData.initialZ[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen7.userData.initialZ[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen7.instanceColor.needsUpdate = true;
                }

                // CRITICAL: Also update screen 3 if it exists (3D mode) - now at position 5
                if (allScreens[6] && allScreens[6].instanceColor) {
                    const screen3 = allScreens[6];
                    const colors3 = screen3.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur réduite pour écran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen3.userData.initialZ) {
                                        const oldDepth = screen3.userData.initialZ[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen3.userData.initialZ[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen3.instanceColor.needsUpdate = true;
                }

            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation with smoothing
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = initialZArray[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            initialZArray[i] = newDepth;
                        }
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (2D mode) - now at position 3
                // SKIP if multi-video system has a dedicated video for this screen
                // SKIP in panoramic mode (updateMultiScreenColors handles it with the correct portion)
                if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.color && !screenVideos[SCREEN_TO_VIDEO_MAP[3]] && !panoramicVideo) {
                    const screen7 = allScreens[3];
                    const geom7 = screen7.geometry;
                    const colors7 = geom7.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom7.attributes.initialZ) {
                                        const oldDepth = geom7.attributes.initialZ.array[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom7.attributes.initialZ.array[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom7.attributes.color.needsUpdate = true;
                    if (geom7.attributes.initialZ) {
                        geom7.attributes.initialZ.needsUpdate = true;
                    }
                }

                // CRITICAL: Also update screen 3 if it exists (2D mode) - now at position 5
                if (allScreens[6] && allScreens[6].geometry && allScreens[6].geometry.attributes.color) {
                    const screen3 = allScreens[6];
                    const geom3 = screen3.geometry;
                    const colors3 = geom3.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur réduite pour écran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom3.attributes.initialZ) {
                                        const oldDepth = geom3.attributes.initialZ.array[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom3.attributes.initialZ.array[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom3.attributes.color.needsUpdate = true;
                    if (geom3.attributes.initialZ) {
                        geom3.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Update colors AND depth for screens 2-5 from their respective videos
        let lastMultiScreenUpdate = 0;
        const MULTI_SCREEN_UPDATE_INTERVAL = 50; // ms between updates
        const reusableMatrix2 = new THREE.Matrix4();
        const reusableColor2 = new THREE.Color();

        function updateMultiScreenColors() {
            const now = performance.now();
            if (now - lastMultiScreenUpdate < MULTI_SCREEN_UPDATE_INTERVAL) return;
            lastMultiScreenUpdate = now;

            // Screens to update: 2, 3, 4, 5 (screen 1 is updated by updateColorsFromVideo)
            const screensToUpdate = [2, 3, 4, 5];
            const scaleFactor = 0.5;
            const rgbToLumFactor = 1 / (3 * 255);

            // Mapping from allScreens index to panorama portion index
            // allScreens[2] (particlesRight) → portion 1
            // allScreens[3] (screen7/Side panel) → portion 2
            // allScreens[4] (wallOppB = ÉCRAN 6) → portion 3
            // allScreens[5] (wallOppA = ÉCRAN 5) → portion 4
            const screenToPortion = {
                2: 1,  // allScreens[2] → portion 1/5
                3: 2,  // allScreens[3] = ÉCRAN 7 → portion 2/5
                4: 3,  // allScreens[4] = ÉCRAN 6 → portion 3/5
                5: 4   // allScreens[5] = ÉCRAN 5 → portion 4/5
            };

            for (const screenNum of screensToUpdate) {
                const screen = allScreens[screenNum];

                // Use panoramicVideo in panoramic mode, otherwise use individual screenVideos
                const video = panoramicVideo || screenVideos[screenNum];

                if (!screen || !video || video.paused || video.videoWidth === 0) continue;

                // Create or get sampling canvas for this screen
                if (!screenSamplingCanvases[screenNum]) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 800;
                    canvas.height = 450;
                    screenSamplingCanvases[screenNum] = {
                        canvas: canvas,
                        ctx: canvas.getContext('2d', { willReadFrequently: true })
                    };
                }

                const { canvas, ctx } = screenSamplingCanvases[screenNum];
                const TARGET_WIDTH = canvas.width;
                const TARGET_HEIGHT = canvas.height;
                const halfWidth = TARGET_WIDTH / 2;
                const halfHeight = TARGET_HEIGHT / 2;
                const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

                // Draw video frame to canvas
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;

                let sourceX, sourceY, sourceWidth, sourceHeight;

                if (panoramicVideo) {
                    // PANORAMIC MODE: Extract the correct portion of the panorama
                    const portionIndex = screenToPortion[screenNum];
                    const totalPortions = 5;
                    const portionWidth = videoWidth / totalPortions;

                    sourceX = portionIndex * portionWidth;
                    sourceY = 0;
                    sourceWidth = portionWidth;
                    sourceHeight = videoHeight;
                } else {
                    // MULTI-VIDEO MODE: Use the whole video with aspect ratio handling
                    const videoAspect = videoWidth / videoHeight;
                    const targetAspect = 16 / 9;

                    if (videoAspect > targetAspect) {
                        sourceHeight = videoHeight;
                        sourceWidth = videoHeight * targetAspect;
                        sourceX = (videoWidth - sourceWidth) / 2;
                        sourceY = 0;
                    } else {
                        sourceWidth = videoWidth;
                        sourceHeight = videoWidth / targetAspect;
                        sourceX = 0;
                        sourceY = (videoHeight - sourceHeight) / 2;
                    }
                }

                ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                const data = imageData.data;

                // Calculate step based on particle density
                const step = Math.max(1, Math.floor(10 / particleDensity));
                const useContrast = contrast !== 1.0;
                const useSaturation = saturation !== 1.0;

                // First pass: find min luminance
                let minLuminance = Infinity;
                for (let y = 0; y < TARGET_HEIGHT; y += step) {
                    for (let x = 0; x < TARGET_WIDTH; x += step) {
                        const i = (y * TARGET_WIDTH + x) * 4;
                        if (data[i + 3] > 30) {
                            const luminance = (data[i] + data[i + 1] + data[i + 2]) * rgbToLumFactor;
                            minLuminance = Math.min(minLuminance, luminance);
                        }
                    }
                }
                if (minLuminance === Infinity) minLuminance = 0;

                // Check if 3D mode (InstancedMesh) or 2D mode (Points)
                const is3DMode = screen.userData && screen.userData.is3D;

                if (is3DMode && screen.instanceColor && screen.userData.initialZ) {
                    // 3D MODE: Update instance colors and positions
                    const colorsArray = screen.instanceColor.array;
                    const initialZs = screen.userData.initialZ;
                    const positions = screen.userData.positions;

                    let particleIndex = 0;
                    for (let y = 0; y < TARGET_HEIGHT && particleIndex < initialZs.length; y += step) {
                        for (let x = 0; x < TARGET_WIDTH && particleIndex < initialZs.length; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            if (data[i + 3] > 30) {
                                const r = data[i], g = data[i + 1], b = data[i + 2];
                                const luminance = (r + g + b) * rgbToLumFactor;
                                const newDepth = (luminance - minLuminance) * depthSpread;

                                // Update depth with smoothing
                                const oldDepth = initialZs[particleIndex];
                                const depthDelta = Math.abs(newDepth - oldDepth);
                                if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                    initialZs[particleIndex] = newDepth;
                                }

                                // Update color
                                let rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                                if (useContrast) {
                                    rNorm = Math.max(0, Math.min(1, (rNorm - 0.5) * contrast + 0.5));
                                    gNorm = Math.max(0, Math.min(1, (gNorm - 0.5) * contrast + 0.5));
                                    bNorm = Math.max(0, Math.min(1, (bNorm - 0.5) * contrast + 0.5));
                                }
                                if (useSaturation) {
                                    const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                    rNorm = Math.max(0, Math.min(1, gray + saturation * (rNorm - gray)));
                                    gNorm = Math.max(0, Math.min(1, gray + saturation * (gNorm - gray)));
                                    bNorm = Math.max(0, Math.min(1, gray + saturation * (bNorm - gray)));
                                }

                                colorsArray[particleIndex * 3] = Math.min(1.0, rNorm * brightness);
                                colorsArray[particleIndex * 3 + 1] = Math.min(1.0, gNorm * brightness);
                                colorsArray[particleIndex * 3 + 2] = Math.min(1.0, bNorm * brightness);

                                // Update instance matrix position
                                if (positions) {
                                    const px = positions[particleIndex * 3];
                                    const py = positions[particleIndex * 3 + 1];
                                    const targetZ = initialZs[particleIndex];
                                    reusableMatrix2.setPosition(px, py, targetZ);
                                    screen.setMatrixAt(particleIndex, reusableMatrix2);
                                }

                                particleIndex++;
                            }
                        }
                    }
                    screen.instanceColor.needsUpdate = true;
                    screen.instanceMatrix.needsUpdate = true;

                } else if (screen.geometry && screen.geometry.attributes.color) {
                    // 2D MODE: Update point colors and positions
                    const colorsArray = screen.geometry.attributes.color.array;
                    const positionsArray = screen.geometry.attributes.position.array;
                    const initialZArray = screen.geometry.attributes.initialZ ? screen.geometry.attributes.initialZ.array : null;

                    let particleIndex = 0;
                    for (let y = 0; y < TARGET_HEIGHT && particleIndex * 3 < colorsArray.length; y += step) {
                        for (let x = 0; x < TARGET_WIDTH && particleIndex * 3 < colorsArray.length; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            if (data[i + 3] > 30) {
                                const r = data[i], g = data[i + 1], b = data[i + 2];
                                const luminance = (r + g + b) * rgbToLumFactor;
                                const newDepth = (luminance - minLuminance) * depthSpread;

                                // Update depth
                                if (initialZArray) {
                                    const oldDepth = initialZArray[particleIndex];
                                    const depthDelta = Math.abs(newDepth - oldDepth);
                                    if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                        initialZArray[particleIndex] = newDepth;
                                        positionsArray[particleIndex * 3 + 2] = newDepth;
                                    }
                                }

                                // Update color
                                let rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                                if (useContrast) {
                                    rNorm = Math.max(0, Math.min(1, (rNorm - 0.5) * contrast + 0.5));
                                    gNorm = Math.max(0, Math.min(1, (gNorm - 0.5) * contrast + 0.5));
                                    bNorm = Math.max(0, Math.min(1, (bNorm - 0.5) * contrast + 0.5));
                                }
                                if (useSaturation) {
                                    const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                    rNorm = Math.max(0, Math.min(1, gray + saturation * (rNorm - gray)));
                                    gNorm = Math.max(0, Math.min(1, gray + saturation * (gNorm - gray)));
                                    bNorm = Math.max(0, Math.min(1, gray + saturation * (bNorm - gray)));
                                }

                                colorsArray[particleIndex * 3] = Math.min(1.0, rNorm * brightness);
                                colorsArray[particleIndex * 3 + 1] = Math.min(1.0, gNorm * brightness);
                                colorsArray[particleIndex * 3 + 2] = Math.min(1.0, bNorm * brightness);

                                particleIndex++;
                            }
                        }
                    }
                    screen.geometry.attributes.color.needsUpdate = true;
                    screen.geometry.attributes.position.needsUpdate = true;
                    if (initialZArray) {
                        screen.geometry.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Collision detection function (for FPS mode) - VERSION FINALE
        // FIX: Épaisseur minimale pour les PlaneGeometry qui n'ont pas d'épaisseur intrinsèque
        const WALL_THICKNESS = 10; // Épaisseur minimale des murs pour la collision (en unités)

        function checkCollision(newPosition, prevPosition) {
            if (!fpsMode) return false;

            const hitboxWidth = fpsSettings.fpsHitboxWidth / 2; // Demi-largeur
            const hitboxHeight = fpsSettings.fpsHitboxHeight / 2; // Demi-hauteur

            // Collecter tous les murs (pas les sols 3, 10 et 11)
            // Inclut à la fois les écrans volumétriques (1,2,5,6,7) et les surfaces de couleur (4,8-21+)
            const walls = [];
            for (const key in allScreens) {
                if (key === '3' || key === '10' || key === '11') continue; // Skip floors

                const screen = allScreens[key];
                // Include both volumetric screens and color surfaces (all non-floor screens)
                if (screen && screen.visible !== false) {
                    walls.push(screen);
                }
            }

            if (walls.length === 0) return false;

            // OPTIMIZED: Reuse global Box3 objects instead of creating new ones
            reusablePlayerBox.min.set(
                newPosition.x - hitboxWidth,
                newPosition.y - hitboxHeight,
                newPosition.z - hitboxWidth
            );
            reusablePlayerBox.max.set(
                newPosition.x + hitboxWidth,
                newPosition.y + hitboxHeight,
                newPosition.z + hitboxWidth
            );

            // Tester collision avec chaque mur
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                reusableWallBox.setFromObject(wall);

                // FIX: Épaissir les bounding boxes qui sont trop fines (PlaneGeometry)
                // Calculer les dimensions de la box
                const sizeX = reusableWallBox.max.x - reusableWallBox.min.x;
                const sizeY = reusableWallBox.max.y - reusableWallBox.min.y;
                const sizeZ = reusableWallBox.max.z - reusableWallBox.min.z;

                // Si une dimension est trop fine (< WALL_THICKNESS), l'épaissir
                if (sizeX < WALL_THICKNESS) {
                    const centerX = (reusableWallBox.max.x + reusableWallBox.min.x) / 2;
                    reusableWallBox.min.x = centerX - WALL_THICKNESS / 2;
                    reusableWallBox.max.x = centerX + WALL_THICKNESS / 2;
                }
                if (sizeY < WALL_THICKNESS) {
                    const centerY = (reusableWallBox.max.y + reusableWallBox.min.y) / 2;
                    reusableWallBox.min.y = centerY - WALL_THICKNESS / 2;
                    reusableWallBox.max.y = centerY + WALL_THICKNESS / 2;
                }
                if (sizeZ < WALL_THICKNESS) {
                    const centerZ = (reusableWallBox.max.z + reusableWallBox.min.z) / 2;
                    reusableWallBox.min.z = centerZ - WALL_THICKNESS / 2;
                    reusableWallBox.max.z = centerZ + WALL_THICKNESS / 2;
                }

                if (reusablePlayerBox.intersectsBox(reusableWallBox)) {
                    return true; // Collision détectée !
                }
            }

            return false; // Pas de collision
        }

        // Animation with subtle breathing movement and video texture updates
        let animateFrameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // FPS Counter calculation
            fpsFrameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - fpsLastTime;

            if (deltaTime >= fpsUpdateInterval) {
                fpsCurrentFPS = Math.round((fpsFrameCount * 1000) / deltaTime);
                fpsFrameCount = 0;
                fpsLastTime = currentTime;

                // OPTIMIZED: Use cached DOM elements instead of querying
                if (fpsDOMCache.value && fpsDOMCache.counter) {
                    fpsDOMCache.value.textContent = fpsCurrentFPS;

                    // Color coding based on performance
                    fpsDOMCache.counter.classList.remove('low-fps', 'critical-fps');
                    if (fpsCurrentFPS < 30) {
                        fpsDOMCache.counter.classList.add('critical-fps');
                    } else if (fpsCurrentFPS < 50) {
                        fpsDOMCache.counter.classList.add('low-fps');
                    }
                }
            }

            animateFrameCount++;
            if (animateFrameCount === 1) {
                dbg('🎬 ANIMATE() - Première frame');
            } else if (animateFrameCount % 60 === 0) {
                dbg(`🎬 ANIMATE() - Frame ${animateFrameCount} (${(animateFrameCount/60).toFixed(0)}s)`);
            }

            time += 0.001 * breathSpeed;

            // SCROLL LISSÉ: Appliquer progressivement la vitesse de scroll
            if (Math.abs(scrollVelocity) > 0.01) {
                camera.getWorldDirection(reusableForward);

                if (fpsMode) {
                    // MODE FPS: Déplacement horizontal uniquement
                    const savedY = camera.position.y;
                    reusableForward.y = 0;
                    reusableForward.normalize();

                    reusablePrevPosition.copy(camera.position);
                    camera.position.addScaledVector(reusableForward, scrollVelocity);
                    camera.position.y = savedY;

                    // Vérifier collision
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                        scrollVelocity = 0; // Arrêter le mouvement en cas de collision
                    }
                } else {
                    // Mode admin: zoom libre
                    camera.position.addScaledVector(reusableForward, scrollVelocity);
                }

                // Décroissance de la vitesse (effet d'inertie)
                scrollVelocity *= SCROLL_DECAY;

                // Arrêter si très petit
                if (Math.abs(scrollVelocity) < 0.01) {
                    scrollVelocity = 0;
                }
            }

            // Update particle colors from current video frame (both 2D and 3D modes)
            if (currentVideo) {
                updateColorsFromVideo();
            }

            // Update colors for screens 2-5 from their respective videos
            updateMultiScreenColors();

            // PERFORMANCE: Update video texture seulement si la video a change de frame
            if (videoTexture && currentVideo && !currentVideo.paused) {
                // Verifier si la frame a change (throttle implicite)
                if (currentVideo.readyState >= 2) {
                    videoTexture.needsUpdate = true;
                }
            }

            if (particles && flowOffsets) {
                // PERFORMANCE: Pre-calculer epsilon une seule fois pour tous les ecrans
                const epsilon = 0.3 * breathSpeed;
                const flowActive = flowIntensity > 0;

                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            const newZ = initialZs[i] + breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowActive && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 7 if it has its own geometry (3D mode) - now at position 3
                    // SKIP if multi-video system has a dedicated video for this screen
                    if (allScreens[3] && allScreens[3].userData && allScreens[3].userData.is3D && !screenVideos[SCREEN_TO_VIDEO_MAP[3]]) {
                        const screen7 = allScreens[3];
                        const initialZs7 = screen7.userData.initialZ;
                        const positions7 = screen7.userData.positions;

                        if (initialZs7 && positions7 && initialZs7.length > 0) {
                            for (let i = 0; i < initialZs7.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs7[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowActive && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions7[i * 3] + flowX,
                                    positions7[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen7.setMatrixAt(i, reusableMatrix);
                            }
                            screen7.instanceMatrix.needsUpdate = true;
                        }
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (3D mode) - now at position 5
                    if (allScreens[6] && allScreens[6].userData && allScreens[6].userData.is3D) {
                        const screen3 = allScreens[6];
                        const initialZs3 = screen3.userData.initialZ;
                        const positions3 = screen3.userData.positions;

                        if (initialZs3 && positions3 && initialZs3.length > 0) {
                            for (let i = 0; i < initialZs3.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs3[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowActive && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions3[i * 3] + flowX,
                                    positions3[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen3.setMatrixAt(i, reusableMatrix);
                            }
                            screen3.instanceMatrix.needsUpdate = true;
                        }
                    }

                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        positions[i * 3 + 2] = initialZs[i] + breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;

                    // CRITICAL: Also update screen 7 if it has its own geometry (2D mode) - now at position 3
                    // SKIP if multi-video system has a dedicated video for this screen
                    if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.position && !screenVideos[SCREEN_TO_VIDEO_MAP[3]]) {
                        const screen7 = allScreens[3];
                        const geom7 = screen7.geometry;
                        const positions7 = geom7.attributes.position.array;
                        const initialZs7 = geom7.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom7.userData.initialPositions) {
                            geom7.userData.initialPositions = new Float32Array(positions7.length);
                            for (let i = 0; i < positions7.length; i++) {
                                geom7.userData.initialPositions[i] = positions7[i];
                            }
                        }

                        const initialPositions7 = geom7.userData.initialPositions;

                        for (let i = 0; i < positions7.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions7[i * 3] = initialPositions7[i * 3] + flowX;
                            positions7[i * 3 + 1] = initialPositions7[i * 3 + 1] + flowY;
                            positions7[i * 3 + 2] = initialZs7[i] + breathOffset;
                        }

                        geom7.attributes.position.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (2D mode) - now at position 5
                    if (allScreens[6] && allScreens[6].geometry && allScreens[6].geometry.attributes.position) {
                        const screen3 = allScreens[6];
                        const geom3 = screen3.geometry;
                        const positions3 = geom3.attributes.position.array;
                        const initialZs3 = geom3.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom3.userData.initialPositions) {
                            geom3.userData.initialPositions = new Float32Array(positions3.length);
                            for (let i = 0; i < positions3.length; i++) {
                                geom3.userData.initialPositions[i] = positions3[i];
                            }
                        }

                        const initialPositions3 = geom3.userData.initialPositions;

                        for (let i = 0; i < positions3.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions3[i * 3] = initialPositions3[i * 3] + flowX;
                            positions3[i * 3 + 1] = initialPositions3[i * 3 + 1] + flowY;
                            positions3[i * 3 + 2] = initialZs3[i] + breathOffset;
                        }

                        geom3.attributes.position.needsUpdate = true;
                    }
                }
            }

            // Mobile joystick movement
            if (typeof applyJoystickMovement === 'function') {
                applyJoystickMovement();
            }

            // Free camera rotation (apply yaw and pitch)
            if (freeCameraEnabled && camera) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;
            }

            // Camera movement (only when no screen selected and free camera enabled)
            if (!selectedScreen && freeCameraEnabled && camera) {
                // OPTIMIZED: Reuse global Vector3 objects
                camera.getWorldDirection(reusableForward);
                reusableForward.y = 0; // Mouvement horizontal uniquement
                reusableForward.normalize();

                reusableRight.crossVectors(reusableForward, reusableUp);
                reusableRight.normalize();

                // Check if any movement key is pressed
                const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;

                if (fpsMode) {
                    // ===== MODE FPS: Vitesse graduée avec accélération =====

                    if (isMoving) {
                        // Accélération progressive
                        currentSpeed = Math.min(currentSpeed + fpsSettings.fpsAcceleration, fpsSettings.fpsMaxSpeed);
                        if (cameraKeys.sprint) {
                            currentSpeed = Math.min(currentSpeed, fpsSettings.fpsMaxSpeed * 1.5); // Sprint limité
                        }
                    } else {
                        // Décélération
                        currentSpeed = Math.max(currentSpeed - fpsSettings.fpsDeceleration, MIN_SPEED);
                    }

                    // OPTIMIZED: Reuse global Vector3 for previous position
                    reusablePrevPosition.copy(camera.position);

                    // Apply movement
                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, currentSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -currentSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -currentSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, currentSpeed);
                    }

                    // Check collisions
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                    }
                } else {
                    // ===== MODE NORMAL: Vitesse fixe, pas de collision =====

                    const normalSpeed = cameraKeys.sprint ? CAMERA_SPEED * CAMERA_SPRINT_MULTIPLIER : CAMERA_SPEED;

                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, normalSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -normalSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -normalSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, normalSpeed);
                    }
                }

                if (fpsMode) {
                    // ===== MODE FPS: Gravité et marche sur le sol =====

                    // PERFORMANCE: Throttle raycasting (tous les 2 frames)
                    raycastCounter++;
                    let groundY = lastGroundY;

                    if (raycastCounter >= RAYCAST_INTERVAL) {
                        raycastCounter = 0;

                        // PERFORMANCE: Cache le tableau des sols
                        if (!cachedFloorScreens) {
                            cachedFloorScreens = [];
                            if (allScreens[6]) cachedFloorScreens.push(allScreens[6]);
                            if (allScreens[10]) cachedFloorScreens.push(allScreens[10]);
                            if (allScreens[11]) cachedFloorScreens.push(allScreens[11]);
                        }

                        reusableRaycaster.set(camera.position, downVector);
                        const intersects = reusableRaycaster.intersectObjects(cachedFloorScreens, false);

                        if (intersects.length > 0) {
                            groundY = intersects[0].point.y + fpsSettings.fpsPlayerHeight;
                            lastGroundY = groundY;
                        } else {
                            groundY = null;
                            lastGroundY = null;
                        }
                    }

                    if (groundY !== null) {
                        const distanceToGround = camera.position.y - groundY;

                        if (distanceToGround <= 1) {
                            // On est au sol - fixer Y et annuler vélocité
                            camera.position.y = groundY;
                            playerVelocityY = 0;
                            isOnGround = true;
                        } else {
                            // On est en l'air - appliquer gravité
                            isOnGround = false;
                            playerVelocityY += fpsSettings.fpsGravity;
                            camera.position.y += playerVelocityY;
                        }
                    } else {
                        // Pas de sol détecté - tomber
                        isOnGround = false;
                        playerVelocityY += fpsSettings.fpsGravity;
                        camera.position.y += playerVelocityY;
                    }

                    // Head bobbing effect when moving
                    const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;
                    if (isMoving && playerVelocityY === 0) { // Only bob when on ground
                        headBobTimer += HEAD_BOB_SPEED * (cameraKeys.sprint ? 1.5 : 1);
                        const bobOffset = Math.sin(headBobTimer) * HEAD_BOB_AMOUNT;
                        camera.position.y += bobOffset;
                    } else {
                        headBobTimer *= 0.9;
                    }

                    // FOV kick during sprint
                    targetFOV = cameraKeys.sprint ? DEFAULT_FOV + SPRINT_FOV_INCREASE : DEFAULT_FOV;

                    // Visualisation de la hitbox
                    if (showHitbox) {
                        // Créer ou mettre à jour le helper
                        if (!hitboxHelper) {
                            // Créer un wireframe box pour visualiser la hitbox
                            const hitboxGeometry = new THREE.BoxGeometry(1, 1, 1); // Base size
                            const hitboxMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00ff00,
                                wireframe: true,
                                transparent: true,
                                opacity: 0.5
                            });
                            hitboxHelper = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                            scene.add(hitboxHelper);
                        }

                        // Mettre à jour la position et la taille de la hitbox dynamiquement
                        hitboxHelper.position.copy(camera.position);
                        hitboxHelper.scale.set(
                            fpsSettings.fpsHitboxWidth,
                            fpsSettings.fpsHitboxHeight,
                            fpsSettings.fpsHitboxWidth
                        );
                        hitboxHelper.visible = true;
                    } else if (hitboxHelper) {
                        hitboxHelper.visible = false;
                    }

                } else {
                    // ===== MODE NORMAL: Déplacement libre avec O/L =====

                    if (cameraKeys.up) {
                        camera.position.y += currentSpeed;
                    }
                    if (cameraKeys.down) {
                        camera.position.y -= currentSpeed;
                    }

                    // Pas de collision en mode normal (mode édition)
                    targetFOV = DEFAULT_FOV;
                }
            }

            // Smooth FOV transition
            if (camera && Math.abs(currentFOV - targetFOV) > 0.1) {
                currentFOV += (targetFOV - currentFOV) * 0.1;
                camera.fov = currentFOV;
                camera.updateProjectionMatrix();
            }

            // OPTIMIZED: Throttle CubeCamera updates (expensive: renders scene 6 times)
            if (allScreens && allScreens[4] && allScreens[4].userData.cubeCamera) {
                cubeCameraUpdateCounter++;
                if (cubeCameraUpdateCounter >= CUBE_CAMERA_UPDATE_INTERVAL) {
                    cubeCameraUpdateCounter = 0;
                    const screen4 = allScreens[4];
                    const cubeCamera = screen4.userData.cubeCamera;
                    screen4.visible = false;  // Cacher l'écran pour éviter auto-réflexion
                    cubeCamera.update(renderer, scene);  // Capturer l'environnement
                    screen4.visible = true;  // Réafficher l'écran
                }
            }

            // Update game instructions visibility based on Y position
            // Floor 11 is at Y=-111.773, with eye height 25, camera should be at Y≈-86.773
            // PERFORMANCE: Utilise le cache DOM au lieu de getElementById
            if (fpsDOMCache.gameInstructions) {
                const instructionsElement = fpsDOMCache.gameInstructions;
                // Show instructions ONLY in FPS mode when on floor 11
                if (fpsMode && !isPaused) {
                    const FLOOR_11_Y = -111.773;
                    const expectedCameraY = FLOOR_11_Y + fpsSettings.fpsPlayerHeight;
                    const tolerance = 8;

                    const isOnFloor11 = Math.abs(camera.position.y - expectedCameraY) < tolerance;

                    if (isOnFloor11 && !instructionsHidden) {
                        // Show instructions until user interacts enough
                        instructionsElement.classList.remove('hidden');
                    } else {
                        instructionsElement.classList.add('hidden');
                    }
                } else {
                    // Hide instructions in admin mode or when paused
                    instructionsElement.classList.add('hidden');
                }
            }

            if (animateFrameCount === 1) {
                dbg('🖼️ RENDER() - Premier rendu de la scène');
            }
            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Only resize if camera and renderer are initialized
            if (!camera || !renderer) return;

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                scheduleRegenerate();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                if (currentVideo) generate(currentVideo);
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        // Update glass material for screen 10
        function updateGlassMaterial() {
            if (allScreens[10] && allScreens[10].userData.isGlass) {
                const mat = allScreens[10].material;
                mat.metalness = fpsSettings.glassMetalness;
                mat.roughness = fpsSettings.glassRoughness;
                mat.opacity = fpsSettings.glassOpacity;
                mat.needsUpdate = true;
                dbg('🔄 Matériau verre mis à jour:', {
                    opacity: fpsSettings.glassOpacity,
                    metalness: fpsSettings.glassMetalness,
                    roughness: fpsSettings.glassRoughness
                });
            } else {
                console.warn('⚠️ Écran 10 pas encore créé ou pas marqué comme verre');
            }
        }

        // FPS Settings Panel Management
        function setupFPSSettings() {
            const panel = document.getElementById('fps-settings-panel');
            const sliders = {
                'fps-speed': { var: 'fpsMaxSpeed', display: 'val-fps-speed', decimals: 2 },
                'fps-scroll': { var: 'fpsScrollSpeed', display: 'val-fps-scroll', decimals: 1 },
                'fps-accel': { var: 'fpsAcceleration', display: 'val-fps-accel', decimals: 2 },
                'fps-decel': { var: 'fpsDeceleration', display: 'val-fps-decel', decimals: 2 },
                'fps-height': { var: 'fpsCameraHeight', display: 'val-fps-height', decimals: 0 },
                'fps-gravity': { var: 'fpsGravity', display: 'val-fps-gravity', decimals: 2 },
                'fps-eye': { var: 'fpsPlayerHeight', display: 'val-fps-eye', decimals: 0 },
                'fps-mouse': { var: 'fpsMouseSensitivity', display: 'val-fps-mouse', decimals: 4 },
                'fps-hitbox-width': { var: 'fpsHitboxWidth', display: 'val-fps-hitbox-width', decimals: 1 },
                'fps-hitbox-height': { var: 'fpsHitboxHeight', display: 'val-fps-hitbox-height', decimals: 0 },
                'glass-opacity': { var: 'glassOpacity', display: 'val-glass-opacity', decimals: 2, callback: updateGlassMaterial },
                'glass-roughness': { var: 'glassRoughness', display: 'val-glass-roughness', decimals: 2, callback: updateGlassMaterial },
                'glass-metalness': { var: 'glassMetalness', display: 'val-glass-metalness', decimals: 2, callback: updateGlassMaterial }
            };

            // Setup sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const config = sliders[sliderId];

                // Skip if slider doesn't exist in DOM
                if (!slider) {
                    console.warn(`⚠️ Slider "${sliderId}" not found in HTML`);
                    return;
                }

                slider.addEventListener('input', function() {
                    const value = parseFloat(this.value);

                    // Update variable in fpsSettings
                    fpsSettings[config.var] = value;

                    // Update display
                    const displayValue = value.toFixed(config.decimals);
                    document.getElementById(config.display).textContent = displayValue;

                    dbg(`✅ ${config.var} = ${displayValue}`);

                    // Call callback if provided
                    if (config.callback) {
                        config.callback();
                    }

                    // Log hitbox changes specifically
                    if (config.var === 'fpsHitboxWidth' || config.var === 'fpsHitboxHeight') {
                        dbg('🎯 Hitbox mise à jour:', {
                            largeur: fpsSettings.fpsHitboxWidth,
                            hauteur: fpsSettings.fpsHitboxHeight
                        });
                    }
                });
            });

            // Export button
            document.getElementById('fps-export-btn').addEventListener('click', exportFPSSettings);

            // Ctrl+S to export
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.code === 'KeyS') {
                    e.preventDefault();
                    exportFPSSettings();
                }
            });
        }

        function exportFPSSettings() {
            console.clear();
            dbg('═════════════════════════════════════════════');
            dbg('📋 PARAMÈTRES FPS - EXPORT');
            dbg('═════════════════════════════════════════════');
            dbg('');
            dbg('Copie ces valeurs pour intégration:');
            dbg('');
            dbg('fpsMaxSpeed = ' + fpsSettings.fpsMaxSpeed + ';');
            dbg('fpsScrollSpeed = ' + fpsSettings.fpsScrollSpeed + ';');
            dbg('fpsAcceleration = ' + fpsSettings.fpsAcceleration + ';');
            dbg('fpsDeceleration = ' + fpsSettings.fpsDeceleration + ';');
            dbg('fpsCameraHeight = ' + fpsSettings.fpsCameraHeight + ';');
            dbg('fpsCollisionRadius = ' + fpsSettings.fpsCollisionRadius + ';');
            dbg('fpsGravity = ' + fpsSettings.fpsGravity + ';');
            dbg('fpsPlayerHeight = ' + fpsSettings.fpsPlayerHeight + ';');
            dbg('fpsMouseSensitivity = ' + fpsSettings.fpsMouseSensitivity + ';');
            dbg('');
            dbg('═════════════════════════════════════════════');
            dbg('✅ Paramètres exportés dans la console!');
            dbg('   Appuie sur Ctrl+S pour ré-exporter');
            dbg('═════════════════════════════════════════════');

            // Also copy to clipboard
            const exportText = Object.entries(fpsSettings)
                .map(([key, value]) => `${key} = ${value};`)
                .join('\n');

            navigator.clipboard.writeText(exportText).then(() => {
                dbg('📋 Copié dans le presse-papier!');
            }).catch(err => {
                console.warn('Impossible de copier dans le presse-papier:', err);
            });
        }

        // Toggle FPS panel with F key (Admin mode only)
        document.addEventListener('keydown', function(e) {
            if (e.code === 'KeyF' && !e.ctrlKey && !e.shiftKey && !e.altKey && !fpsMode) {
                const panel = document.getElementById('fps-settings-panel');
                panel.classList.toggle('hidden');
                dbg(panel.classList.contains('hidden') ? '🔧 FPS Settings cachés (F pour afficher)' : '🔧 FPS Settings affichés (F pour cacher)');
            }
        });

        // Draggable panels system
        function makeDraggable(element) {
            if (!element) return;

            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                // Don't drag if clicking on interactive elements
                const tagName = e.target.tagName;
                const classList = e.target.classList;

                // Exclude interactive elements
                if (tagName === 'BUTTON' || tagName === 'INPUT' || tagName === 'SELECT' ||
                    tagName === 'VIDEO' || tagName === 'A' || tagName === 'TEXTAREA') {
                    return;
                }

                // Exclude specific classes
                if (classList.contains('screen-list') || classList.contains('slider') ||
                    classList.contains('param-row') || classList.contains('slider-wrapper') ||
                    classList.contains('video-controls') || classList.contains('timeline-container') ||
                    classList.contains('preview') || classList.contains('arrow-btn') ||
                    classList.contains('value')) {
                    return;
                }

                // Only drag from the title or empty areas
                // Allow drag from h2, h3, or the main container background
                const isTitle = tagName === 'H2' || tagName === 'H3';
                const isContainer = e.target === element;

                if (!isTitle && !isContainer) {
                    return;
                }

                e.preventDefault();
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                element.style.cursor = 'grabbing';
            }

            function elementDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                const newTop = element.offsetTop - pos2;
                const newLeft = element.offsetLeft - pos1;

                // Keep within viewport bounds
                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;

                element.style.top = Math.max(0, Math.min(newTop, maxY)) + "px";
                element.style.left = Math.max(0, Math.min(newLeft, maxX)) + "px";
                element.style.bottom = "auto";
                element.style.right = "auto";
            }

            function closeDragElement() {
                isDragging = false;
                document.onmouseup = null;
                document.onmousemove = null;
                element.style.cursor = 'move';
            }
        }

        // Audio system with progressive fade
        let backgroundMusic = null;
        let footstepSound = null;
        let isPaused = false;
        let lastPauseToggleTime = 0; // Debounce pour éviter double ESC
        const PAUSE_DEBOUNCE_MS = 300; // Délai minimum entre toggles pause

        // Instructions timer (hide after 5 seconds)
        // Track keyboard interactions instead of time
        let uniqueKeysPressed = new Set();
        let scrollCount = 0; // Compteur de scrolls pour cacher les instructions
        let instructionsHidden = false;
        const REQUIRED_UNIQUE_KEYS = 2;  // Au moins 2 touches distinctes
        const REQUIRED_SCROLLS = 3;      // Au moins 3 scrolls après les touches
        const KEY_HOLD_DURATION = 1000;  // Ou 1 touche maintenue ≥ 1 seconde
        let keyHoldTimer = null;
        let keyHoldStartTime = null;

        // Legacy audio variables (for backward compatibility)
        let targetVolume = 0.7;
        let currentVolume = 0.7;
        let volumeFadeInterval = null;
        let isMuted = false;

        // ═══════════════════════════════════════════════════════════════
        // AUDIO MANAGER - Professional audio system
        // ═══════════════════════════════════════════════════════════════
        const AudioManager = {
            // State
            music: null,
            clickSound: null,
            audioContext: null,
            masterVolume: 0.3,
            currentMusicVolume: 0.3,
            isMuted: false,
            fadeInterval: null,

            // Initialize audio system
            init() {
                // Background music
                this.music = new Audio('son/Teimo.mp3');
                this.music.loop = true;
                this.music.volume = this.masterVolume;
                this.currentMusicVolume = this.masterVolume;

                // Click sound effect
                this.clickSound = new Audio('son/immersivecontrol-button-click-sound-463065.mp3');
                this.clickSound.volume = 0.5; // Base volume for click sound

                // Web Audio Context for UI sounds (fallback)
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.warn('Web Audio API not supported');
                }

                dbg('🔊 AudioManager initialized');
            },

            // Play background music
            playMusic() {
                if (!this.music) return;

                this.music.play().catch(err => {
                    console.warn('⚠️ Autoplay blocked:', err);
                });
                this.fadeMusicTo(this.masterVolume, 500);
            },

            // Pause background music
            pauseMusic() {
                if (!this.music) return;

                this.fadeMusicTo(0, 500);
                setTimeout(() => {
                    if (this.music) this.music.pause();
                }, 500);
            },

            // Fade music volume
            fadeMusicTo(targetVolume, duration = 800) {
                if (this.fadeInterval) clearInterval(this.fadeInterval);

                const steps = 30;
                const stepDuration = duration / steps;
                const volumeDelta = (targetVolume - this.currentMusicVolume) / steps;

                let step = 0;
                this.fadeInterval = setInterval(() => {
                    step++;
                    this.currentMusicVolume += volumeDelta;

                    if (!this.isMuted && this.music) {
                        this.music.volume = Math.max(0, Math.min(1, this.currentMusicVolume));
                    }

                    if (step >= steps) {
                        clearInterval(this.fadeInterval);
                        this.fadeInterval = null;
                        this.currentMusicVolume = targetVolume;
                    }
                }, stepDuration);
            },

            // Set master volume
            setVolume(volume) {
                this.masterVolume = volume;
                if (!this.isMuted && this.music) {
                    this.music.volume = volume;
                    this.currentMusicVolume = volume;
                }
            },

            // Toggle mute
            toggleMute() {
                this.isMuted = !this.isMuted;

                const soundWaves = document.getElementById('sound-waves');
                const muteSlash = document.getElementById('mute-slash');

                if (this.isMuted) {
                    // Mute everything
                    if (this.music) this.music.volume = 0;
                    soundWaves.style.display = 'none';
                    muteSlash.style.display = 'block';
                } else {
                    // Unmute
                    if (this.music) this.music.volume = this.currentMusicVolume;
                    soundWaves.style.display = 'block';
                    muteSlash.style.display = 'none';

                    // Play confirmation sound
                    this.playClick();
                }
            },

            // Play click sound (using audio file)
            playClick() {
                if (this.isMuted || !this.clickSound) return;

                try {
                    // Reset to start and play immediately (no delay)
                    this.clickSound.currentTime = 0;
                    this.clickSound.volume = 0.5 * this.masterVolume;
                    this.clickSound.play().catch(err => {
                        console.warn('Click sound playback error:', err);
                    });
                } catch(e) {
                    console.warn('Click sound error:', e);
                }
            }
        };

        // Legacy function wrappers (for backward compatibility)
        function initAudio() {
            AudioManager.init();
            backgroundMusic = AudioManager.music;
        }

        function playClickSound() {
            AudioManager.playClick();
        }

        function playAudio() {
            AudioManager.playMusic();
        }

        function pauseAudio() {
            AudioManager.pauseMusic();
        }

        function fadeVolume(target, duration = 800) {
            AudioManager.fadeMusicTo(target, duration);
        }

        function updateVolume(value) {
            const volumePercent = parseInt(value);

            const newVolume = volumePercent / 100;
            AudioManager.setVolume(newVolume);

            // Update legacy variables
            targetVolume = newVolume;
            currentVolume = newVolume;
        }

        function toggleMute() {
            AudioManager.toggleMute();
            isMuted = AudioManager.isMuted;
        }

        // Footstep sounds (trigger when moving)
        let footstepTimer = 0;
        let isMoving = false;
        function playFootsteps() {
            // Placeholder - add footstep sound file if you have one
            // if (footstepSound && fpsMode) {
            //     footstepSound.currentTime = 0;
            //     footstepSound.play().catch(err => {});
            // }
        }

        // Welcome screen functions
        window.handlePlayClick = function() {
            playClickSound(); // Click feedback

            // Passer en état clickedPlay
            document.body.classList.remove('hoverPlay');
            document.body.classList.add('clickedPlay');

            // Activer le logo animé et cacher le logo statique
            const logoVideo = document.getElementById('welcome-logo-video');
            const logoStatic = document.getElementById('welcome-logo');
            if (logoStatic) {
                logoStatic.style.opacity = '0';
            }
            if (logoVideo) {
                logoVideo.classList.add('active');
                logoVideo.play();
            }

            // Attendre la fin des animations avant de démarrer l'expérience
            setTimeout(() => {
                startExperience();
            }, 600);
        }

        // Gérer le hover sur le bouton play
        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('mouseenter', () => {
                document.body.classList.add('hoverPlay');
            });

            playButton.addEventListener('mouseleave', () => {
                if (!document.body.classList.contains('clickedPlay')) {
                    document.body.classList.remove('hoverPlay');
                }
            });
        }

        function startExperience() {
            const welcomeScreen = document.getElementById('welcome-screen');
            const loadingScreen = document.getElementById('loading-screen');

            // Hide welcome screen
            welcomeScreen.classList.add('hidden');

            // Show loading screen IMMEDIATELY
            loadingScreen.classList.add('active');
            loadingScreen.classList.remove('hidden');

            // Immediately hide cursor - user should enter FPS mode directly
            document.body.style.cursor = 'none';

            // Start the auto-load sequence after welcome screen
            setTimeout(() => {
                welcomeScreen.style.display = 'none';
                init();
                setupFPSSettings();

                // Make panels draggable
                makeDraggable(document.getElementById('screen-manager-panel'));
                makeDraggable(document.getElementById('fps-settings-panel'));
                makeDraggable(document.getElementById('ui'));

                // Setup pause screen click handler (click anywhere to resume)
                document.getElementById('pause-screen').addEventListener('click', function(e) {
                    // Only resume if clicking on the background (not on controls)
                    if (e.target.id === 'pause-screen') {
                        resumeExperience();
                    }
                });

                autoLoadSequence();
            }, 100);
        }

        // Pause screen functions
        function showPauseScreen() {
            if (!fpsMode) return; // Only in Spectator mode

            // Debounce: évite la double action ESC
            const now = performance.now();
            if (now - lastPauseToggleTime < PAUSE_DEBOUNCE_MS) {
                dbg('⏳ showPauseScreen ignoré (debounce)');
                return;
            }
            lastPauseToggleTime = now;

            isPaused = true;
            document.getElementById('pause-screen').classList.add('active');

            // Volume constant - pas de fade
            // Note: Pointer lock is automatically released by ESC key before this function is called
        }

        function resumeExperience() {
            playClickSound(); // Satisfying click feedback

            // Debounce: évite la double action ESC
            lastPauseToggleTime = performance.now();

            isPaused = false;
            document.getElementById('pause-screen').classList.remove('active');

            // Volume constant - pas de fade

            // CRITICAL: Request pointer lock immediately to avoid intermediate cursor state
            if (fpsMode && renderer && renderer.domElement) {
                renderer.domElement.requestPointerLock();
            }
        }

        window.onload = function() {
            // Don't auto-start - wait for user interaction on welcome screen
            initAudio();
            dbg('═══════════════════════════════════════════════════════');
            dbg('📦 WINDOW.ONLOAD - Page chargée');
            dbg('💡 Cliquez sur PLAY pour démarrer');
            dbg('═══════════════════════════════════════════════════════');

            // Remove initial black loader
            const initialLoader = document.getElementById('initial-loader');
            if (initialLoader) {
                initialLoader.classList.add('fade-out');
                setTimeout(() => {
                    initialLoader.remove();
                }, 300);
            }

            // Handle background video loading
            const welcomeVideo = document.getElementById('welcome-video-bg');
            if (welcomeVideo) {
                welcomeVideo.addEventListener('canplaythrough', function() {
                    welcomeVideo.classList.add('loaded');
                    dbg('✅ Vidéo d\'arrière-plan chargée');
                });

                welcomeVideo.addEventListener('error', function() {
                    dbg('⚠️ Vidéo d\'arrière-plan non disponible - fond noir utilisé');
                    welcomeVideo.style.display = 'none';
                });
            }
        };

        // Auto-load sequence: Load default video → Activate FPS → Show UI → Apply
        async function autoLoadSequence() {
            const loadingScreen = document.getElementById('loading-screen');

            try {
                // Step 1: Load videos for all volumetric screens
                dbg('🎬 AUTO-LOAD: Chargement des vidéos multi-écrans...');
                await loadVolumetricScreenVideos();

                // Fallback: also load default video for backward compatibility
                await loadDefaultVideo();
                await sleep(500);

                // Step 2: Activate FPS mode (Spectator mode)
                dbg('🎮 AUTO-LOAD: Activation du mode SPECTATEUR...');
                fpsMode = true;

                // Hide all interfaces in Spectator mode
                document.getElementById('ui')?.classList.add('hidden');
                document.getElementById('screen-manager-panel')?.classList.add('hidden');
                document.getElementById('shape-selector')?.classList.add('hidden');
                document.getElementById('fps-settings-panel')?.classList.add('hidden');
                document.getElementById('fps-counter')?.classList.add('hidden');

                // Play background music in Spectator mode
                playAudio();
                await sleep(300);

                // Step 3: Apply settings
                dbg('⚙️ AUTO-LOAD: Application des paramètres...');
                applySettings();
                await sleep(500);

                // Step 4: Synchroniser et lancer toutes les vidéos ensemble
                dbg('🔄 AUTO-LOAD: Synchronisation des vidéos...');
                syncStartAllVideos();
                await sleep(200);

                // Step 5: Hide loading screen
                dbg('✅ AUTO-LOAD: Séquence terminée!');
                await sleep(500);

                loadingScreen.classList.add('hidden');

                // Remove from DOM after transition
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);

                // CRITICAL: Request pointer lock immediately to avoid intermediate cursor state
                // Wait a bit for the loading screen to disappear, then request pointer lock
                setTimeout(() => {
                    if (fpsMode && renderer && renderer.domElement) {
                        dbg('🔒 Demande de pointer lock automatique...');
                        renderer.domElement.requestPointerLock();
                    }
                }, 800);

            } catch (error) {
                console.error('❌ AUTO-LOAD: Erreur:', error);

                // Hide loading screen anyway after 2s
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 2000);
            }
        }

        // Helper function to load default video (uses ecran1.mp4 if available, fallback to test_01.mp4)
        function loadDefaultVideo() {
            return new Promise((resolve, reject) => {
                // If multi-video system loaded ecran1.mp4, use it instead of test_01.mp4
                if (screenVideos[1] && screenVideos[1].videoWidth > 0) {
                    dbg('✅ Utilisation de ecran1.mp4 comme vidéo principale');
                    currentVideo = screenVideos[1];

                    // Show preview
                    const previewSrc = screenVideos[1].src || 'videos/ecran1.mp4';
                    document.getElementById('preview').innerHTML = '<video src="' + previewSrc + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                    document.getElementById('preview').classList.add('loaded');
                    const previewVideo = document.getElementById('preview').querySelector('video');
                    if (previewVideo) previewVideo.play();

                    // Auto-apply
                    dbg('🎬 Apply automatique après chargement vidéo multi-écrans...');
                    applySettings();

                    setTimeout(() => {
                        dbg('🎬 Apply automatique (2ème passe)...');
                        applySettings();
                        resolve();
                    }, 100);
                    return;
                }

                // Fallback: load test_01.mp4
                const videoElement = document.getElementById('video-source');
                const videoPath = 'videos/test_01.mp4';

                videoElement.src = videoPath;
                videoElement.load();

                videoElement.onloadeddata = function() {
                    dbg('✅ Vidéo fallback chargée:', videoPath);
                    currentVideo = videoElement;

                    // CRITICAL: Start playing the source video
                    videoElement.muted = true;
                    videoElement.loop = true;
                    videoElement.play().catch(err => {
                        console.warn('⚠️ Autoplay vidéo source bloqué:', err);
                    });

                    // Show preview
                    document.getElementById('preview').innerHTML = '<video src="' + videoPath + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                    document.getElementById('preview').classList.add('loaded');
                    const previewVideo = document.getElementById('preview').querySelector('video');
                    if (previewVideo) previewVideo.play();

                    // Auto-apply after loading
                    dbg('🎬 Apply automatique après chargement vidéo...');
                    applySettings();

                    // Second apply pass (like in original code)
                    setTimeout(() => {
                        dbg('🎬 Apply automatique (2ème passe)...');
                        applySettings();
                        resolve();
                    }, 100);
                };

                videoElement.onerror = function(error) {
                    console.error('❌ Erreur chargement vidéo:', error);
                    reject(error);
                };

                // Timeout fallback
                setTimeout(() => {
                    if (!currentVideo) {
                        reject(new Error('Timeout loading video'));
                    }
                }, 5000);
            });
        }

        // Charger la vidéo du sol (écran 6)
        let floorVideo = null;
        async function loadFloorVideo() {
            return new Promise((resolve) => {
                const videoElement = document.createElement('video');
                videoElement.id = 'video-floor';
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.playsinline = true;
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);

                const videoPath = 'videos/ecran_sol.webm';
                videoElement.src = videoPath;
                videoElement.load();

                let videoReady = false;
                videoElement.oncanplaythrough = function() {
                    if (videoReady) return;
                    videoReady = true;
                    videoElement.oncanplaythrough = null;

                    dbg(`✅ Vidéo sol chargée: ${videoPath}`);
                    dbg(`   Dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);

                    floorVideo = videoElement;
                    screenVideos[6] = videoElement;

                    videoElement.currentTime = 0.1;
                    videoElement.play().then(() => {
                        setTimeout(() => {
                            videoElement.pause();
                            dbg('🏠 Vidéo sol prête');
                            resolve(true);
                        }, 100);
                    }).catch(() => {
                        resolve(true);
                    });
                };

                videoElement.onerror = function() {
                    console.warn('⚠️ Vidéo sol non trouvée:', videoPath);
                    resolve(false);
                };

                setTimeout(() => {
                    if (!floorVideo) resolve(false);
                }, 5000);
            });
        }

        // PANORAMIC VIDEO SYSTEM: Load single panorama_opti.webm for all screens
        async function loadVolumetricScreenVideos() {
            dbg('🎬 Tentative de chargement de la vidéo panoramique (panorama_opti.webm)...');

            // Charger aussi la vidéo du sol en parallèle
            loadFloorVideo();

            return new Promise((resolve) => {
                // Create hidden video element for panoramic video
                const videoElement = document.createElement('video');
                videoElement.id = 'video-panorama';
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.playsinline = true;
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);

                // Try to load panoramic video
                const videoPath = 'videos/panorama_opti.webm';
                videoElement.src = videoPath;
                videoElement.load();

                let videoReady = false;
                videoElement.oncanplaythrough = function() {
                    if (videoReady) return; // Éviter les appels multiples
                    videoReady = true;
                    videoElement.oncanplaythrough = null; // Supprimer le handler

                    dbg(`✅ Vidéo panoramique chargée: ${videoPath}`);
                    dbg(`   Dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                    dbg(`   Attendu: ${PANORAMIC_WIDTH}x${PANORAMIC_HEIGHT}`);

                    // Store as the panoramic video
                    panoramicVideo = videoElement;

                    // Also set as screenVideos[1] for backward compatibility with generate()
                    screenVideos[1] = videoElement;

                    // Jouer brièvement pour que les pixels soient disponibles
                    videoElement.currentTime = 0.1;
                    videoElement.play().then(() => {
                        setTimeout(() => {
                            videoElement.pause();
                            dbg('🌅 MODE PANORAMIQUE ACTIVÉ - Pixels prêts');
                            resolve(true);
                        }, 100);
                    }).catch(() => {
                        dbg('🌅 MODE PANORAMIQUE ACTIVÉ');
                        resolve(true);
                    });
                };

                videoElement.onerror = function() {
                    console.warn('⚠️ Vidéo panoramique non trouvée:', videoPath);
                    console.warn('   Le fichier videos/panorama_opti.webm est requis');
                    panoramicVideo = null;
                    resolve(false);
                };

                // Timeout fallback
                setTimeout(() => {
                    if (!panoramicVideo) {
                        console.warn('⏱️ Timeout chargement vidéo panoramique');
                        resolve(false);
                    }
                }, 10000);
            });
        }

        // Synchroniser et lancer toutes les vidéos en même temps
        function syncStartAllVideos() {
            dbg('🔄 Synchronisation et lancement de toutes les vidéos...');

            // Lancer la vidéo du sol si disponible
            if (floorVideo) {
                floorVideo.currentTime = 0;
                floorVideo.play().catch(err => {
                    console.warn('⚠️ Erreur play sol:', err);
                });
                dbg('✅ Vidéo sol lancée');
            }

            // Mode panoramique: vidéo principale
            if (panoramicVideo) {
                panoramicVideo.currentTime = 0;
                panoramicVideo.play().catch(err => {
                    console.warn('⚠️ Erreur play panorama:', err);
                });
                dbg('✅ Vidéo panoramique lancée');
                return;
            }

            // Mode multi-vidéos: synchroniser toutes les vidéos
            const videos = Object.values(screenVideos).filter(v => v && v.videoWidth > 0);

            if (videos.length === 0) {
                console.warn('⚠️ Aucune vidéo à synchroniser');
                return;
            }

            // Mettre toutes les vidéos à 0 et les lancer en même temps
            videos.forEach(video => {
                video.currentTime = 0;
            });

            // Petit délai pour s'assurer que currentTime est appliqué
            setTimeout(() => {
                videos.forEach(video => {
                    video.play().catch(err => {
                        console.warn('⚠️ Erreur play:', err);
                    });
                });
                dbg(`✅ ${videos.length} vidéos lancées en synchronisation`);
            }, 50);
        }

        // Helper sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE CONTROLS - Gyroscope, Joystick, Pull-to-refresh
           ═══════════════════════════════════════════════════════════════ */

        // Détection mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

        // Variables globales mobile
        let gyroEnabled = false;
        let gyroPermissionGranted = false;
        let initialAlpha = null;
        let initialBeta = null;
        let initialGamma = null;
        let baseYaw = 0; // Orientation camera au demarrage
        let basePitch = 0;
        let joystickActive = false;
        let joystickData = { x: 0, y: 0 };
        let mobileInstructionsHidden = false;
        let touchDragEnabled = false; // Mode tap-and-drag actif
        let lastTouchX = 0;
        let lastTouchY = 0;

        // ═══════════════════════════════════════════════════════════════
        // VISIBILITY CHANGE - Couper le son quand page inactive
        // ═══════════════════════════════════════════════════════════════
        let wasPlayingBeforeHidden = false;

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page cachee (telephone verrouille, onglet change, etc.)
                if (AudioManager.music && !AudioManager.music.paused) {
                    wasPlayingBeforeHidden = true;
                    AudioManager.music.pause();
                }
            } else {
                // Page redevient visible
                if (wasPlayingBeforeHidden && AudioManager.music && fpsMode && !isPaused) {
                    AudioManager.music.play().catch(() => {});
                    wasPlayingBeforeHidden = false;
                }
            }
        });

        // Aussi gerer pagehide pour iOS Safari
        window.addEventListener('pagehide', () => {
            if (AudioManager.music) {
                AudioManager.music.pause();
            }
        });

        // ═══════════════════════════════════════════════════════════════
        // VOLUME SLIDER DYNAMIQUE
        // ═══════════════════════════════════════════════════════════════
        let volumeSliderTimeout = null;

        window.showVolumeSlider = function() {
            const volumeControl = document.getElementById('volume-control');
            if (volumeControl) {
                volumeControl.classList.add('active');
                // Auto-hide apres 3 secondes d'inactivite
                clearTimeout(volumeSliderTimeout);
                volumeSliderTimeout = setTimeout(() => {
                    hideVolumeSlider();
                }, 3000);
            }
        };

        window.hideVolumeSlider = function() {
            const volumeControl = document.getElementById('volume-control');
            if (volumeControl) {
                volumeControl.classList.remove('active');
            }
        };

        // Garder ouvert si on interagit avec le slider
        document.addEventListener('DOMContentLoaded', () => {
            const slider = document.getElementById('volume-slider');
            if (slider) {
                slider.addEventListener('input', () => {
                    clearTimeout(volumeSliderTimeout);
                    volumeSliderTimeout = setTimeout(() => {
                        hideVolumeSlider();
                    }, 3000);
                });
                slider.addEventListener('touchstart', () => {
                    clearTimeout(volumeSliderTimeout);
                });
                slider.addEventListener('touchend', () => {
                    volumeSliderTimeout = setTimeout(() => {
                        hideVolumeSlider();
                    }, 2000);
                });
            }
        });

        // ═══════════════════════════════════════════════════════════════
        // FULLSCREEN API
        // ═══════════════════════════════════════════════════════════════
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(() => {});
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // PULL-TO-REFRESH (Welcome screen only)
        // ═══════════════════════════════════════════════════════════════
        let ptrStartY = 0;
        let ptrCurrentY = 0;
        let ptrTriggered = false;
        const PTR_THRESHOLD = 80;

        function initPullToRefresh() {
            if (!isMobile) return;

            const welcomeScreen = document.getElementById('welcome-screen');
            const ptrIndicator = document.getElementById('pull-to-refresh');

            if (!welcomeScreen || !ptrIndicator) return;

            welcomeScreen.addEventListener('touchstart', (e) => {
                if (welcomeScreen.scrollTop === 0) {
                    ptrStartY = e.touches[0].clientY;
                    ptrIndicator.classList.add('visible');
                }
            }, { passive: true });

            welcomeScreen.addEventListener('touchmove', (e) => {
                if (ptrStartY === 0) return;

                ptrCurrentY = e.touches[0].clientY;
                const pullDistance = ptrCurrentY - ptrStartY;

                if (pullDistance > 0 && welcomeScreen.scrollTop === 0) {
                    if (pullDistance > PTR_THRESHOLD) {
                        ptrIndicator.classList.add('pulling');
                        ptrTriggered = true;
                    } else {
                        ptrIndicator.classList.remove('pulling');
                        ptrTriggered = false;
                    }
                }
            }, { passive: true });

            welcomeScreen.addEventListener('touchend', () => {
                if (ptrTriggered) {
                    const ptrIndicator = document.getElementById('pull-to-refresh');
                    ptrIndicator.classList.add('loading');
                    ptrIndicator.querySelector('.ptr-text').textContent = 'Actualisation...';

                    setTimeout(() => {
                        location.reload();
                    }, 500);
                } else {
                    ptrIndicator.classList.remove('visible', 'pulling');
                }
                ptrStartY = 0;
                ptrTriggered = false;
            }, { passive: true });
        }

        // ═══════════════════════════════════════════════════════════════
        // GYROSCOPE CAMERA CONTROL
        // ═══════════════════════════════════════════════════════════════
        window.requestGyroPermission = async function() {
            const permissionBtn = document.getElementById('gyro-permission-btn');

            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        gyroPermissionGranted = true;
                        enableGyroscope();
                        permissionBtn.style.display = 'none';
                    }
                } catch (error) {
                    console.warn('Gyroscope permission denied:', error);
                    permissionBtn.style.display = 'none';
                }
            } else {
                // Non-iOS ou ancien navigateur
                gyroPermissionGranted = true;
                enableGyroscope();
                permissionBtn.style.display = 'none';
            }
        };

        function enableGyroscope() {
            if (!isMobile || gyroEnabled) return;

            window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            gyroEnabled = true;
            dbg('📱 Gyroscope activé');
        }

        function handleDeviceOrientation(event) {
            if (!fpsMode || isPaused || !gyroEnabled || touchDragEnabled) return;

            const alpha = event.alpha || 0; // Rotation Z (compass/yaw)
            const beta = event.beta || 0;   // Rotation X (tilt front/back = pitch)
            const gamma = event.gamma || 0; // Rotation Y (tilt left/right)

            // Initialiser les valeurs de référence au premier événement
            if (initialAlpha === null) {
                initialAlpha = alpha;
                initialBeta = beta;
                initialGamma = gamma;
                // Sauvegarder l'orientation camera actuelle comme base
                baseYaw = cameraYaw;
                basePitch = cameraPitch;
                return;
            }

            // Calculer les deltas par rapport à la position initiale
            let deltaAlpha = alpha - initialAlpha;

            // Normaliser deltaAlpha (-180 à 180)
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;

            // Pour le pitch, utiliser beta (inclinaison avant/arriere)
            // beta = 0 quand le telephone est a plat, 90 quand vertical
            // On veut que le telephone tenu normalement (beta ~60-90) corresponde a regarder droit
            let deltaBeta = beta - initialBeta;

            // Sensibilité ajustee
            const yawSensitivity = 0.018;
            const pitchSensitivity = 0.012;
            const smoothing = 0.15;

            // Calculer les cibles en ajoutant aux valeurs de base
            const targetYaw = baseYaw - (deltaAlpha * yawSensitivity);
            const targetPitch = basePitch + (deltaBeta * pitchSensitivity);

            // Limiter le pitch (regarder haut/bas)
            const maxPitch = Math.PI / 2.5;
            const clampedPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));

            // Lissage progressif
            cameraYaw += (targetYaw - cameraYaw) * smoothing;
            cameraPitch += (clampedPitch - cameraPitch) * smoothing;
        }

        // Réinitialiser l'orientation de référence
        function resetGyroReference() {
            initialAlpha = null;
            initialBeta = null;
            initialGamma = null;
            baseYaw = cameraYaw;
            basePitch = cameraPitch;
        }

        // ═══════════════════════════════════════════════════════════════
        // JOYSTICK TACTILE
        // ═══════════════════════════════════════════════════════════════
        function initJoystick() {
            if (!isMobile) return;

            const joystick = document.getElementById('mobile-joystick');
            const thumb = joystick?.querySelector('.joystick-thumb');

            if (!joystick || !thumb) return;

            // Variables recalculees au premier touch (quand visible)
            let baseRadius = 0;
            let maxDistance = 0;
            let touchId = null;
            let centerX = 0;
            let centerY = 0;

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchId !== null) return;

                // Recalculer les dimensions maintenant que le joystick est visible
                if (baseRadius === 0) {
                    baseRadius = joystick.offsetWidth / 2;
                    maxDistance = baseRadius - (thumb.offsetWidth / 2);
                    if (maxDistance <= 0) maxDistance = 35; // Fallback
                }

                const touch = e.changedTouches[0];
                touchId = touch.identifier;

                const rect = joystick.getBoundingClientRect();
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;

                joystick.classList.add('active');
                updateJoystick(touch.clientX, touch.clientY);

                // Cacher instructions mobile au premier mouvement
                hideMobileInstructions();
            });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                        break;
                    }
                }
            });

            joystick.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        touchId = null;
                        joystick.classList.remove('active');
                        resetJoystick();
                        break;
                    }
                }
            });

            joystick.addEventListener('touchcancel', () => {
                touchId = null;
                joystick.classList.remove('active');
                resetJoystick();
            });

            function updateJoystick(clientX, clientY) {
                let deltaX = clientX - centerX;
                let deltaY = clientY - centerY;

                // Limiter au cercle
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }

                // Mettre à jour le thumb
                thumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                // Normaliser entre -1 et 1
                joystickData.x = deltaX / maxDistance;
                joystickData.y = deltaY / maxDistance;
                joystickActive = true;
            }

            function resetJoystick() {
                thumb.style.transform = 'translate(-50%, -50%)';
                joystickData.x = 0;
                joystickData.y = 0;
                joystickActive = false;
            }
        }

        // Appliquer le mouvement du joystick à la caméra
        function applyJoystickMovement() {
            if (!fpsMode || isPaused) return;

            // Si joystick pas actif, remettre toutes les touches a false
            if (!joystickActive) {
                cameraKeys.forward = false;
                cameraKeys.backward = false;
                cameraKeys.left = false;
                cameraKeys.right = false;
                return;
            }

            // Forward/Backward (Y axis inversé)
            if (Math.abs(joystickData.y) > 0.1) {
                cameraKeys.forward = joystickData.y < -0.1;
                cameraKeys.backward = joystickData.y > 0.1;
            } else {
                cameraKeys.forward = false;
                cameraKeys.backward = false;
            }

            // Left/Right
            if (Math.abs(joystickData.x) > 0.1) {
                cameraKeys.left = joystickData.x < -0.1;
                cameraKeys.right = joystickData.x > 0.1;
            } else {
                cameraKeys.left = false;
                cameraKeys.right = false;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // GYROSCOPE TOGGLE ET TAP-AND-DRAG
        // ═══════════════════════════════════════════════════════════════
        function initGyroToggle() {
            if (!isMobile) return;

            const toggleBtn = document.getElementById('gyro-toggle-btn');
            if (!toggleBtn) return;

            toggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleGyroMode();
            });

            toggleBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: false });
        }

        function toggleGyroMode() {
            touchDragEnabled = !touchDragEnabled;
            const toggleBtn = document.getElementById('gyro-toggle-btn');

            if (touchDragEnabled) {
                // Mode tap-and-drag active
                toggleBtn.classList.add('touch-mode');
                // Reinitialiser la reference gyroscope pour quand on reactivera
                resetGyroReference();
                dbg('Mode tactile active');
            } else {
                // Mode gyroscope active
                toggleBtn.classList.remove('touch-mode');
                resetGyroReference();
                dbg('Mode gyroscope active');
            }
        }

        function initTouchDrag() {
            if (!isMobile) return;

            const canvas = document.getElementById('canvas');
            if (!canvas) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let initialYaw = 0;
            let initialPitch = 0;

            document.addEventListener('touchstart', (e) => {
                if (!touchDragEnabled || !fpsMode || isPaused) return;

                // Ignorer si on touche le joystick ou d'autres controles
                if (e.target.closest('#mobile-joystick') ||
                    e.target.closest('#mobile-pause-btn') ||
                    e.target.closest('#gyro-toggle-btn') ||
                    e.target.closest('.pause-controls')) return;

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                initialYaw = cameraYaw;
                initialPitch = cameraPitch;
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!touchDragEnabled || !fpsMode || isPaused) return;
                if (touchStartX === 0 && touchStartY === 0) return;

                // Ignorer si on touche le joystick
                if (e.target.closest('#mobile-joystick')) return;

                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;

                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;

                // Sensibilite du drag
                const sensitivity = 0.005;

                // Appliquer la rotation (signes inverses pour direction naturelle)
                cameraYaw = initialYaw + deltaX * sensitivity;
                cameraPitch = initialPitch + deltaY * sensitivity;

                // Limiter le pitch
                const maxPitch = Math.PI / 2.2;
                cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));
            }, { passive: true });

            document.addEventListener('touchend', () => {
                touchStartX = 0;
                touchStartY = 0;
            }, { passive: true });
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE PAUSE BUTTON
        // ═══════════════════════════════════════════════════════════════
        function initMobilePauseButton() {
            if (!isMobile) return;

            const pauseBtn = document.getElementById('mobile-pause-btn');
            if (!pauseBtn) return;

            pauseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (isPaused) {
                    resumeExperience();
                } else {
                    showPauseScreen();
                }
            });

            // Empêcher les événements tactiles de se propager
            pauseBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: false });
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE INSTRUCTIONS
        // ═══════════════════════════════════════════════════════════════
        function showMobileInstructions() {
            if (!isMobile || mobileInstructionsHidden) return;

            const instructions = document.getElementById('mobile-instructions');
            if (instructions) {
                instructions.classList.remove('hidden');
            }
        }

        function hideMobileInstructions() {
            if (mobileInstructionsHidden) return;

            const instructions = document.getElementById('mobile-instructions');
            if (instructions) {
                instructions.classList.add('hidden');
            }
            mobileInstructionsHidden = true;
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE INITIALIZATION
        // ═══════════════════════════════════════════════════════════════
        function initMobile() {
            if (!isMobile) {
                dbg('💻 Mode desktop détecté');
                return;
            }

            dbg('📱 Mode mobile détecté');

            // Initialiser les contrôles
            initPullToRefresh();
            initJoystick();
            initMobilePauseButton();
            initGyroToggle();
            initTouchDrag();

            // Vérifier si on doit demander la permission gyroscope (iOS)
            if (isIOS && typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // La permission sera demandée au clic sur Play
            } else {
                // Activer directement le gyroscope
                enableGyroscope();
            }

            // Modifier handlePlayClick pour mobile
            const originalHandlePlayClick = window.handlePlayClick;
            window.handlePlayClick = function() {
                // Demander fullscreen
                requestFullscreen();

                // Demander permission gyroscope sur iOS
                if (isIOS && !gyroPermissionGranted &&
                    typeof DeviceOrientationEvent !== 'undefined' &&
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // Afficher le bouton de permission
                    document.getElementById('gyro-permission-btn').style.display = 'block';
                }

                // Appeler la fonction originale
                originalHandlePlayClick();
            };
        }

        // Hook dans startExperience pour afficher les contrôles mobiles
        const originalStartExperience = startExperience;
        startExperience = function() {
            originalStartExperience();

            if (isMobile) {
                // Afficher les contrôles mobiles
                document.getElementById('mobile-pause-btn')?.classList.remove('hidden');
                document.getElementById('mobile-joystick')?.classList.remove('hidden');
                const gyroToggle = document.getElementById('gyro-toggle-btn');
                if (gyroToggle) {
                    gyroToggle.classList.remove('hidden');
                    gyroToggle.style.display = 'flex';
                }

                // Afficher instructions après un délai
                setTimeout(() => {
                    showMobileInstructions();
                }, 2000);

                // Réinitialiser la référence gyroscope
                resetGyroReference();
            }
        };

        // Hook dans la boucle d'animation pour le joystick
        const originalAnimate = typeof animate === 'function' ? animate : null;
        if (originalAnimate) {
            animate = function() {
                applyJoystickMovement();
                originalAnimate();
            };
        }

        // Initialiser au chargement
        document.addEventListener('DOMContentLoaded', initMobile);

        // Empêcher les comportements tactiles indésirables sur l'expérience
        document.addEventListener('touchmove', (e) => {
            // Permettre le scroll sur welcome-screen
            if (e.target.closest('#welcome-screen')) return;

            // Bloquer le scroll ailleurs si l'expérience est active
            if (fpsMode && !isPaused) {
                e.preventDefault();
            }
        }, { passive: false });

        // Empêcher le double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
    </script>
</body>
</html>
