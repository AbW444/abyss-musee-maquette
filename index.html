<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Dumbo</title>

    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="img/presences_rares_favicon_v2.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/presences_rares_favicon_v2.png">
    <link rel="apple-touch-icon" sizes="180x180" href="img/presences_rares_favicon_v2.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet">
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        :root {
            /* ─── Layout Welcome Screen ─── */
            --textLeft: 240px;
            --textColW: 580px;
            --textTop: 150px;
            --logoSize: 104px;
            --playRight: 240px;
            --playBottom: 150px;
            --hoverTextShift: 90px;
            --clickTextExitX: 320px;
            --clickFadeMs: 320ms;
            --logoMoveMs: 420ms;

            /* ─── Colors ─── */
            --color-bg: #000;
            --color-panel: rgba(0,0,0,0.92);
            --color-panel-light: rgba(0,0,0,0.88);
            --color-overlay: rgba(0,0,0,0.80);
            --color-surface: rgba(255,255,255,0.03);
            --color-surface-hover: rgba(255,255,255,0.06);
            --color-surface-active: rgba(255,255,255,0.12);

            --color-border: rgba(255,255,255,0.15);
            --color-border-hover: rgba(255,255,255,0.25);
            --color-border-strong: rgba(255,255,255,0.3);

            --color-text: rgba(255,255,255,0.95);
            --color-text-secondary: rgba(255,255,255,0.7);
            --color-text-dim: rgba(255,255,255,0.45);
            --color-text-hint: rgba(255,255,255,0.3);

            --color-accent: rgba(100,150,255,0.5);
            --color-accent-bg: rgba(100,150,255,0.08);
            --color-accent-hover: rgba(100,150,255,0.2);
            --color-accent-strong: rgba(100,150,255,0.4);

            --color-success: rgba(100,200,100,0.25);
            --color-success-border: rgba(100,200,100,0.4);
            --color-success-hover: rgba(100,200,100,0.35);

            --color-danger: rgba(255,80,80,0.7);
            --color-danger-hover: rgba(255,80,80,1);

            --color-warning: rgba(255,100,0,0.95);
            --color-fps-ok: #00ff88;
            --color-fps-low: #ff6400;
            --color-fps-critical: #ff0000;

            /* ─── Typography ─── */
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'IBM Plex Mono', 'Courier New', monospace;
            --text-xs: 9px;
            --text-sm: 10px;
            --text-md: 11px;
            --text-lg: 13px;
            --text-xl: 14px;
            --text-2xl: 16px;

            /* ─── Spacing ─── */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 24px;
            --space-2xl: 32px;

            /* ─── Border Radius ─── */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
            --radius-2xl: 28px;
            --radius-round: 50%;

            /* ─── Transitions ─── */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.25s ease;

            /* ─── Slider ─── */
            --slider-thumb: 16px;
            --slider-track: 4px;
            --slider-bg: rgba(255,255,255,0.15);
            --slider-thumb-color: #fff;
            --slider-thumb-shadow: 0 2px 4px rgba(0,0,0,0.3);

            /* ─── Z-Index Layers ─── */
            --z-canvas: 1;
            --z-ui: 100;
            --z-indicator: 200;
            --z-fps: 300;
            --z-overlay: 1000;
            --z-pause: 5000;
            --z-pause-controls: 5001;
            --z-welcome: 6000;
            --z-loading: 6001;
            --z-mobile-controls: 7000;
            --z-permission: 8000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* ═══════════════════════════════════════════════════════════════
           GLOBAL MOBILE STYLES - Anti-comportements gênants
           ═══════════════════════════════════════════════════════════════ */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            touch-action: manipulation;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: #fff;
            overflow: hidden;
            /* Anti tap highlight */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            /* Prevent pull-to-refresh native sur body */
            overscroll-behavior: none;
            /* Safe areas iOS */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Désactiver sélection sur éléments interactifs */
        button, .play-button-container, .mute-button, #mobile-pause-btn, #mobile-joystick {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Focus: accessible visible outline */
        button:focus, *:focus {
            outline: none;
        }
        button:focus-visible, *:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
        }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: var(--z-canvas); }
        #canvas canvas { display: block; }

        /* ─── Shared Admin Panel Base ─── */
        #ui, #screen-manager-panel, #fps-settings-panel {
            background: var(--color-panel);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
            font-family: var(--font-sans);
            color: #fff;
            cursor: move;
            user-select: none;
        }
        #ui, #screen-manager-panel, #fps-settings-panel {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        #ui::-webkit-scrollbar, #screen-manager-panel::-webkit-scrollbar, #fps-settings-panel::-webkit-scrollbar {
            width: 6px;
        }
        #ui::-webkit-scrollbar-track, #screen-manager-panel::-webkit-scrollbar-track, #fps-settings-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        #ui::-webkit-scrollbar-thumb, #screen-manager-panel::-webkit-scrollbar-thumb, #fps-settings-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.15);
            border-radius: 3px;
        }
        #ui::-webkit-scrollbar-thumb:hover, #screen-manager-panel::-webkit-scrollbar-thumb:hover, #fps-settings-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.25);
        }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: var(--z-ui);
              padding: var(--space-xl); max-width: 420px; width: 90%;
              transition: transform 0.4s ease, top 0.4s ease, bottom 0.4s ease, max-width 0.4s ease, padding 0.4s ease;
              max-height: 85vh; max-height: 85dvh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 280px; width: auto; padding: var(--space-md);
                     max-height: calc(100vh - 40px); max-height: calc(100dvh - 40px); overflow-y: auto; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: var(--z-ui);
                      text-decoration: none; color: #fff; transition: opacity var(--transition-fast); }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 22px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: var(--text-md); font-weight: 400; opacity: 0.5;
                    margin-top: var(--space-xs); letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: var(--space-sm) 0; padding: var(--space-sm) var(--space-md);
                 background: rgba(255,255,255,0.08); color: #fff;
                 border: 1px solid var(--color-border); border-radius: var(--radius-md);
                 cursor: pointer; font-size: var(--text-sm); font-weight: 600;
                 transition: background var(--transition-fast), transform var(--transition-fast);
                 text-transform: uppercase; letter-spacing: 0.8px; }
        button:hover { background: var(--color-surface-active); }
        button:active { transform: scale(0.97); }

        button.small { padding: var(--space-sm); font-size: var(--text-sm); opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: var(--radius-md); margin: var(--space-sm) 0;
                   display: flex; align-items: center; justify-content: center;
                   background: var(--color-surface); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: var(--text-sm); opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: var(--text-md); font-weight: 600; margin-top: var(--space-lg); display: block;
                text-transform: uppercase; letter-spacing: 0.8px; color: var(--color-text-secondary); }

        .hidden { display: none !important; }

        #controls { margin-top: var(--space-lg); padding-top: var(--space-lg);
                    border-top: 1px solid var(--color-border); }

        /* ─── Unified Slider Style ─── */
        .slider, .volume-slider, .fps-param input[type="range"] {
            width: 100%; height: var(--slider-track); border-radius: 2px;
            background: var(--slider-bg); outline: none;
            -webkit-appearance: none; appearance: none; margin: var(--space-sm) 0;
        }
        .slider::-webkit-slider-thumb, .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: var(--slider-thumb); height: var(--slider-thumb); border-radius: var(--radius-round);
            background: var(--slider-thumb-color); cursor: pointer;
            box-shadow: var(--slider-thumb-shadow);
        }
        .slider::-moz-range-thumb, .volume-slider::-moz-range-thumb {
            width: var(--slider-thumb); height: var(--slider-thumb); border-radius: var(--radius-round);
            background: var(--slider-thumb-color); cursor: pointer; border: none;
            box-shadow: var(--slider-thumb-shadow);
        }
        /* FPS panel sliders: green accent distinctif */
        .fps-param input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: var(--slider-thumb); height: var(--slider-thumb); border-radius: var(--radius-round);
            background: var(--color-fps-ok); cursor: pointer;
        }
        .fps-param input[type="range"]::-moz-range-thumb {
            width: var(--slider-thumb); height: var(--slider-thumb); border-radius: var(--radius-round);
            background: var(--color-fps-ok); cursor: pointer; border: none;
        }

        .value { font-family: var(--font-mono); font-weight: 700; font-size: var(--text-md);
                 cursor: pointer; padding: 2px 6px; border-radius: var(--radius-sm);
                 transition: background var(--transition-fast); }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: var(--font-mono); font-weight: 700; font-size: var(--text-md);
                       background: rgba(255,255,255,0.15); border: 1px solid var(--color-border-strong);
                       color: #fff; padding: 2px 6px; border-radius: var(--radius-sm); width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: var(--space-md); }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: var(--space-xs); }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: var(--space-xs); align-items: center; }

        .arrow-btn { width: 22px; height: 22px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.08); border: 1px solid var(--color-border);
                     border-radius: var(--radius-sm); color: #fff; font-size: var(--text-xs); cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: background var(--transition-fast), transform var(--transition-fast); line-height: 1; }
        .arrow-btn:hover { background: var(--color-surface-active); }
        .arrow-btn:active { background: rgba(255,255,255,0.2); transform: scale(0.92); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: var(--text-xs); color: var(--color-text-dim); margin-top: var(--space-sm); text-align: center;
                font-style: italic; }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: var(--z-ui);
                          display: flex; gap: var(--space-sm); background: var(--color-panel-light);
                          padding: var(--space-sm); border-radius: var(--radius-lg);
                          border: 1px solid var(--color-border); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.06);
                     border: 1px solid var(--color-border); border-radius: var(--radius-md);
                     color: #fff; font-size: 20px; cursor: pointer;
                     transition: background var(--transition-fast), transform var(--transition-fast), border-color var(--transition-fast);
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: var(--color-surface-active); }
        .shape-btn.active { background: rgba(255,255,255,0.2);
                            border-color: var(--color-accent); }

        #mode-3d-btn { width: auto; padding: 0 var(--space-md); font-size: var(--text-sm); margin-left: var(--space-sm);
                       border-left: 1px solid var(--color-border-strong); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: var(--z-ui);
                           background: var(--color-panel-light);
                           padding: var(--space-sm) var(--space-md); border-radius: var(--radius-md);
                           border: 1px solid var(--color-border);
                           font-size: var(--text-sm); cursor: pointer; transition: background var(--transition-fast); }
        #version-selector:hover { background: rgba(255,255,255,0.06); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: var(--z-ui);
                       background: var(--color-panel);
                       padding: var(--space-sm); border-radius: var(--radius-md);
                       border: 1px solid var(--color-border);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: var(--space-sm) var(--space-md); cursor: pointer; font-size: var(--text-sm);
                       border-radius: var(--radius-sm); margin: 2px 0; transition: background var(--transition-fast);
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.08); }
        .version-item.current { background: var(--color-surface-active); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: var(--space-md); }
        .video-control-btn { padding: var(--space-sm) var(--space-md); font-size: var(--text-sm); margin: 0; width: 100%; }

        .video-timeline { margin-top: var(--space-sm); }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: var(--space-sm);
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: var(--color-accent);
            border-radius: 3px;
            transition: background var(--transition-fast);
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(100,150,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: var(--radius-round);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: var(--text-xs);
            color: var(--color-text-dim);
            text-align: center;
            font-family: var(--font-mono);
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }

        /* Screen Management UI */
        #screen-manager-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: var(--z-ui);
            padding: var(--space-lg);
            max-width: 300px;
            width: 300px;
            max-height: calc(100vh - 40px);
            max-height: calc(100dvh - 40px);
            overflow-y: auto;
        }
        #screen-manager-panel.hidden { display: none; }
        #screen-manager-panel h2 {
            font-size: var(--text-md);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-md);
            font-weight: 600;
        }
        .screen-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: var(--space-md);
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.15) transparent;
        }
        .screen-list::-webkit-scrollbar {
            width: 4px;
        }
        .screen-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
        }
        .screen-item {
            background: var(--color-surface);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: var(--radius-md);
            padding: var(--space-sm);
            margin-bottom: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            transition: background var(--transition-fast), border-color var(--transition-fast);
            cursor: pointer;
        }
        .screen-item:hover {
            background: var(--color-surface-hover);
            border-color: var(--color-border);
        }
        .screen-item.selected {
            border-color: var(--color-accent);
            background: var(--color-accent-bg);
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-header .screen-num {
            font-weight: 600;
            font-size: var(--text-md);
            color: var(--color-text);
        }
        .screen-header .screen-delete {
            background: transparent;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            transition: color var(--transition-fast), transform var(--transition-fast);
            color: var(--color-danger);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .screen-header .screen-delete:hover {
            color: var(--color-danger-hover);
            transform: scale(1.15);
        }
        .screen-type-selector {
            display: none; /* Retrait transformation forme→écran */
        }
        .screen-type-btn {
            flex: 1;
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            font-size: var(--text-xs);
            cursor: pointer;
            transition: background var(--transition-fast), border-color var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .screen-type-btn.active {
            background: var(--color-accent-hover);
            border-color: var(--color-accent);
            color: var(--color-text);
        }
        .screen-type-btn:hover {
            background: rgba(255,255,255,0.08);
        }
        .color-section {
            margin-top: var(--space-sm);
        }
        .color-section h4 {
            font-size: var(--text-xs);
            text-transform: uppercase;
            color: var(--color-text-dim);
            margin-bottom: var(--space-sm);
            letter-spacing: 0.5px;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-sm);
        }
        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: var(--radius-md);
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.08);
            transition: transform var(--transition-fast), border-color var(--transition-fast);
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.08);
            border-color: var(--color-border-hover);
        }
        .color-option.active {
            border-color: var(--color-accent);
            transform: scale(1.08);
        }
        .color-custom {
            margin-top: var(--space-md);
            display: flex;
            gap: var(--space-sm);
            align-items: center;
        }
        .color-custom input[type="color"] {
            width: 44px;
            height: 32px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            cursor: pointer;
        }
        .color-custom input[type="text"] {
            flex: 1;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-sm);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            color: #fff;
            font-size: var(--text-sm);
            font-family: var(--font-mono);
        }
        .add-screen-btn {
            background: var(--color-success);
            border: 1px solid var(--color-success-border);
            margin-top: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            width: 100%;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: background var(--transition-fast), border-color var(--transition-fast);
        }
        .add-screen-btn:hover {
            background: var(--color-success-hover);
            border-color: rgba(100,200,100,0.6);
        }
        .screen-manager-hint {
            display: none; /* Retrait hints texte */
        }

        /* Cacher titre et version selector */
        #title-link, #version-selector, #version-menu {
            display: none !important;
        }

        /* FPS Settings Panel */
        #fps-settings-panel {
            position: fixed;
            bottom: 20px;
            right: 360px;
            z-index: var(--z-ui);
            padding: var(--space-lg);
            max-width: 320px;
            width: 320px;
            font-size: var(--text-md);
        }
        #fps-settings-panel.hidden { display: none !important; }
        #fps-settings-panel h3 {
            margin: 0 0 var(--space-md) 0;
            font-size: var(--text-md);
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding-right: 25px;
        }
        .fps-param {
            margin-bottom: var(--space-sm);
        }
        .fps-param label {
            display: block;
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            margin-bottom: var(--space-xs);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .fps-param-value {
            display: inline-block;
            float: right;
            color: var(--color-fps-ok);
            font-family: var(--font-mono);
            font-weight: 600;
            font-size: var(--text-sm);
        }
        #fps-export-btn {
            margin-top: var(--space-md);
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: var(--radius-md);
            color: var(--color-fps-ok);
            font-size: var(--text-sm);
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #fps-export-btn:hover {
            background: rgba(0,255,136,0.2);
        }

        /* Video Paused Indicator */
        #video-paused-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-indicator);
            background: var(--color-warning);
            padding: var(--space-md) var(--space-xl);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 150, 0, 0.8);
            font-size: var(--text-lg);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity var(--transition-normal);
            pointer-events: none;
        }
        #video-paused-indicator.visible {
            opacity: 1;
        }

        /* Welcome Screen - Page d'accueil */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #000;
            z-index: var(--z-welcome);
            transition: opacity 0.6s ease;
            overflow: hidden;
        }
        #welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #welcome-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 40%, rgba(0,0,0,0) 60%, transparent 100%);
            z-index: 1;
            pointer-events: none;
        }
        #welcome-video-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #welcome-video-bg.loaded {
            opacity: 1;
        }
        #welcome-fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        body.clickedPlay #welcome-fade-overlay {
            opacity: 1;
        }
        .welcome-content {
            position: absolute;
            left: var(--textLeft);
            top: 50%;
            transform: translateY(-50%);
            width: var(--textColW);
            max-width: 580px; /* ~60-65 caractères par ligne */
            max-height: calc(100vh - 120px);
            max-height: calc(100dvh - 120px);
            overflow-y: auto;
            scrollbar-width: none;
            z-index: 2;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity var(--clickFadeMs) ease;
        }
        .welcome-content::-webkit-scrollbar {
            display: none;
        }
        body.hoverPlay .welcome-content {
            transform: translateY(-50%) translateX(var(--hoverTextShift));
        }
        body.clickedPlay .welcome-content {
            opacity: 0;
            transform: translateY(-50%) translateX(var(--clickTextExitX));
        }
        .welcome-project-name {
            font-family: var(--font-sans);
            font-size: 64px;
            font-weight: 700;
            letter-spacing: 8px;
            margin-bottom: 2px;
            color: var(--color-text);
            line-height: 1.1;
            text-transform: uppercase;
            display: block;
        }
        .welcome-title {
            font-family: var(--font-sans);
            font-size: 22px;
            font-weight: 500;
            letter-spacing: 1.5px;
            margin-bottom: 28px;
            color: var(--color-text);
            line-height: 1.4;
            text-transform: uppercase;
        }
        .welcome-subtitle-inline {
            font-size: var(--text-lg);
            font-weight: 300;
            letter-spacing: 1px;
            color: var(--color-text-dim);
            text-transform: none;
        }
        .welcome-text, .welcome-manifesto {
            font-family: var(--font-sans);
            font-size: 15px;
            font-weight: 300;
            color: var(--color-text-secondary);
            line-height: 1.9;
            margin-bottom: 20px;
            letter-spacing: 0.3px;
            text-align: justify;
        }
        .welcome-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        .welcome-context {
            font-family: var(--font-mono);
            font-size: 12px;
            font-weight: 300;
            color: var(--color-text-dim);
            line-height: 1.7;
            margin-top: 50px;
            padding-top: 25px;
            border-top: 1px solid var(--color-border);
            letter-spacing: 0.3px;
        }
        .play-button-container {
            position: absolute;
            bottom: var(--playBottom);
            right: var(--playRight);
            cursor: pointer;
            z-index: 3;
            width: 208px;
            height: 209px;
            transition: opacity var(--clickFadeMs) ease;
        }
        body.clickedPlay .play-button-container {
            opacity: 0;
        }
        /* Desktop play visible, mobile play cache par defaut */
        .play-button-container.mobile-play {
            display: none;
        }
        .play-button-container.desktop-play {
            display: block;
        }
        .play-button-container .play-rond,
        .play-button-container .play-fleche {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .play-button-container .play-rond {
            width: 208px;
            height: 209px;
            animation: playRondRotate 6s linear infinite;
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-rond {
            transform: scale(1.05);
        }
        @keyframes playRondRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        body.hoverPlay .play-button-container .play-rond {
            animation: playRondRotateHover 6s linear infinite;
        }
        @keyframes playRondRotateHover {
            from { transform: rotate(0deg) scale(1.05); }
            to { transform: rotate(360deg) scale(1.05); }
        }
        .play-button-container .play-fleche {
            width: 80px;
            height: 105px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) translateX(4px);
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-fleche {
            transform: translate(-50%, -50%) translateX(4px) scale(1.08);
        }

        /* Logo container - PNG et WEBM */
        .welcome-logo-container {
            position: absolute;
            left: calc(var(--textLeft) / 2 - var(--logoSize) / 2);
            top: calc(50% - var(--logoSize) / 2);
            width: var(--logoSize);
            height: var(--logoSize);
            z-index: 10;
            /* Transitions explicites (pas 'all') pour éviter rasterisation GPU basse-res */
            transition: left var(--logoMoveMs) cubic-bezier(0.4, 0, 0.2, 1),
                        top var(--logoMoveMs) cubic-bezier(0.4, 0, 0.2, 1),
                        opacity var(--logoMoveMs) ease;
        }

        /* Recentrage du logo lors du hover */
        body.hoverPlay .welcome-logo-container {
            left: calc((var(--textLeft) + var(--hoverTextShift)) / 2 - var(--logoSize) / 2);
        }

        /* Centrage final lors du click */
        body.clickedPlay .welcome-logo-container {
            left: calc(50vw - var(--logoSize) / 2);
            top: calc(50vh - var(--logoSize) / 2);
            top: calc(50dvh - var(--logoSize) / 2);
        }

        .welcome-logo,
        .welcome-logo-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Pas de will-change ici: évite rasterisation GPU basse résolution sur desktop */
        }

        .welcome-logo {
            transition: opacity 0.2s ease;
        }

        .welcome-logo-video {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .welcome-logo-video.active {
            opacity: 1;
        }

        /* Pause Screen - Ultra Modern */
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: transparent;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 0;
            box-sizing: border-box;
            z-index: var(--z-pause);
            cursor: pointer;
            transition: opacity 0.4s ease;
        }
        #pause-screen.active {
            display: flex;
        }
        .pause-content {
            max-width: 680px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            background: var(--color-overlay);
            border: none;
            border-radius: var(--radius-2xl);
            padding: 36px 50px;
            text-align: left;
            box-shadow: none;
            pointer-events: all;
            cursor: default;
        }
        .pause-content::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        .pause-title {
            font-family: var(--font-sans);
            font-size: 19px;
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 18px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            line-height: 1.4;
        }
        .pause-text {
            font-family: var(--font-sans);
            font-size: 13.5px;
            font-weight: 300;
            color: var(--color-text-secondary);
            line-height: 1.75;
            margin-bottom: 14px;
            letter-spacing: 0.3px;
            text-align: justify;
        }
        .pause-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        /* Liste conceptuelle - sans décoration */
        .pause-conceptual-list {
            font-family: var(--font-sans);
            font-size: 13.5px;
            font-weight: 300;
            color: var(--color-text-secondary);
            line-height: 1.9;
            margin: 14px 0;
            letter-spacing: 0.3px;
        }
        .pause-conceptual-list .list-intro {
            display: block;
            margin-bottom: 8px;
            line-height: 1.75;
        }
        .pause-conceptual-list .list-item {
            display: block;
            color: rgba(255,255,255,0.80);
        }
        .pause-meta {
            font-family: var(--font-mono);
            font-size: 11px;
            font-weight: 300;
            color: var(--color-text-dim);
            line-height: 1.6;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--color-border);
            letter-spacing: 0.3px;
        }
        .pause-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-lg);
            z-index: var(--z-pause-controls);
        }
        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            height: auto;
            justify-content: center;
            position: relative;
        }
        .volume-slider-container {
            height: 0;
            overflow: hidden;
            opacity: 0;
            transition: height 0.3s ease, opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .volume-control.active .volume-slider-container {
            height: 130px;
            opacity: 1;
        }
        .volume-label {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .volume-slider {
            width: 120px;
            transform: rotate(-90deg);
            transform-origin: center;
        }
        /* ─── Circle Buttons (mute, close, mobile) ─── */
        .mute-button, .pause-close-btn {
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--color-border);
            color: #fff;
            padding: 0;
            width: 48px;
            height: 48px;
            border-radius: var(--radius-round);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background var(--transition-fast), transform var(--transition-fast), border-color var(--transition-fast);
        }
        .mute-button:hover, .pause-close-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: scale(1.05);
        }
        .mute-button:active, .pause-close-btn:active {
            background: var(--color-accent-strong);
            transform: scale(0.93);
        }
        .mute-button.muted {
            border-color: var(--color-danger);
        }
        .pause-credits {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--text-md);
            color: var(--color-text-hint);
            font-style: italic;
        }

        /* Pause close button positioning */
        .pause-close-btn {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: var(--z-pause-controls);
        }

        /* Persistent Instructions (ALT + ESC — always visible in FPS mode) */
        .persistent-instructions {
            position: fixed;
            top: 12px;
            left: 12px;
            padding: 9px 11px;
            font-size: 11.3px;
            color: var(--color-text);
            z-index: var(--z-ui);
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.3px;
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        /* Game & Pause Instructions (shared base) */
        .game-instructions, .pause-instructions {
            position: fixed;
            left: 12px;
            padding: 9px 11px;
            font-size: 11.3px;
            color: var(--color-text);
            z-index: var(--z-ui);
            opacity: 1;
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.3px;
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }
        .game-instructions {
            top: 60px; /* Below persistent-instructions */
        }
        .pause-instructions {
            top: 12px;
            z-index: var(--z-pause-controls);
        }
        .game-instructions .instruction-row {
            transition: opacity 0.6s ease;
        }
        .instruction-row {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: var(--space-sm);
            line-height: 1.25;
        }
        .keys-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        .persistent-instructions .key, .game-instructions .key, .pause-instructions .key {
            display: inline-block;
            background: var(--color-accent-hover);
            padding: 5px 7px;
            border-radius: var(--radius-md);
            border: none;
            font-family: var(--font-mono);
            font-size: var(--text-sm);
            color: #fff;
            font-weight: 600;
            white-space: nowrap;
        }
        .arrows-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, auto);
            grid-template-rows: repeat(2, auto);
            gap: 2px;
        }
        .arrows-grid .key {
            padding: 3px 5px;
            font-size: 9px;
            line-height: 1;
        }
        .arrows-grid .key:nth-child(1) { grid-column: 2; grid-row: 1; }
        .arrows-grid .key:nth-child(2) { grid-column: 1; grid-row: 2; }
        .arrows-grid .key:nth-child(3) { grid-column: 2; grid-row: 2; }
        .arrows-grid .key:nth-child(4) { grid-column: 3; grid-row: 2; }
        .or-text {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            font-style: italic;
        }

        /* Initial Page Loader */
        #initial-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: var(--color-bg);
            z-index: var(--z-loading);
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #initial-loader.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: var(--color-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: var(--z-loading);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #loading-screen.active {
            display: flex;
            opacity: 1;
        }

        #loading-screen.hidden {
            opacity: 0;
        }

        /* Fade-from-black overlay: sits behind loading screen, reveals 3D scene smoothly */
        #scene-reveal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: var(--color-bg);
            z-index: calc(var(--z-loading) - 1);
            opacity: 1;
            pointer-events: none;
            display: none;
            transition: opacity 1.2s ease;
        }

        #scene-reveal-overlay.active {
            display: block;
            opacity: 1;
        }

        #scene-reveal-overlay.revealed {
            opacity: 0;
        }

        .loading-video {
            width: var(--logoSize);
            height: var(--logoSize);
            opacity: 1;
            object-fit: contain;
            will-change: transform;
            transform: translateZ(0);
        }

        /* Panel Close Button (X) */
        .panel-close-btn {
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            width: 22px;
            height: 22px;
            background: transparent;
            border: none;
            color: var(--color-text-dim);
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color var(--transition-fast), transform var(--transition-fast);
            z-index: 10;
        }
        .panel-close-btn:hover {
            color: var(--color-text);
            transform: scale(1.15);
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: var(--z-fps);
            background: var(--color-panel-light);
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(0, 255, 136, 0.2);
            font-family: var(--font-mono);
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-fps-ok);
            min-width: 90px;
            text-align: center;
        }
        #fps-counter .fps-value {
            font-size: 26px;
            font-weight: 700;
            display: block;
            line-height: 1;
            margin-bottom: var(--space-xs);
        }
        #fps-counter .fps-label {
            font-size: var(--text-sm);
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        #fps-counter.low-fps {
            border-color: rgba(255, 100, 0, 0.4);
            color: var(--color-fps-low);
        }
        #fps-counter.critical-fps {
            border-color: rgba(255, 0, 0, 0.4);
            color: var(--color-fps-critical);
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE UI COMPONENTS
           ═══════════════════════════════════════════════════════════════ */

        /* Pull-to-refresh indicator */
        #pull-to-refresh {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            z-index: var(--z-mobile-controls);
            background: rgba(0,0,0,0.7);
            padding: var(--space-md) var(--space-xl);
            border-radius: 0 0 var(--radius-xl) var(--radius-xl);
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            transition: transform 0.3s ease;
            display: none;
        }
        #pull-to-refresh.visible {
            display: block;
        }
        #pull-to-refresh.pulling {
            transform: translateX(-50%) translateY(0);
        }
        #pull-to-refresh .ptr-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        #pull-to-refresh.loading .ptr-spinner {
            animation: ptr-spin 0.8s linear infinite;
        }
        @keyframes ptr-spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Pause Button */
        #mobile-pause-btn {
            display: none;
            position: fixed;
            top: calc(10px + env(safe-area-inset-top));
            left: calc(20px + env(safe-area-inset-left));
            z-index: var(--z-mobile-controls);
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-round);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        #mobile-pause-btn .btn-icon-info,
        #mobile-pause-btn .btn-icon-close {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #mobile-pause-btn .btn-icon-info {
            font-family: 'Georgia', 'Times New Roman', serif;
            font-style: italic;
            font-size: 22px;
            font-weight: 700;
            color: #fff;
            line-height: 1;
            opacity: 1;
            text-transform: lowercase;
        }
        #mobile-pause-btn .btn-icon-close {
            opacity: 0;
            transform: translate(-50%, -50%) rotate(-90deg);
        }
        #mobile-pause-btn.active-infos .btn-icon-info {
            opacity: 0;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        #mobile-pause-btn.active-infos .btn-icon-close {
            opacity: 1;
            transform: translate(-50%, -50%) rotate(0deg);
        }
        #mobile-pause-btn:active {
            background: rgba(255,255,255,0.15);
            transform: scale(0.93);
        }

        /* Mobile Fullscreen Button */
        #mobile-fullscreen-btn {
            display: none;
            position: fixed;
            top: calc(10px + env(safe-area-inset-top));
            right: calc(20px + env(safe-area-inset-right));
            z-index: var(--z-mobile-controls);
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-round);
            color: #fff;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        #mobile-fullscreen-btn:active {
            background: rgba(255,255,255,0.15);
            transform: scale(0.93);
        }

        /* Mobile Joystick */
        #mobile-joystick {
            display: none;
            position: fixed;
            bottom: calc(50px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-mobile-controls);
            width: 120px;
            height: 120px;
            touch-action: none;
        }
        #mobile-joystick .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.06);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-round);
        }
        #mobile-joystick .joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.2);
            border: 1px solid var(--color-border-strong);
            border-radius: var(--radius-round);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.15s;
        }
        #mobile-joystick.active .joystick-thumb {
            background: rgba(255,255,255,0.4);
        }

        /* Bouton Gyroscope (bas gauche) */
        #gyro-toggle-btn {
            display: none;
            position: fixed;
            bottom: calc(50px + env(safe-area-inset-bottom));
            left: calc(20px + env(safe-area-inset-left));
            z-index: var(--z-mobile-controls);
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-round);
            color: #fff;
            cursor: pointer;
            padding: 0;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
        }
        #gyro-toggle-btn:active {
            transform: scale(0.93);
        }

        /* Bouton Manuel (bas droite) */
        #manual-toggle-btn {
            display: none;
            position: fixed;
            bottom: calc(50px + env(safe-area-inset-bottom));
            right: calc(20px + env(safe-area-inset-right));
            z-index: var(--z-mobile-controls);
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-round);
            color: #fff;
            cursor: pointer;
            padding: 0;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
        }
        #manual-toggle-btn:active {
            transform: scale(0.93);
        }

        /* Mode actif = sélection bleue */
        #gyro-toggle-btn.mode-active,
        #manual-toggle-btn.mode-active {
            border-color: rgba(100,150,255,0.6);
            background: rgba(100,150,255,0.18);
        }

        /* Mobile Instructions */
        #mobile-instructions {
            display: none;
            position: fixed;
            top: calc(65px + env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            background: rgba(0,0,0,0.85);
            padding: var(--space-lg);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255,255,255,0.08);
            text-align: left;
            font-size: 12px;
            color: rgba(255,255,255,0.85);
            max-width: 220px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #mobile-instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #mobile-instructions .instruction-line {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        #mobile-instructions .instruction-line:last-child {
            margin-bottom: 0;
        }
        #mobile-instructions .instruction-line.secondary {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
        }
        #mobile-instructions .instruction-svg {
            opacity: 0.7;
            flex-shrink: 0;
        }

        /* Gyroscope permission button */
        #gyro-permission-btn {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: var(--z-permission);
            background: var(--color-panel);
            padding: var(--space-2xl) 40px;
            border-radius: var(--radius-xl);
            border: 1px solid var(--color-border);
            text-align: center;
        }
        #gyro-permission-btn h3 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #fff;
        }
        #gyro-permission-btn p {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #gyro-permission-btn button {
            padding: 14px 32px;
            font-size: 14px;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            width: auto;
            margin: 0;
        }
        #gyro-permission-btn button:active {
            background: rgba(255,255,255,0.25);
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE RESPONSIVE STYLES
           ═══════════════════════════════════════════════════════════════ */
        @media (max-width: 768px), (pointer: coarse) {
            /* Variables mobiles */
            :root {
                --textLeft: clamp(20px, 5vw, 40px);
                --textColW: calc(100vw - clamp(40px, 10vw, 80px));
                --playRight: clamp(30px, 8vw, 60px);
                --playBottom: clamp(80px, 15vh, 120px);
                --logoSize: clamp(45px, 12vw, 55px); /* 1.5x plus petit */
                --hoverTextShift: 0px;
                --clickTextExitX: 100px;
            }

            /* Welcome screen mobile - pas de scroll global, vidéo couvre tout */
            #welcome-screen {
                height: 100dvh;
                height: -webkit-fill-available;
                overflow: hidden;
            }

            /* Logo mobile: centré dans la zone entre le haut et le bloc texte */
            .welcome-logo-container {
                left: calc(50% - var(--logoSize) / 2) !important;
                top: calc(30px + env(safe-area-inset-top)) !important;
            }
            body.hoverPlay .welcome-logo-container {
                left: calc(50% - var(--logoSize) / 2) !important;
            }
            body.clickedPlay .welcome-logo-container {
                left: calc(50vw - var(--logoSize) / 2) !important;
                top: calc(50vh - var(--logoSize) / 2) !important;
                top: calc(50dvh - var(--logoSize) / 2) !important;
            }

            /* Texte mobile: glassmorphisme style pause-content, scroll interne */
            .welcome-content {
                left: 50% !important;
                top: calc(60px + env(safe-area-inset-top) + var(--logoSize)) !important;
                transform: translateX(-50%) !important;
                width: calc(100vw - 40px) !important;
                max-width: 500px !important;
                max-height: calc(100dvh - 70px - env(safe-area-inset-top) - var(--logoSize)) !important;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                padding: 22px 20px;
                text-align: left;
                background: rgba(0,0,0,0.80);
                border-radius: 28px;
            }
            .welcome-content::-webkit-scrollbar {
                display: none;
            }
            body.hoverPlay .welcome-content {
                transform: translateX(-50%) !important;
            }
            body.clickedPlay .welcome-content {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) !important;
            }

            /* Textes plus petits */
            .welcome-project-name {
                font-size: clamp(28px, 8vw, 42px);
                letter-spacing: 4px;
            }
            .welcome-title {
                font-size: clamp(14px, 4vw, 18px);
                margin-bottom: 24px;
            }
            .welcome-subtitle-inline {
                font-size: clamp(10px, 3vw, 12px);
            }
            .welcome-manifesto {
                font-size: clamp(12px, 3vw, 14px);
                line-height: 1.7;
                margin-bottom: 16px;
                text-align: left;
            }
            .welcome-text {
                font-size: clamp(12px, 3vw, 14px);
                line-height: 1.7;
                margin-bottom: 16px;
                text-align: left;
            }
            .welcome-context {
                font-size: clamp(10px, 2.5vw, 12px);
                margin-top: 30px;
                padding-top: 20px;
            }

            /* Boutons play: mobile visible, desktop cache */
            .play-button-container.mobile-play {
                display: block !important;
                position: relative !important;
                bottom: auto !important;
                right: auto !important;
                margin: 40px auto 40px auto;
                width: clamp(90px, 22vw, 120px);
                height: clamp(90px, 22vw, 120px);
            }
            .play-button-container.desktop-play {
                display: none !important;
            }
            .play-button-container .play-rond {
                width: 100%;
                height: 100%;
            }
            .play-button-container .play-fleche {
                width: 40%;
                height: 50%;
            }

            /* Gradient adapté mobile */
            #welcome-screen::before {
                background: linear-gradient(to bottom,
                    rgba(0,0,0,0.9) 0%,
                    rgba(0,0,0,0.7) 20%,
                    rgba(0,0,0,0.4) 50%,
                    rgba(0,0,0,0.7) 80%,
                    rgba(0,0,0,0.95) 100%
                );
            }

            /* Afficher UI mobile */
            #mobile-pause-btn {
                display: flex;
            }
            #mobile-fullscreen-btn {
                display: flex;
            }
            #mobile-joystick {
                display: block;
            }
            #mobile-instructions {
                display: block;
            }
            #manual-toggle-btn {
                display: flex;
            }

            /* Cacher UI desktop */
            .persistent-instructions,
            .game-instructions,
            .pause-instructions {
                display: none !important;
            }

            /* Pause screen mobile - centré verticalement */
            #pause-screen {
                justify-content: center;
                padding-top: 0;
            }
            .pause-content {
                max-width: 85vw;
                width: auto;
                padding: 22px 20px;
                margin: 15px;
                max-height: calc(100dvh - 140px);
                overflow-y: auto;
                font-size: 13px;
            }
            .pause-title {
                font-size: clamp(15px, 4vw, 18px);
                margin-bottom: 18px;
            }
            .pause-text {
                font-size: clamp(11px, 3vw, 13px);
                line-height: 1.6;
                margin-bottom: 14px;
            }
            .pause-conceptual-list {
                font-size: clamp(11px, 3vw, 13px);
                line-height: 1.8;
            }
            .pause-conceptual-list .list-intro {
                margin-bottom: 8px;
            }
            .pause-meta {
                font-size: clamp(8px, 2.5vw, 10px);
                margin-top: 20px;
                padding-top: 15px;
            }
            .pause-controls {
                bottom: calc(60px + env(safe-area-inset-bottom));
                right: calc(15px + env(safe-area-inset-right));
            }
            /* Cacher le volume et le bouton fermer sur mobile */
            .volume-control {
                display: none !important;
            }
            .pause-close-btn {
                display: none !important;
            }

            /* FPS counter plus discret sur mobile */
            #fps-counter {
                display: none;
            }

            /* Admin panels cachés sur mobile */
            #screen-manager-panel,
            #fps-settings-panel,
            #shape-selector,
            #version-selector,
            #ui {
                display: none !important;
            }
        }

        /* Très petits écrans */
        @media (max-width: 375px) {
            .welcome-content {
                padding-bottom: 0;
            }
            .play-button-container {
                width: 90px;
                height: 90px;
            }
            #mobile-joystick {
                width: 100px;
                height: 100px;
            }
            #mobile-joystick .joystick-thumb {
                width: 40px;
                height: 40px;
            }
        }

        /* Paysage mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .welcome-logo-container {
                top: calc(20px + env(safe-area-inset-top)) !important;
                left: calc(60px + env(safe-area-inset-left)) !important;
                transform: translate(0, 0) !important;
            }
            .welcome-content {
                top: calc(20px + env(safe-area-inset-top)) !important;
                left: calc(150px + env(safe-area-inset-left)) !important;
                width: calc(60vw - 150px) !important;
                padding-bottom: 20px;
            }
            .play-button-container {
                right: calc(40px + env(safe-area-inset-right)) !important;
                bottom: 50% !important;
                transform: translateY(50%);
            }
            #mobile-joystick {
                left: calc(80px + env(safe-area-inset-left));
                transform: none;
                bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Initial black loader - visible immediately, removed when page is ready -->
    <div id="initial-loader"></div>

    <!-- ═══════════════════════════════════════════════════════════════
         MOBILE UI COMPONENTS
         ═══════════════════════════════════════════════════════════════ -->

    <!-- Pull-to-refresh indicator (welcome screen only) -->
    <div id="pull-to-refresh">
        <span class="ptr-spinner"></span>
        <span class="ptr-text">Relâchez pour actualiser</span>
    </div>

    <!-- Mobile Info Button (ouvre le mode ESC/Infos) -->
    <button id="mobile-pause-btn" class="hidden" aria-label="Infos">
        <span class="btn-icon-info">i</span>
        <svg class="btn-icon-close" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
    </button>

    <!-- Mobile Fullscreen Button -->
    <button id="mobile-fullscreen-btn" class="hidden" aria-label="Plein écran">
        <svg class="fs-enter-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M8 3H5a2 2 0 0 0-2 2v3"></path>
            <path d="M21 8V5a2 2 0 0 0-2-2h-3"></path>
            <path d="M3 16v3a2 2 0 0 0 2 2h3"></path>
            <path d="M16 21h3a2 2 0 0 0 2-2v-3"></path>
        </svg>
        <svg class="fs-exit-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
            <path d="M8 3v3a2 2 0 0 1-2 2H3"></path>
            <path d="M21 8h-3a2 2 0 0 1-2-2V3"></path>
            <path d="M3 16h3a2 2 0 0 1 2 2v3"></path>
            <path d="M16 21v-3a2 2 0 0 1 2-2h3"></path>
        </svg>
    </button>

    <!-- Mobile Joystick -->
    <div id="mobile-joystick" class="hidden">
        <div class="joystick-base"></div>
        <div class="joystick-thumb"></div>
    </div>

    <!-- Bouton Gyroscope (bas gauche) -->
    <button id="gyro-toggle-btn" class="hidden" aria-label="Mode Gyroscope">
        <svg class="gyro-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
            <line x1="12" y1="2" x2="12" y2="6"></line>
            <line x1="12" y1="18" x2="12" y2="22"></line>
            <line x1="2" y1="12" x2="6" y2="12"></line>
            <line x1="18" y1="12" x2="22" y2="12"></line>
        </svg>
    </button>

    <!-- Bouton Manuel (bas droite) -->
    <button id="manual-toggle-btn" class="hidden" aria-label="Mode Manuel">
        <svg class="touch-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v5"></path>
            <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v6"></path>
            <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"></path>
            <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"></path>
        </svg>
    </button>

    <!-- Mobile Instructions -->
    <div id="mobile-instructions" class="hidden">
        <div class="instruction-line">
            <svg class="instruction-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="3"></circle>
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
            </svg>
            <span>Inclinez pour regarder</span>
        </div>
        <div class="instruction-line">
            <svg class="instruction-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v5"></path>
                <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v6"></path>
                <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"></path>
                <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"></path>
            </svg>
            <span>Toucher pour orienté</span>
        </div>
        <div class="instruction-line secondary">
            <svg class="instruction-svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="4"></circle>
            </svg>
            <span>Joystick pour se déplacer</span>
        </div>
    </div>

    <!-- Gyroscope Permission Request (iOS) -->
    <div id="gyro-permission-btn">
        <h3>Activer le mouvement</h3>
        <p>Pour une expérience immersive, autorisez l'accès aux capteurs de mouvement.</p>
        <button onclick="requestGyroPermission()">Activer</button>
    </div>

    <!-- Persistent Instructions (ALT + ESC — always visible in FPS mode) -->
    <div class="persistent-instructions" id="persistent-instructions" style="display:none;">
        <div class="instruction-row">
            <span class="key">ALT</span>
            <span>Infos</span>
        </div>
        <div class="instruction-row">
            <span class="key">ESC</span>
            <span>Plein écran</span>
        </div>
    </div>

    <!-- Game Instructions (top-left, visible when on floor Y=11, hides after movement) -->
    <div class="game-instructions hidden" id="game-instructions">
        <div class="instruction-row">
            <span class="key">Souris</span>
            <span>Regarder autour</span>
        </div>
        <div class="instruction-row">
            <div class="keys-group">
                <span class="key">ZQSD</span>
                <span class="or-text">ou</span>
                <div class="arrows-grid">
                    <span class="key">↑</span>
                    <span class="key">←</span>
                    <span class="key">↓</span>
                    <span class="key">→</span>
                </div>
            </div>
            <span>Se déplacer</span>
        </div>
        <div class="instruction-row">
            <span class="key">Molette</span>
            <span>Avancer / Reculer</span>
        </div>
    </div>

    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <video id="welcome-video-bg" autoplay loop muted playsinline>
            <source src="videos/background.webm" type="video/webm">
        </video>

        <!-- Overlay fondu noir au clic play (devant tout sauf logo) -->
        <div id="welcome-fade-overlay"></div>

        <div class="welcome-logo-container" id="welcome-logo-container">
            <img src="img/presences_rares_logo.png" alt="Logo" class="welcome-logo" id="welcome-logo">
            <video class="welcome-logo-video" id="welcome-logo-video" loop muted playsinline preload="auto">
                <source src="videos/dumbo_icone_chargement.webm" type="video/webm">
            </video>
        </div>

        <div class="welcome-content" id="welcome-content">
            <span class="welcome-project-name">DUMBO</span>
            <h1 class="welcome-title">
                Présences aquatiques rares<br>
                <span class="welcome-subtitle-inline">Maquette de dispositif d'exposition</span>
            </h1>

            <p class="welcome-manifesto">
                Traduire des captations scientifiques en formes exposables, sans les simplifier ni les fictionnaliser.
            </p>

            <p class="welcome-text">
                Ce projet explore comment des images réelles issues de captations sous-marines rares, souvent fragmentaires, instables ou difficilement lisibles, peuvent être traduites visuellement afin de rendre perceptible une présence vivante autrement inaccessible au public.
            </p>

            <p class="welcome-text">
                À partir de ces images, un protocole de transformation volumétrique est appliqué. Celui-ci ne vise ni la reconstitution fidèle du milieu aquatique, ni la production d'images spectaculaires, mais la conception de formes traduites, plus stables, plus proches et regardables dans le temps de l'exposition, tout en conservant leur ancrage documentaire.
            </p>

            <p class="welcome-text">
                L'espace que vous traversez n'est pas une exposition finale, mais une maquette spatiale et perceptive. Elle permet de tester l'échelle, la proximité, la temporalité et la relation du regard à ces formes, dans la perspective d'un futur dispositif d'exposition physique.
            </p>

            <p class="welcome-text">
                Cette maquette s'inscrit dans une réflexion sur la médiation scientifique&nbsp;: comment exposer des formes de vie rarement observables sans les simplifier, sans les fictionnaliser, et sans prétendre les rendre totalement accessibles.
            </p>

            <div class="welcome-context">
                Projet de recherche par le design — maquette non définitive<br>
                Images issues de sources scientifiques réelles<br>
                Traductions visuelles réalisées dans un cadre expérimental
            </div>

            <!-- Bouton Play mobile: dans le flux -->
            <div class="play-button-container mobile-play" id="play-button-mobile" onclick="handlePlayClick()">
                <img src="img/icone_play_rond.png" alt="Play" class="play-rond">
                <img src="img/icone_play_fleche.png" alt="Play" class="play-fleche">
            </div>
        </div>

        <!-- Bouton Play desktop: position absolute -->
        <div class="play-button-container desktop-play" id="play-button" onclick="handlePlayClick()">
            <img src="img/icone_play_rond.png" alt="Play" class="play-rond">
            <img src="img/icone_play_fleche.png" alt="Play" class="play-fleche">
        </div>
    </div>

    <!-- Pause Screen (ESC / Infos) -->
    <div id="pause-screen">
        <!-- Bouton fullscreen (desktop) — bascule le plein écran sans fermer le panneau -->
        <button class="pause-close-btn" id="pause-close-btn" onclick="handlePauseFullscreenClick()">
            <svg class="fs-enter-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3"></path>
                <path d="M21 8V5a2 2 0 0 0-2-2h-3"></path>
                <path d="M3 16v3a2 2 0 0 0 2 2h3"></path>
                <path d="M16 21h3a2 2 0 0 0 2-2v-3"></path>
            </svg>
            <svg class="fs-exit-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
                <path d="M8 3v3a2 2 0 0 1-2 2H3"></path>
                <path d="M21 8h-3a2 2 0 0 1-2-2V3"></path>
                <path d="M3 16h3a2 2 0 0 1 2 2v3"></path>
                <path d="M16 21v-3a2 2 0 0 1 2-2h3"></path>
            </svg>
        </button>

        <div class="pause-instructions">
            <div class="instruction-row">
                <span class="key">ALT</span>
                <span>Infos</span>
            </div>
            <div class="instruction-row">
                <span class="key">ESC</span>
                <span>Plein écran</span>
            </div>
            <div class="instruction-row">
                <span class="key">Souris</span>
                <span>Regarder autour</span>
            </div>
            <div class="instruction-row">
                <div class="keys-group">
                    <span class="key">ZQSD</span>
                    <span class="or-text">ou</span>
                    <div class="arrows-grid">
                        <span class="key">↑</span>
                        <span class="key">←</span>
                        <span class="key">↓</span>
                        <span class="key">→</span>
                    </div>
                </div>
                <span>Se déplacer</span>
            </div>
            <div class="instruction-row">
                <span class="key">Molette</span>
                <span>Avancer / Reculer</span>
            </div>
        </div>

        <div class="pause-content" onclick="event.stopPropagation()">
            <h2 class="pause-title">À propos de cette maquette</h2>

            <p class="pause-text">
                Cet espace numérique a été conçu comme un outil de simulation perceptive, permettant de tester comment des formes issues d'images scientifiques réelles peuvent être perçues lorsqu'elles sont traduites volumétriquement et mises en situation d'exposition.
            </p>

            <p class="pause-text">
                Les formes présentées ne sont ni des reconstitutions fidèles, ni des créations fictionnelles. Elles résultent d'un processus de traduction visuelle, appliqué à des captations existantes, afin de rendre perceptible une présence vivante tout en assumant les limites du réel et de l'image.
            </p>

            <div class="pause-conceptual-list">
                <span class="list-intro">Le choix d'une maquette web répond à des contraintes de temps et de moyens. Il permet néanmoins d'explorer des questions essentielles&nbsp;:</span>
                <span class="list-item">- distance et proximité du regard</span>
                <span class="list-item">- échelle et corporalité</span>
                <span class="list-item">- temporalité de l'observation</span>
                <span class="list-item">- relation entre image documentaire et forme exposée</span>
            </div>

            <p class="pause-text">
                Cette interface ne remplace pas une exposition physique. Elle en constitue une prévisualisation critique, destinée à nourrir la réflexion sur de futurs dispositifs de médiation.
            </p>

            <div class="pause-meta">
                Navigation libre - déplacement lent recommandé<br>
                Les contenus projetés peuvent évoluer au cours du projet
            </div>
        </div>

        <div class="pause-controls" onclick="event.stopPropagation()">
            <div class="volume-control" id="volume-control" onmouseleave="hideVolumeSlider()">
                <div class="volume-slider-container">
                    <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="30" oninput="updateVolume(this.value)">
                </div>
                <button class="mute-button" id="mute-button" onclick="toggleMute()" ontouchstart="showVolumeSlider()" onmouseenter="showVolumeSlider()">
                <svg id="mute-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    <line id="mute-slash" x1="2" y1="2" x2="22" y2="22" style="display:none;"></line>
                </svg>
            </button>
            </div>
        </div>

        <div class="pause-credits">Musique : Teimo (schluss) par Thomas Köner</div>
    </div>

    <!-- Fade-from-black overlay (reveals 3D scene smoothly after loading) -->
    <div id="scene-reveal-overlay"></div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <video class="loading-video" autoplay loop muted playsinline preload="auto">
            <source src="videos/dumbo_icone_chargement.webm" type="video/webm">
        </video>
    </div>

    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 — Video projection volumétrique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn" data-shape="circle" title="Circle">○</button>
        <button class="shape-btn active" data-shape="square" title="Square">□</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">◇</button>
        <button class="shape-btn" data-shape="star" title="Star">☆</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>

    <!-- Video Paused Indicator -->
    <div id="video-paused-indicator">VIDEO PAUSED</div>

    <!-- FPS Counter -->
    <div id="fps-counter">
        <span class="fps-value">60</span>
        <span class="fps-label">FPS</span>
    </div>

    <div id="canvas"></div>

    <!-- FPS Settings Panel (Bottom Left) -->
    <div id="fps-settings-panel" class="hidden">
        <button class="panel-close-btn" onclick="document.getElementById('fps-settings-panel').classList.add('hidden')" title="Fermer (F pour réafficher)">×</button>
        <h3>FPS & Verre Settings</h3>

        <div class="fps-param">
            <label>Vitesse touches <span class="fps-param-value" id="val-fps-speed">2.25</span></label>
            <input type="range" id="fps-speed" min="0.5" max="10" step="0.1" value="2.25">
        </div>

        <div class="fps-param">
            <label>Vitesse molette <span class="fps-param-value" id="val-fps-scroll">4.5</span></label>
            <input type="range" id="fps-scroll" min="0.5" max="15" step="0.5" value="4.5">
        </div>

        <div class="fps-param">
            <label>Accélération <span class="fps-param-value" id="val-fps-accel">0.10</span></label>
            <input type="range" id="fps-accel" min="0.05" max="1.0" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Décélération <span class="fps-param-value" id="val-fps-decel">0.30</span></label>
            <input type="range" id="fps-decel" min="0.05" max="1.0" step="0.05" value="0.3">
        </div>

        <div class="fps-param">
            <label>Hauteur caméra <span class="fps-param-value" id="val-fps-height">-96</span></label>
            <input type="range" id="fps-height" min="-150" max="-10" step="1" value="-96">
        </div>

        <div class="fps-param">
            <label>Gravité <span class="fps-param-value" id="val-fps-gravity">-1.50</span></label>
            <input type="range" id="fps-gravity" min="-3.0" max="-0.1" step="0.1" value="-1.5">
        </div>

        <div class="fps-param">
            <label>Hauteur yeux <span class="fps-param-value" id="val-fps-eye">30</span></label>
            <input type="range" id="fps-eye" min="5" max="100" step="1" value="30">
        </div>

        <div class="fps-param">
            <label>Sensibilité souris <span class="fps-param-value" id="val-fps-mouse">0.0010</span></label>
            <input type="range" id="fps-mouse" min="0.0005" max="0.01" step="0.0005" value="0.001">
        </div>

        <div class="fps-param">
            <label>Largeur hitbox <span class="fps-param-value" id="val-fps-hitbox-width">1</span></label>
            <input type="range" id="fps-hitbox-width" min="0.1" max="20" step="0.1" value="1">
        </div>

        <div class="fps-param">
            <label>Hauteur hitbox <span class="fps-param-value" id="val-fps-hitbox-height">10</span></label>
            <input type="range" id="fps-hitbox-height" min="1" max="100" step="1" value="10">
        </div>

        <div class="fps-param">
            <label>Opacité verre <span class="fps-param-value" id="val-glass-opacity">0.00</span></label>
            <input type="range" id="glass-opacity" min="0" max="1" step="0.05" value="0.00">
        </div>

        <div class="fps-param">
            <label>Rugosité verre <span class="fps-param-value" id="val-glass-roughness">0.10</span></label>
            <input type="range" id="glass-roughness" min="0" max="1" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Metalness verre <span class="fps-param-value" id="val-glass-metalness">0.20</span></label>
            <input type="range" id="glass-metalness" min="0" max="1" step="0.05" value="0.2">
        </div>

        <button id="fps-export-btn" style="grid-column: 1 / -1;">📋 Export (Ctrl+S)</button>
    </div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 — Image dispersée</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 — Video dispersée</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 — Luminance depth</div>
    </div>

    <!-- Screen Management Panel (Left side) -->
    <div id="screen-manager-panel">
        <button class="panel-close-btn" onclick="document.getElementById('screen-manager-panel').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <h2>Gestion des Écrans</h2>
        <div class="screen-list" id="screen-list"></div>
        <button class="add-screen-btn" onclick="addNewScreen()">+ Ajouter un Écran</button>
        <p class="screen-manager-hint">
            <strong>Raccourcis clavier:</strong><br>
            Touche A: Ajouter un écran<br>
            Suppr/Backspace: Supprimer sélection<br>
            Ctrl+C: Copier écran | Ctrl+V: Coller<br>
            1-7: Sélectionner écran<br>
            G/R/E/S: Translate/Rotate/Scale/Size
        </p>
    </div>

    <div id="ui">
        <button class="panel-close-btn" onclick="document.getElementById('ui').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">▼</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">▼</button>
                        <span class="value" id="val-density" data-param="density">15X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="30" step="1" value="15">
                    <div class="center-mark" style="left: 20.7%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">▼</button>
                        <span class="value" id="val-depth" data-param="depth">0.10X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="0.2" step="0.01" value="0.10">
                    <div class="center-mark" style="left: 50%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SMOOTHING</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="smoothing" data-dir="down">▼</button>
                        <span class="value" id="val-smoothing" data-param="smoothing">0.00</span>
                        <button class="arrow-btn" data-param="smoothing" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="smoothing" min="0.0" max="0.1" step="0.005" value="0.1">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">▼</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">▼</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.8</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>GLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="glow" data-dir="down">▼</button>
                        <span class="value" id="val-glow" data-param="glow">0.00</span>
                        <button class="arrow-btn" data-param="glow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="glow" min="0.0" max="1.0" step="0.05" value="0.0">
                    <div class="center-mark" style="left: 30%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">▼</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">▼</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">▼</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.1</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.1">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">▼</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.70</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.70">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Clic gauche + drag pour tourner • Molette pour avancer/reculer • Flèches: déplacement • P/M: monter/descendre • N: toggle UI</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        // PERFORMANCE: Désactiver tous les console.log en production
        const DEBUG_MODE = false;
        const _log = console.log.bind(console);
        if (!DEBUG_MODE) {
            console.log = function() {};
        }

        if (DEBUG_MODE) {
            _log('Script démarré - DEBUG_MODE:', DEBUG_MODE);
        }

        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.1;
        let depthSmoothing = 0.1; // Seuil pour atténuer micro-mouvements (0 = aucun, 0.1 = élevé)
        let pointSize = 0.39;
        let particleDensity = 15;
        let brightness = 1.8;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'square'; // Mode carré par défaut
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // Multi-video system: each volumetric screen has its own video
        let screenVideos = {}; // {1: video_element, 2: video_element, 5: video_element, ...}
        let videoTextures = {}; // {1: texture, 2: texture, 5: texture, ...}

        // Sampling canvases for each screen (for continuous video updates)
        let screenSamplingCanvases = {};  // {screenNum: {canvas, ctx, data}}

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.1;
        let saturation = 0.70;
        let hideBackground = false;
        let bgThreshold = 40;
        let glowIntensity = 0.0; // Émissivité/glow des particules lumineuses

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Particle density system - Safety cap to prevent performance issues
        const MAX_PARTICLES = 500000; // Cap maximum de particules par écran

        // FPS Counter variables
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let fpsCurrentFPS = 60;
        let fpsUpdateInterval = 500; // Update FPS display every 500ms

        // Cache DOM elements to avoid repeated queries in animate()
        let fpsDOMCache = {
            counter: null,
            value: null,
            gameInstructions: null
        };

        // CubeCamera optimization: throttle updates
        let cubeCameraUpdateCounter = 0;
        const CUBE_CAMERA_UPDATE_INTERVAL = 3; // Update every 3 frames

        // PERFORMANCE: Throttle floor raycasting (gravity detection)
        let raycastCounter = 0;
        const RAYCAST_INTERVAL = 3; // Raycast every 3 frames
        let lastGroundY = null; // Cache last ground hit

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // CRITICAL PERFORMANCE: Reusable objects for collision detection & camera movement
        const reusablePlayerBox = new THREE.Box3();
        const reusableWallBox = new THREE.Box3();
        const reusableRaycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const reusableForward = new THREE.Vector3();
        const reusableRight = new THREE.Vector3();
        const reusableUp = new THREE.Vector3(0, 1, 0);
        const reusablePrevPosition = new THREE.Vector3();

        // Scroll lissé (smooth scroll) - Effet très minimal
        let scrollVelocity = 0; // Vitesse de scroll actuelle
        const SCROLL_SMOOTHING = 0.56; // Facteur de lissage réduit de 30%
        const SCROLL_DECAY = 0.50; // Décroissance de la vitesse (plus bas = arrêt plus rapide)

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Transform controls for manipulating screens
        let transformControls = null;
        let selectedScreen = null;
        let allScreens = {}; // Store all screens by number
        let clipboardScreen = null; // Store copied screen data for copy/paste
        let screenLabels = {}; // Store screen number labels (sprites) for volumetric screens
        let screenOutlines = {}; // Store neon outlines for admin mode debug
        const VOLUMETRIC_SCREENS = [1, 2, 3, 4, 5, 6]; // Écrans volumétriques (renumérotés sans trous)

        // Free camera (no orbit controls, no pivot)
        let freeCameraEnabled = true;
        let fpsMode = false; // Mode Normal/Admin par défaut - Touche B pour activer mode FPS
        let bPressCount = 0; // Compteur d'appuis consécutifs sur B
        let bPressTimeout = null; // Timeout pour réinitialiser le compteur
        let showHitbox = false; // Affichage de la hitbox activé avec touche H
        let hitboxHelper = null; // Helper pour visualiser la hitbox
        let cameraYaw = 0; // Rotation horizontale (Y axis)
        let cameraPitch = 0; // Rotation verticale (X axis)
        let isMouseLocked = false;

        // FPS visual effects
        let headBobTimer = 0;
        const HEAD_BOB_SPEED = 0.12;
        const HEAD_BOB_AMOUNT = 0.5;
        const HEAD_BOB_SIDE_AMOUNT = 0.25;
        const DEFAULT_FOV = 75;
        const SPRINT_FOV_INCREASE = 5;
        let currentFOV = DEFAULT_FOV;
        let targetFOV = DEFAULT_FOV;

        // Camera smoothing (mouse look interpolation)
        let smoothYaw = null;
        let smoothPitch = null;
        const MOUSE_SMOOTHING = 0.25;

        // Camera sway (strafe tilt)
        let cameraTilt = 0;
        const CAMERA_TILT_AMOUNT = 0.012;
        const CAMERA_TILT_SPEED = 0.08;

        // FPS Physics (paramètres configurables via interface)
        let playerVelocityY = 0;
        let isOnGround = false;
        let currentSpeed = 0;
        const MIN_SPEED = 0;

        // FPS Settings Object (accessible globalement)
        const fpsSettings = {
            fpsCameraHeight: -96,       // Hauteur de spawn de la caméra
            fpsGravity: -1.5,           // Gravité
            fpsPlayerHeight: 25,        // Hauteur des yeux du joueur au-dessus du sol
            fpsMaxSpeed: 1.125,         // Vitesse maximale (divisée par 2)
            fpsAcceleration: 0.1,       // Vitesse d'accélération
            fpsDeceleration: 0.3,       // Vitesse de décélération
            fpsCollisionRadius: 0.5,    // Rayon de collision (réduit par 10)
            fpsHitboxWidth: 1,          // Largeur de la hitbox (réduit par 10)
            fpsHitboxHeight: 10,        // Hauteur de la hitbox (réduit par 10)
            fpsScrollSpeed: 4.5,        // Vitesse de déplacement à la molette
            fpsMouseSensitivity: 0.001, // Sensibilité souris
            // Glassmorphisme écran 10
            glassOpacity: 0.00,         // Opacité du verre
            glassRoughness: 0.1,        // Rugosité de surface
            glassMetalness: 0.2         // Aspect métallique
        };

        // Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Magnetism settings
        const MAGNETISM_THRESHOLD = 0.05; // ~3 degrees in radians
        const MAGNETISM_ANGLES = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2];

        // Scale mode: 'uniform' (proportionnel) or 'free' (par axe)
        let scaleMode = 'free'; // Default to free mode (allows per-axis scaling)

        // FPS Camera controls (only when no screen selected)
        const cameraKeys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            sprint: false
        };
        const CAMERA_SPEED = 1.5; // Vitesse de déplacement de la caméra (divisée par 2)
        const CAMERA_SPRINT_MULTIPLIER = 2.5; // Multiplicateur pour la vitesse de sprint

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 30, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 0.2, step: 0.01, decimals: 2, suffix: 'X' }, // Plage 0-0.2 pour précision sur petites valeurs
            smoothing: { min: 0.0, max: 0.1, step: 0.005, decimals: 3, suffix: '' }, // Seuil atténuation micro-mouvements
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            glow: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' }, // Émissivité/glow
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            // GPU uniform params: update shader uniforms instantly, no regeneration
            const gpuUniformParams = ['size', 'depth', 'brightness', 'contrast', 'saturation', 'glow', 'blackThreshold', 'depthCullPower'];

            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);
                    const val = parseFloat(slider.value);

                    if (param === 'flow') {
                        flowIntensity = val;
                    } else if (param === 'breath') {
                        breathSpeed = val;
                    } else if (gpuUniformParams.includes(param)) {
                        // Update JS variable + GPU uniforms (no regeneration needed)
                        if (param === 'size') pointSize = val;
                        else if (param === 'depth') depthMultiplier = val;
                        else if (param === 'brightness') brightness = val;
                        else if (param === 'contrast') contrast = val;
                        else if (param === 'saturation') saturation = val;
                        else if (param === 'glow') glowIntensity = val;
                        else if (param === 'blackThreshold') blackThreshold = val;
                        else if (param === 'depthCullPower') depthCullPower = val;
                        updateGPUVolumeUniforms();
                    } else {
                        // density, smoothing, bgThreshold: need full regeneration
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = 'Pause';
            } else {
                video.pause();
                btn.textContent = 'Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Fonction pour vérifier et cacher les instructions (niveau global pour scroll + clavier)
        function checkHideInstructions() {
            if (instructionsHidden) return;

            // Conditions: au moins 2 touches distinctes OU au moins 3 scrolls
            if (uniqueKeysPressed.size >= REQUIRED_UNIQUE_KEYS || scrollCount >= REQUIRED_SCROLLS) {
                const instructionsElement = document.getElementById('game-instructions');
                if (instructionsElement) {
                    instructionsElement.classList.add('hidden');
                    instructionsHidden = true;
                }
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            // SPECTATOR MODE: Only allow movement keys and mode toggle
            if (fpsMode) {
                const allowedKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',  // WASD movement
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',  // Arrow keys
                    'ShiftLeft', 'ShiftRight',  // Sprint
                    'KeyB',  // Toggle to Admin mode
                    'Escape',  // Toggle fullscreen
                    'AltLeft', 'AltRight'  // Toggle info screen
                ];

                if (!allowedKeys.includes(e.code)) {
                    // Block all other keys in Spectator mode
                    return;
                }

                // Track movement keys for instructions hiding
                const movementKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
                ];
                if (movementKeys.includes(e.code) && !instructionsHidden) {
                    uniqueKeysPressed.add(e.code);

                    // Vérifier si les conditions sont remplies (touches + scrolls)
                    checkHideInstructions();
                }
            }

            // Debug: log all Ctrl key combinations
            if (e.ctrlKey) {
                console.log('🎹 Touche Ctrl détectée:', e.code, 'ctrlKey:', e.ctrlKey, 'shiftKey:', e.shiftKey);
            }

            // Ctrl+Z: Undo (PRIORITY - check first!)
            if (e.code === 'KeyZ' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('🔄 Ctrl+Z détecté - Exécution undo()');
                undo();
                return; // Stop here
            }

            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.code === 'KeyZ' && e.ctrlKey && e.shiftKey) || (e.code === 'KeyY' && e.ctrlKey)) {
                e.preventDefault();
                e.stopPropagation();
                console.log('🔄 Ctrl+Shift+Z ou Ctrl+Y détecté - Exécution redo()');
                redo();
                return; // Stop here
            }

            // Ctrl+S: Save positions to JSON file
            if (e.code === 'KeyS' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('💾 Ctrl+S détecté - Sauvegarde positions');
                savePositionsToFile();
                return; // Stop here
            }

            // Ctrl+C: Copy selected screen
            if (e.code === 'KeyC' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('📋 Ctrl+C détecté - Copie écran');
                copyScreen();
                return; // Stop here
            }

            // Ctrl+V: Paste screen (create duplicate)
            if (e.code === 'KeyV' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('📄 Ctrl+V détecté - Collage écran');
                pasteScreen();
                return; // Stop here
            }

            // FPS Camera controls (always active, even with screen selected)
            // Arrow keys always work; WASD only when no screen selected
            if (e.code === 'ArrowUp' || (e.code === 'KeyW' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.forward = true;
            }
            if (e.code === 'ArrowDown' || (e.code === 'KeyS' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.backward = true;
            }
            if (e.code === 'ArrowLeft' || (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.left = true;
            }
            if (e.code === 'ArrowRight' || (e.code === 'KeyD' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.right = true;
            }

            // O/L: Camera up/down (only in normal mode, not FPS mode)
            if (e.code === 'KeyO' && !fpsMode) {
                e.preventDefault();
                cameraKeys.up = true;
            }
            if (e.code === 'KeyL' && !fpsMode) {
                e.preventDefault();
                cameraKeys.down = true;
            }

            // Shift: Sprint (when no screen selected, works in both modes)
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !selectedScreen) {
                cameraKeys.sprint = true;
            }

            // Space: play/pause (only if video exists)
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }

            // Number keys 1-9: Select screen/shape (keyboard + numpad)
            if ((e.code >= 'Digit1' && e.code <= 'Digit9') || (e.code >= 'Numpad1' && e.code <= 'Numpad9')) {
                e.preventDefault();
                const screenNum = parseInt(e.code.replace('Digit', '').replace('Numpad', ''));
                selectScreen(screenNum);
            }

            // G: Translate mode
            if (e.code === 'KeyG' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('translate');
                console.log('Mode: TRANSLATE (déplacement XYZ)');
            }

            // R: Rotate mode
            if (e.code === 'KeyR' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('rotate');
                console.log('Mode: ROTATE (rotation XYZ)');
            }

            // E: Scale mode
            if (e.code === 'KeyE' && selectedScreen) {
                e.preventDefault();
                // Cycle between scale modes
                if (transformControls.mode !== 'scale') {
                    // First press: activate scale mode
                    transformControls.setMode('scale');
                    scaleMode = 'free';
                    console.log('Mode: SCALE LIBRE (axe individuel) - Re-appuyez sur E pour mode uniforme');
                } else {
                    // Subsequent presses: toggle between free and uniform
                    scaleMode = scaleMode === 'free' ? 'uniform' : 'free';
                    console.log(`Mode: SCALE ${scaleMode === 'uniform' ? 'UNIFORME (proportionnel)' : 'LIBRE (axe individuel)'}`);
                }
            }

            // S: Size/Resize mode (when screen selected) OR Save positions (when no screen)
            if (e.code === 'KeyS' && !e.ctrlKey) {
                e.preventDefault();
                if (selectedScreen) {
                    // Activate SIZE mode (geometry resize)
                    transformControls.setMode('scale');
                    scaleMode = 'resize'; // Special mode for geometry resizing
                    console.log('=== MODE: REDIMENSIONNEMENT (S) ===');
                    console.log('Modifie les positions des particules directement');
                    console.log('→ Surface change SANS affecter depth spread');
                    console.log('→ Idéal pour harmoniser les écrans volumétriques');
                    console.log('Drag les handles pour redimensionner');
                } else {
                    saveAllPositions();
                }
            }

            // Escape: browser exits fullscreen natively; in Admin mode, deselect
            if (e.code === 'Escape') {
                if (!fpsMode && selectedScreen) {
                    e.preventDefault();
                    deselectScreen();
                }
                // In FPS mode: browser handles fullscreen exit natively via ESC — no custom action needed
            }

            // Delete or Backspace: Delete selected screen
            if ((e.code === 'Delete' || e.code === 'Backspace') && selectedScreen) {
                e.preventDefault();
                deleteScreen(selectedScreen);
            }

            // A: Add new screen
            if (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey) {
                e.preventDefault();
                addNewScreen();
            }

            // N: Toggle all interfaces
            if (e.code === 'KeyN') {
                e.preventDefault();
                toggleAllInterfaces();
            }

            // B: Toggle FPS mode (requires 5 consecutive presses)
            if (e.code === 'KeyB') {
                e.preventDefault();

                // Clear existing timeout
                if (bPressTimeout) {
                    clearTimeout(bPressTimeout);
                }

                // Increment counter
                bPressCount++;
                console.log(`🅱️ B appuyé ${bPressCount}/5 fois`);

                // Reset counter after 2 seconds of inactivity
                bPressTimeout = setTimeout(() => {
                    bPressCount = 0;
                    console.log('⏱️ Compteur B réinitialisé (timeout)');
                }, 2000);

                // Only toggle mode after 5 presses
                if (bPressCount < 5) {
                    return; // Not enough presses yet
                }

                // Reset counter and toggle mode
                bPressCount = 0;
                clearTimeout(bPressTimeout);
                fpsMode = !fpsMode;
                if (fpsMode) {
                    // ENTERING SPECTATOR MODE: Hide all interfaces
                    console.log('🎮 MODE SPECTATEUR (FPS) ACTIVÉ');
                    console.log('   - Cliquez sur le canvas pour activer PointerLock');
                    console.log('   - WASD pour se déplacer');
                    console.log('   - Shift pour sprinter');
                    console.log('   - ESC pour sortir du PointerLock');
                    console.log('   - B pour passer en mode ADMIN');
                    console.log('   - Interfaces désactivées en mode Spectateur');

                    // Hide all UI elements in Spectator mode
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('fps-counter')?.classList.add('hidden');

                    // Hide screen labels in Spectator mode
                    hideScreenLabels();

                    // Hide cursor in Spectator/FPS mode
                    document.body.style.cursor = 'none';

                    // Play background music in Spectator mode
                    playAudio();
                } else {
                    // ENTERING ADMIN MODE: Show all interfaces
                    console.log('🖱️ MODE ADMIN ACTIVÉ');

                    // Show screen labels in Admin mode
                    updateScreenLabels();

                    // Pause music in Admin mode
                    pauseAudio();
                    console.log('   - N pour afficher/cacher les interfaces');
                    console.log('   - B pour passer en mode SPECTATEUR');
                    console.log('   - F pour FPS Settings');
                    console.log('   - Toutes les touches actives');

                    // Release pointer lock if active
                    if (document.exitPointerLock) {
                        document.exitPointerLock();
                    }

                    // CRITICAL: Show cursor in Admin mode
                    document.body.style.cursor = 'default';
                    isMouseLocked = false;

                    // CRITICAL: In Admin mode, show ONLY FPS counter + screen numbers by default
                    // Other interfaces appear only when pressing N or their individual keys
                    document.getElementById('fps-counter')?.classList.remove('hidden');

                    // Hide all other interfaces by default
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('controls')?.classList.add('hidden');
                }
            }

            // H: Toggle hitbox visibility
            if (e.code === 'KeyH') {
                e.preventDefault();
                showHitbox = !showHitbox;
                if (showHitbox) {
                    console.log('👁️ HITBOX VISIBLE');
                } else {
                    console.log('🚫 HITBOX MASQUÉE');
                    // Remove hitbox helper if exists and dispose properly to prevent memory leak
                    if (hitboxHelper) {
                        scene.remove(hitboxHelper);
                        if (hitboxHelper.geometry) hitboxHelper.geometry.dispose();
                        if (hitboxHelper.material) hitboxHelper.material.dispose();
                        hitboxHelper = null;
                    }
                }
            }

            // Individual interface toggles (Admin mode only)
            if (!fpsMode) {
                // & (Digit1): Toggle UI (video + controls)
                if (e.key === '&' || e.code === 'Digit1') {
                    e.preventDefault();
                    const ui = document.getElementById('ui');
                    ui?.classList.toggle('hidden');
                    console.log(`🎥 Interface vidéo: ${ui?.classList.contains('hidden') ? 'cachée' : 'visible'}`);
                }

                // é (Digit2): Toggle screen manager
                if (e.key === 'é' || e.code === 'Digit2') {
                    e.preventDefault();
                    const screenManager = document.getElementById('screen-manager-panel');
                    screenManager?.classList.toggle('hidden');
                    console.log(`📺 Gestionnaire écrans: ${screenManager?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // " (Digit3): Toggle shape selector
                if (e.key === '"' || e.code === 'Digit3') {
                    e.preventDefault();
                    const shapeSelector = document.getElementById('shape-selector');
                    shapeSelector?.classList.toggle('hidden');
                    console.log(`🔷 Sélecteur formes: ${shapeSelector?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // ' (Digit4): Toggle FPS settings (replaces F key)
                if (e.key === "'" || e.code === 'Digit4') {
                    e.preventDefault();
                    const fpsSettings = document.getElementById('fps-settings-panel');
                    fpsSettings?.classList.toggle('hidden');
                    console.log(`⚙️ Paramètres FPS: ${fpsSettings?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }

                // ( (Digit5): Toggle FPS counter
                if (e.key === '(' || e.code === 'Digit5') {
                    e.preventDefault();
                    const fpsCounter = document.getElementById('fps-counter');
                    fpsCounter?.classList.toggle('hidden');
                    console.log(`📊 Compteur FPS: ${fpsCounter?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // - (Digit6 or Minus): Toggle controls (protocol settings)
                if (e.key === '-' || e.code === 'Digit6' || e.code === 'Minus') {
                    e.preventDefault();
                    const controls = document.getElementById('controls');
                    controls?.classList.toggle('hidden');
                    console.log(`🎛️ Réglages protocole: ${controls?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }
            }
        });

        // Keyboard controls - keyup for FPS camera
        document.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                cameraKeys.forward = false;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                cameraKeys.backward = false;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                cameraKeys.left = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                cameraKeys.right = false;
            }
            if (e.code === 'KeyO') {
                cameraKeys.up = false;
            }
            if (e.code === 'KeyL') {
                cameraKeys.down = false;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                cameraKeys.sprint = false;
            }

            // Réinitialiser le timer de maintien si touche relâchée
            const movementKeys = [
                'KeyW', 'KeyA', 'KeyS', 'KeyD',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
            ];
            if (movementKeys.includes(e.code)) {
                if (keyHoldTimer) {
                    clearTimeout(keyHoldTimer);
                    keyHoldTimer = null;
                }
                keyHoldStartTime = null;
            }
        });

        // Transform control functions
        function selectScreen(num) {
            if (!allScreens[num]) return;

            // Deselect previous first to prevent listener leaks
            if (selectedScreen !== null) deselectScreen();

            selectedScreen = num;
            transformControls.attach(allScreens[num]);

            // Set snap settings based on Shift key
            document.addEventListener('keydown', onShiftChange);
            document.addEventListener('keyup', onShiftChange);

            console.log('Écran ' + num + ' sélectionné — G/R/E/S pour transformer, Échap pour désélectionner');
        }

        function deselectScreen() {
            if (selectedScreen !== null) {
                console.log('Écran ' + selectedScreen + ' désélectionné');
                transformControls.detach();
                selectedScreen = null;

                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }
        }

        // Toggle all interfaces (touche N) - ONLY accessible in Admin mode
        function toggleAllInterfaces() {
            // Only allow in Admin mode (not FPS/Spectator mode)
            if (fpsMode) return;

            const ui = document.getElementById('ui');
            const screenManager = document.getElementById('screen-manager-panel');
            const shapeSelector = document.getElementById('shape-selector');
            const fpsSettings = document.getElementById('fps-settings-panel');
            const fpsCounter = document.getElementById('fps-counter');
            const loadSection = document.getElementById('load-section');

            const isVisible = !ui.classList.contains('hidden');

            if (isVisible) {
                // Cacher les interfaces SAUF load-section si aucune vidéo n'est chargée
                if (currentVideo) {
                    ui.classList.add('hidden');
                } else {
                    // Si pas de vidéo, garder load-section visible mais cacher le reste
                    document.getElementById('controls')?.classList.add('hidden');
                }
                screenManager.classList.add('hidden');
                shapeSelector.classList.add('hidden');
                fpsSettings.classList.add('hidden');
                fpsCounter.classList.add('hidden');
            } else {
                ui.classList.remove('hidden');
                screenManager.classList.remove('hidden');
                shapeSelector.classList.remove('hidden');
                fpsSettings.classList.remove('hidden');
                fpsCounter.classList.remove('hidden');
                if (currentVideo) {
                    document.getElementById('controls')?.classList.remove('hidden');
                }
            }
        }

        function deleteScreen(num) {
            if (!allScreens[num]) {
                console.warn(`Écran ${num} n'existe pas`);
                return;
            }

            // Save state for undo
            saveState();

            const screen = allScreens[num];

            // Detach transform controls if this screen is selected
            if (selectedScreen === num) {
                transformControls.detach();
                selectedScreen = null;
                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }

            // Remove from scene
            if (screen.parent) {
                screen.parent.remove(screen);
            }

            // Dispose geometry and material to free memory
            if (screen.geometry) screen.geometry.dispose();
            if (screen.material) {
                if (Array.isArray(screen.material)) {
                    screen.material.forEach(mat => mat.dispose());
                } else {
                    screen.material.dispose();
                }
            }

            // Remove from allScreens
            delete allScreens[num];

            console.log(`=== ÉCRAN ${num} SUPPRIMÉ ===`);

            // Update UI
            updateScreenList();
        }

        // Screen numbering system for volumetric screens and shapes
        // color parameter: 'green' for volumetric screens, 'red' for forms/shapes
        function createScreenLabel(screenNumber, color = 'red') {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Choose color based on type
            const labelColor = color === 'green' ? '#00ff4c' : '#ff004c';

            // Draw number
            ctx.fillStyle = labelColor;
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Add glow effect
            ctx.shadowColor = labelColor;
            ctx.shadowBlur = 20;
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(50, 50, 1);

            return sprite;
        }

        // Create neon outline for screen/shape (admin debug mode)
        function createScreenOutline(screen) {
            // Get geometry - handle both regular meshes and instanced meshes
            let geometry = screen.geometry;
            if (!geometry) return null;

            // Create edge geometry for outline
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff004c, // Neon red
                linewidth: 1,
                transparent: true,
                opacity: 0.8
            });
            const outline = new THREE.LineSegments(edges, lineMaterial);

            // Copy transform from original screen
            outline.position.copy(screen.position);
            outline.rotation.copy(screen.rotation);
            outline.scale.copy(screen.scale);

            return outline;
        }

        function updateScreenLabels() {
            // Remove existing labels
            Object.values(screenLabels).forEach(label => {
                if (label.parent) label.parent.remove(label);
            });
            screenLabels = {};

            // Remove existing outlines
            Object.values(screenOutlines).forEach(outline => {
                if (outline && outline.parent) outline.parent.remove(outline);
            });
            screenOutlines = {};

            // Only show in Admin mode
            if (fpsMode) return;

            // Create labels and outlines for ALL screens and shapes
            Object.keys(allScreens).forEach(screenNum => {
                const screen = allScreens[screenNum];
                if (!screen) return;

                const num = parseInt(screenNum);
                const isVolumetric = VOLUMETRIC_SCREENS.includes(num);

                // Create label: green for volumetric screens, red for forms/shapes
                const labelColor = isVolumetric ? 'green' : 'red';
                const label = createScreenLabel(screenNum, labelColor);
                label.position.copy(screen.position);
                scene.add(label);
                screenLabels[screenNum] = label;

                // Create outline ONLY for forms/shapes (not volumetric screens)
                if (!isVolumetric) {
                    const outline = createScreenOutline(screen);
                    if (outline) {
                        scene.add(outline);
                        screenOutlines[screenNum] = outline;
                    }
                }
            });
        }

        function hideScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = false;
            });
            Object.values(screenOutlines).forEach(outline => {
                if (outline) outline.visible = false;
            });
        }

        function showScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = true;
            });
        }

        function addNewScreen() {
            console.log('🆕 addNewScreen() appelé - allScreens actuels:', Object.keys(allScreens));
            console.trace('Stack trace:'); // Pour voir qui appelle cette fonction

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }
            console.log('🆕 Nouveau numéro trouvé:', newNum);

            // Save state for undo
            saveState();

            // Default dimensions (same as standard screen)
            const width = 450;
            const height = 450;

            // Create new screen plane with color surface
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080, // Gray by default
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Position offset from origin
            const offset = (newNum - 1) * 500;
            screen.position.set(offset, 0, 0);

            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = true; // Mark as color surface by default
            screen.userData.color = 0x808080; // Store color

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`=== ÉCRAN ${newNum} CRÉÉ ===`);
            console.log(`Position: (${offset}, 0, 0)`);
            console.log(`Dimensions: ${width} x ${height}`);
            console.log(`Type: Surface couleur unie (gris)`);

            // Update UI
            updateScreenList();
        }

        // Copy selected screen to clipboard
        function copyScreen() {
            if (!selectedScreen) {
                console.log('❌ Aucun écran sélectionné pour copier');
                return;
            }

            const screen = allScreens[selectedScreen];
            if (!screen) {
                console.log('❌ Écran non trouvé');
                return;
            }

            // Deep copy all screen properties
            clipboardScreen = {
                position: {
                    x: screen.position.x,
                    y: screen.position.y,
                    z: screen.position.z
                },
                rotation: {
                    x: screen.rotation.x,
                    y: screen.rotation.y,
                    z: screen.rotation.z
                },
                scale: {
                    x: screen.scale.x,
                    y: screen.scale.y,
                    z: screen.scale.z
                },
                isColorSurface: screen.userData.isColorSurface || false,
                color: screen.userData.color || 0x808080,
                geometryType: screen.geometry ? screen.geometry.type : 'PlaneGeometry',
                dimensions: null
            };

            // Copy geometry dimensions if available
            if (screen.geometry && screen.geometry.parameters) {
                const params = screen.geometry.parameters;
                if (params.width !== undefined && params.height !== undefined) {
                    clipboardScreen.dimensions = {
                        width: params.width,
                        height: params.height
                    };
                }
            }

            console.log(`📋 Écran ${selectedScreen} copié dans le presse-papiers`);
            console.log('   Dimensions:', clipboardScreen.dimensions);
            console.log('   Position:', clipboardScreen.position);
        }

        // Paste screen from clipboard (create duplicate)
        function pasteScreen() {
            if (!clipboardScreen) {
                console.log('❌ Presse-papiers vide - copiez d\'abord un écran (Ctrl+C)');
                return;
            }

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }

            // Save state for undo
            saveState();

            // Create geometry based on stored data
            let width = 450;
            let height = 450;
            if (clipboardScreen.dimensions) {
                width = clipboardScreen.dimensions.width;
                height = clipboardScreen.dimensions.height;
            }

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: clipboardScreen.color,
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Copy position, rotation, scale
            screen.position.set(
                clipboardScreen.position.x,
                clipboardScreen.position.y,
                clipboardScreen.position.z
            );
            screen.rotation.set(
                clipboardScreen.rotation.x,
                clipboardScreen.rotation.y,
                clipboardScreen.rotation.z
            );
            screen.scale.set(
                clipboardScreen.scale.x,
                clipboardScreen.scale.y,
                clipboardScreen.scale.z
            );

            // Copy metadata
            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = clipboardScreen.isColorSurface;
            screen.userData.color = clipboardScreen.color;

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`✅ Écran ${newNum} créé par collage (duplicata)`);
            console.log(`   Position: (${screen.position.x.toFixed(3)}, ${screen.position.y.toFixed(3)}, ${screen.position.z.toFixed(3)})`);
            console.log(`   Dimensions: ${width} x ${height}`);

            // Update UI and select new screen
            updateScreenList();
            selectScreen(newNum);
        }

        function updateScreenList() {
            const screenList = document.getElementById('screen-list');
            if (!screenList) return;

            screenList.textContent = '';

            // Separate screens into two categories
            const videoScreens = [];
            const colorScreens = [];

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const isColorSurface = screen.userData.isColorSurface || false;

                if (isColorSurface) {
                    colorScreens.push(num);
                } else {
                    videoScreens.push(num);
                }
            });

            // Sort each category by number
            videoScreens.sort((a, b) => parseInt(a) - parseInt(b));
            colorScreens.sort((a, b) => parseInt(a) - parseInt(b));

            // Helper function to add section header
            const addSectionHeader = (title) => {
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    padding: 8px 0 4px 0;
                    font-size: 9px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    color: rgba(255,255,255,0.5);
                    margin-top: 8px;
                    border-top: 1px solid rgba(255,255,255,0.1);
                `;
                headerDiv.textContent = title;
                screenList.appendChild(headerDiv);
            };

            // Display video screens first
            if (videoScreens.length > 0) {
                addSectionHeader('Écrans vidéo');
                videoScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = false;
                const color = screen.userData.color || 0x808080;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'screen-item';
                if (selectedScreen == num) {
                    itemDiv.classList.add('selected');
                }

                // Click to select screen
                itemDiv.addEventListener('click', (e) => {
                    // Don't select if clicking delete button
                    if (!e.target.classList.contains('screen-delete')) {
                        selectScreen(num);
                        updateScreenList();
                    }
                });

                // Header with number and delete button
                const headerDiv = document.createElement('div');
                headerDiv.className = 'screen-header';
                const numSpan = document.createElement('span');
                numSpan.className = 'screen-num';
                numSpan.textContent = 'Écran ' + num;
                const delBtn = document.createElement('button');
                delBtn.className = 'screen-delete';
                delBtn.textContent = '×';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteScreen(num);
                    updateScreenList();
                });
                headerDiv.appendChild(numSpan);
                headerDiv.appendChild(delBtn);
                itemDiv.appendChild(headerDiv);

                // Type selector
                const typeSelectorDiv = document.createElement('div');
                typeSelectorDiv.className = 'screen-type-selector';
                const videoBtn = document.createElement('button');
                videoBtn.className = 'screen-type-btn' + (!isColorSurface ? ' active' : '');
                videoBtn.textContent = 'Vidéo';
                videoBtn.addEventListener('click', () => setScreenType(num, false));
                const colorBtn2 = document.createElement('button');
                colorBtn2.className = 'screen-type-btn' + (isColorSurface ? ' active' : '');
                colorBtn2.textContent = 'Couleur';
                colorBtn2.addEventListener('click', () => setScreenType(num, true));
                typeSelectorDiv.appendChild(videoBtn);
                typeSelectorDiv.appendChild(colorBtn2);
                itemDiv.appendChild(typeSelectorDiv);

                // Color picker (only if color surface)
                if (isColorSurface) {
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x070707, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker (safe DOM construction)
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    const colorHex = '#' + color.toString(16).padStart(6, '0');
                    const picker = document.createElement('input');
                    picker.type = 'color';
                    picker.id = 'color-picker-' + num;
                    picker.value = colorHex;
                    const hexInput = document.createElement('input');
                    hexInput.type = 'text';
                    hexInput.id = 'color-hex-' + num;
                    hexInput.value = colorHex.toUpperCase();
                    hexInput.placeholder = '#RRGGBB';
                    hexInput.maxLength = 7;
                    customDiv.appendChild(picker);
                    customDiv.appendChild(hexInput);
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    // Reset to current color if invalid
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                }

                    screenList.appendChild(itemDiv);
                });
            }

            // Display color screens
            if (colorScreens.length > 0) {
                addSectionHeader('Formes colorées');
                colorScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = true;
                    const color = screen.userData.color || 0x808080;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'screen-item';
                    if (selectedScreen == num) {
                        itemDiv.classList.add('selected');
                    }

                    // Click to select screen
                    itemDiv.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('screen-delete')) {
                            selectScreen(num);
                            updateScreenList();
                        }
                    });

                    // Header with number and delete button
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'screen-header';
                    const numSpan2 = document.createElement('span');
                    numSpan2.className = 'screen-num';
                    numSpan2.textContent = 'Forme ' + num;
                    const delBtn2 = document.createElement('button');
                    delBtn2.className = 'screen-delete';
                    delBtn2.textContent = '×';
                    delBtn2.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteScreen(num);
                        updateScreenList();
                    });
                    headerDiv.appendChild(numSpan2);
                    headerDiv.appendChild(delBtn2);
                    itemDiv.appendChild(headerDiv);

                    // Type selector
                    const typeSelectorDiv = document.createElement('div');
                    typeSelectorDiv.className = 'screen-type-selector';
                    const videoBtn2 = document.createElement('button');
                    videoBtn2.className = 'screen-type-btn' + (!isColorSurface ? ' active' : '');
                    videoBtn2.textContent = 'Vidéo';
                    videoBtn2.addEventListener('click', () => setScreenType(num, false));
                    const colorBtn3 = document.createElement('button');
                    colorBtn3.className = 'screen-type-btn' + (isColorSurface ? ' active' : '');
                    colorBtn3.textContent = 'Couleur';
                    colorBtn3.addEventListener('click', () => setScreenType(num, true));
                    typeSelectorDiv.appendChild(videoBtn2);
                    typeSelectorDiv.appendChild(colorBtn3);
                    itemDiv.appendChild(typeSelectorDiv);

                    // Color picker
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x070707, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker (safe DOM construction)
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    const colorHex = '#' + color.toString(16).padStart(6, '0');
                    const picker = document.createElement('input');
                    picker.type = 'color';
                    picker.id = 'color-picker-' + num;
                    picker.value = colorHex;
                    const hexInput = document.createElement('input');
                    hexInput.type = 'text';
                    hexInput.id = 'color-hex-' + num;
                    hexInput.value = colorHex.toUpperCase();
                    hexInput.placeholder = '#RRGGBB';
                    hexInput.maxLength = 7;
                    customDiv.appendChild(picker);
                    customDiv.appendChild(hexInput);
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                    screenList.appendChild(itemDiv);
                });
            }
        }

        function setScreenType(num, isColorSurface) {
            const screen = allScreens[num];
            if (!screen) return;

            saveState();

            screen.userData.isColorSurface = isColorSurface;

            // Detect if this is a volumetric screen (1-7) or a shape (>7)
            const isVolumetric = (num >= 1 && num <= 7);

            if (isColorSurface) {
                // Switch to color surface
                const color = screen.userData.color || 0x808080;

                if (isVolumetric) {
                    // For volumetric screens: create overlay plane to hide particles
                    if (!screen.userData.colorOverlay) {
                        // Get screen dimensions (approximate from bounding box)
                        const box = new THREE.Box3().setFromObject(screen);
                        const size = box.getSize(new THREE.Vector3());
                        const width = Math.max(size.x, size.y, size.z);
                        const height = Math.max(size.x, size.y, size.z);

                        // Create overlay mesh
                        const overlayGeometry = new THREE.PlaneGeometry(width * 1.2, height * 1.2);
                        const overlayMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);

                        // Position overlay at screen position (local space)
                        overlay.position.copy(screen.position);
                        overlay.rotation.copy(screen.rotation);
                        overlay.scale.copy(screen.scale);

                        screensGroup.add(overlay);
                        screen.userData.colorOverlay = overlay;
                    } else {
                        // Update existing overlay color
                        screen.userData.colorOverlay.material.color.setHex(color);
                        screen.userData.colorOverlay.visible = true;
                    }

                    // Hide volumetric particles
                    screen.visible = false;

                } else {
                    // For shapes: change material color (ShaderMaterial or MeshBasicMaterial)
                    if (screen.material.isShaderMaterial && screen.material.uniforms && screen.material.uniforms.baseColor) {
                        screen.material.uniforms.baseColor.value.setHex(color);
                    } else if (screen.material.color) {
                        screen.material.color.setHex(color);
                    }
                }
            } else {
                // Switch to video
                if (isVolumetric) {
                    // For volumetric screens: hide overlay, show particles
                    if (screen.userData.colorOverlay) {
                        screen.userData.colorOverlay.visible = false;
                    }
                    screen.visible = true;
                } else {
                    // For shapes: can't convert to video (not supported yet)
                    console.warn(`Écran ${num}: Conversion forme → vidéo non supportée`);
                }
            }

            updateScreenList();
            console.log(`Écran ${num}: Type changé en ${isColorSurface ? 'Couleur' : 'Vidéo'}`);
        }

        function setScreenColor(num, colorValue) {
            const screen = allScreens[num];
            if (!screen || !screen.userData.isColorSurface) return;

            saveState();

            screen.userData.color = colorValue;

            // Update color for volumetric overlay or direct material
            const isVolumetric = (num >= 1 && num <= 7);
            if (isVolumetric && screen.userData.colorOverlay) {
                screen.userData.colorOverlay.material.color.setHex(colorValue);
            } else if (screen.material) {
                // ShaderMaterial uses uniforms.baseColor, MeshBasicMaterial uses .color
                if (screen.material.isShaderMaterial && screen.material.uniforms && screen.material.uniforms.baseColor) {
                    screen.material.uniforms.baseColor.value.setHex(colorValue);
                } else if (screen.material.color) {
                    screen.material.color.setHex(colorValue);
                }
            }

            updateScreenList();
            console.log(`Écran ${num}: Couleur changée → #${colorValue.toString(16).padStart(6, '0')}`);
        }

        function onShiftChange(e) {
            if (!transformControls || !selectedScreen) return;

            const isShiftPressed = e.shiftKey;

            if (transformControls.mode === 'rotate') {
                // Rotation par pas de 15° (en radians)
                transformControls.setRotationSnap(isShiftPressed ? THREE.MathUtils.degToRad(15) : null);
            } else if (transformControls.mode === 'translate') {
                // Translation snapping de 1000 unités
                transformControls.setTranslationSnap(isShiftPressed ? 1000 : null);
            }
        }

        // Apply magnetism to rotation - snap to 0, 90, 180, 270 degrees when close
        function applyMagnetism(screen) {
            if (!screen) return;

            ['x', 'y', 'z'].forEach(axis => {
                const rotation = screen.rotation[axis];
                const normalized = ((rotation % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                for (let angle of MAGNETISM_ANGLES) {
                    if (Math.abs(normalized - angle) < MAGNETISM_THRESHOLD) {
                        screen.rotation[axis] = rotation - normalized + angle;
                        break;
                    }
                }
            });
        }

        // PROFESSIONAL UNDO/REDO SYSTEM - Complet et robuste
        function saveState() {
            const state = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            // Deep copy of ALL screen properties
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                state.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });

            undoHistory.push(state);
            console.log('💾 saveState() - État sauvegardé, écrans:', Object.keys(state.screens), 'historique:', undoHistory.length);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Clear redo history when new action is made
            redoHistory = [];
        }

        function undo() {
            console.log('🔄 undo() appelé - undoHistory.length:', undoHistory.length);

            if (undoHistory.length === 0) {
                console.log('❌ Rien à annuler (historique vide)');
                return;
            }

            // Save current state to redo BEFORE undoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            console.log('💾 État actuel sauvegardé dans redo, écrans:', Object.keys(currentState.screens));
            redoHistory.push(currentState);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }

            // Restore previous state
            const previousState = undoHistory.pop();
            console.log('⏮️ Restauration état précédent, écrans:', Object.keys(previousState.screens));

            // Restore all screens from previous state
            Object.keys(previousState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = previousState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (previousState.selectedScreen && allScreens[previousState.selectedScreen]) {
                selectScreen(previousState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('✅ Annulé (Ctrl+Z)');
        }

        function redo() {
            if (redoHistory.length === 0) {
                console.log('❌ Rien à refaire');
                return;
            }

            // Save current state to undo BEFORE redoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            undoHistory.push(currentState);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Restore next state
            const nextState = redoHistory.pop();

            // Restore all screens from next state
            Object.keys(nextState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = nextState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (nextState.selectedScreen && allScreens[nextState.selectedScreen]) {
                selectScreen(nextState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('✅ Refait (Ctrl+Shift+Z)');
        }

        function saveAllPositions() {
            console.log('');
            console.log('='.repeat(60));
            console.log('SAUVEGARDE DES POSITIONS - COPIER-COLLER DANS LE CODE');
            console.log('='.repeat(60));
            console.log('');

            Object.keys(allScreens).sort().forEach(num => {
                const screen = allScreens[num];
                const pos = screen.position;
                const rot = screen.rotation;
                const scale = screen.scale;

                console.log(`// Écran ${num}`);
                console.log(`screen${num}.position.set(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)});`);
                console.log(`screen${num}.rotation.set(${rot.x.toFixed(6)}, ${rot.y.toFixed(6)}, ${rot.z.toFixed(6)});`);
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    console.log(`screen${num}.scale.set(${scale.x.toFixed(3)}, ${scale.y.toFixed(3)}, ${scale.z.toFixed(3)});`);
                }
                console.log('');
            });

            console.log('='.repeat(60));
        }

        // Save positions to JSON file (Ctrl+S)
        function savePositionsToFile() {
            const data = {
                timestamp: new Date().toISOString(),
                screens: {}
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const screenData = {
                    position: {
                        x: parseFloat(screen.position.x.toFixed(3)),
                        y: parseFloat(screen.position.y.toFixed(3)),
                        z: parseFloat(screen.position.z.toFixed(3))
                    },
                    rotation: {
                        x: parseFloat(screen.rotation.x.toFixed(6)),
                        y: parseFloat(screen.rotation.y.toFixed(6)),
                        z: parseFloat(screen.rotation.z.toFixed(6))
                    },
                    scale: {
                        x: parseFloat(screen.scale.x.toFixed(3)),
                        y: parseFloat(screen.scale.y.toFixed(3)),
                        z: parseFloat(screen.scale.z.toFixed(3))
                    },
                    // Type and properties
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };

                // Save geometry dimensions if available
                if (screen.geometry && screen.geometry.parameters) {
                    const params = screen.geometry.parameters;
                    if (params.width !== undefined && params.height !== undefined) {
                        screenData.dimensions = {
                            width: parseFloat(params.width.toFixed(3)),
                            height: parseFloat(params.height.toFixed(3))
                        };
                    }
                    // Save geometry type
                    screenData.geometryType = screen.geometry.type || 'unknown';
                }

                data.screens[num] = screenData;
            });

            // Download as JSON file
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `screen-positions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('✅ Positions complètes (avec dimensions) sauvegardées dans le fichier JSON téléchargé');
            console.log(`📦 ${Object.keys(allScreens).length} écrans exportés`);
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            console.log('═══════════════════════════════════════════════════════');
            console.log('🔧 INIT() - Début de l\'initialisation');
            console.log('═══════════════════════════════════════════════════════');

            console.log('📦 Vérification THREE.js...');
            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded!');
                alert('THREE.js failed to load.');
                return;
            }
            console.log('✅ THREE.js chargé:', THREE.REVISION);

            console.log('🌍 Création de la scène...');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            console.log('✅ Scène créée');

            console.log('📦 Création du groupe d\'écrans...');
            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);
            console.log('✅ Groupe d\'écrans créé et ajouté à la scène');

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;
            console.log(`📐 Dimensions: ${canvasWidth}x${canvasHeight} (ratio: ${aspectRatio.toFixed(2)})`);

            console.log('📷 Création de la caméra...');
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            // Position de spawn au centre de la forme 11, à quelques unités au-dessus du sol
            // Sol de la forme 11: y = -111.773, on spawn à fpsCameraHeight
            camera.position.set(-274.876, fpsSettings.fpsCameraHeight, 112.79);
            console.log(`📍 Position caméra: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);

            // Orienter la caméra vers l'écran 7 puis tourner d'un quart de tour supplémentaire
            const lookAtTarget = new THREE.Vector3(599.938, fpsSettings.fpsCameraHeight, 112.546);
            camera.lookAt(lookAtTarget);
            console.log(`👀 Caméra regarde vers: (${lookAtTarget.x.toFixed(1)}, ${lookAtTarget.y.toFixed(1)}, ${lookAtTarget.z.toFixed(1)})`);

            // Calculer yaw et pitch initiaux basés sur l'orientation
            const direction = new THREE.Vector3();
            direction.subVectors(lookAtTarget, camera.position).normalize();
            cameraYaw = Math.atan2(direction.x, direction.z) + Math.PI; // +180° (quart de tour supplémentaire)
            cameraPitch = 0; // Vision horizontale
            console.log(`🎯 Orientation: yaw=${cameraYaw.toFixed(2)}, pitch=${cameraPitch.toFixed(2)}`);
            console.log('✅ Caméra configurée');

            console.log('🖼️ Création du renderer...');
            renderer = new THREE.WebGLRenderer({
                antialias: isMobile, // Enable MSAA on mobile for crisp edges
                alpha: true,
                powerPreference: 'high-performance'
            });
            // Mobile: allow native DPR (up to 3x) for sharp rendering
            // Desktop: cap at 2x (sufficient with larger screens)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 3 : 2));
            renderer.setSize(canvasWidth, canvasHeight);
            // PERFORMANCE: Shadows désactivés (coûteux, pas visibles sur ce projet)
            renderer.shadowMap.enabled = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            console.log('✅ Renderer créé et configuré');

            console.log('📎 Ajout du canvas au DOM...');
            const canvasContainer = document.getElementById('canvas');
            if (!canvasContainer) {
                console.error('❌ Element #canvas introuvable dans le DOM!');
                return;
            }
            canvasContainer.appendChild(renderer.domElement);
            console.log('✅ Canvas ajouté au DOM');

            console.log('💡 Ajout des lumières...');
            // Lumière ambiante
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // HemisphereLight — température couleur naturelle (ciel froid / sol chaud)
            const hemiLight = new THREE.HemisphereLight(
                0x1a1a2e,  // Sky: bleu-nuit très sombre
                0x0d0800,  // Ground: brun-noir chaud
                0.25       // Intensité subtile
            );
            scene.add(hemiLight);
            console.log('✅ Lumières ajoutées (ambient + hemisphere)');

            // FREE CAMERA: Pas d'OrbitControls, caméra complètement libre
            // Rotation avec clic droit + drag, mouvement avec flèches

            console.log('🎮 Configuration des TransformControls...');
            // TransformControls for manipulating screens
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('world'); // Use world space to avoid X/Y inversion
            scene.add(transformControls);
            console.log('✅ TransformControls configurés');

            // When transforming, disable free camera
            transformControls.addEventListener('dragging-changed', function(event) {
                freeCameraEnabled = !event.value;

                // Apply magnetism when releasing (end of drag)
                if (!event.value && selectedScreen && allScreens[selectedScreen]) {
                    applyMagnetism(allScreens[selectedScreen]);
                }
            });

            // Save state when starting to drag
            transformControls.addEventListener('mouseDown', function() {
                if (selectedScreen) {
                    saveState();
                }
            });

            // Handle scale modes: uniform, free, and resize
            let lastResizeScale = {x: 1, y: 1, z: 1};
            transformControls.addEventListener('objectChange', function() {
                if (transformControls.mode === 'scale' && selectedScreen && allScreens[selectedScreen]) {
                    const screen = allScreens[selectedScreen];

                    if (scaleMode === 'uniform') {
                        // UNIFORM mode: proportional scaling
                        const avgScale = (screen.scale.x + screen.scale.y + screen.scale.z) / 3;
                        screen.scale.set(avgScale, avgScale, avgScale);
                    } else if (scaleMode === 'resize') {
                        // RESIZE mode: change geometry dimensions, not scale
                        const currentScale = {x: screen.scale.x, y: screen.scale.y, z: screen.scale.z};

                        // Detect which axis changed
                        const deltaX = currentScale.x / lastResizeScale.x;
                        const deltaY = currentScale.y / lastResizeScale.y;
                        const deltaZ = currentScale.z / lastResizeScale.z;

                        if (deltaX !== 1 || deltaY !== 1 || deltaZ !== 1) {
                            // PlaneGeometry (color surfaces)
                            if (screen.geometry && screen.geometry.type === 'PlaneGeometry') {
                                // Get current geometry dimensions
                                const currentWidth = screen.geometry.parameters.width;
                                const currentHeight = screen.geometry.parameters.height;

                                // Calculate new dimensions based on scale change
                                const newWidth = currentWidth * deltaX;
                                const newHeight = currentHeight * deltaY;

                                // Recreate geometry with new dimensions
                                screen.geometry.dispose();
                                screen.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionné: ${Math.round(newWidth)} x ${Math.round(newHeight)}`);
                            }
                            // Volumetric screens (Points or InstancedMesh)
                            else if (screen.userData.positions || (screen.geometry && screen.geometry.attributes.position)) {
                                // Get positions array
                                let positions;
                                if (screen.userData.positions) {
                                    positions = screen.userData.positions;
                                } else {
                                    positions = screen.geometry.attributes.position.array;
                                }

                                // Multiply all positions by delta (resize without affecting depth spread)
                                for (let i = 0; i < positions.length; i += 3) {
                                    positions[i] *= deltaX;     // X
                                    positions[i + 1] *= deltaY; // Y
                                    positions[i + 2] *= deltaZ; // Z (depth)
                                }

                                // Update geometry based on type
                                if (screen.isPoints) {
                                    // Points: update position attribute
                                    screen.geometry.attributes.position.needsUpdate = true;
                                    screen.geometry.computeBoundingSphere();
                                } else if (screen.isInstancedMesh) {
                                    // InstancedMesh: update instance matrices
                                    const count = screen.count;
                                    for (let i = 0; i < count; i++) {
                                        reusableMatrix.setPosition(
                                            positions[i * 3],
                                            positions[i * 3 + 1],
                                            positions[i * 3 + 2]
                                        );
                                        screen.setMatrixAt(i, reusableMatrix);
                                    }
                                    screen.instanceMatrix.needsUpdate = true;
                                }

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionné (volumétrique): x${deltaX.toFixed(2)}, y${deltaY.toFixed(2)}, z${deltaZ.toFixed(2)}`);
                            }
                        }
                    }
                    // FREE mode: do nothing, allow non-uniform scaling
                }
            });

            // Free camera mouse controls (LEFT CLICK + drag)
            let isLeftMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.button === 0) { // Left click
                    isLeftMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', function(e) {
                if (e.button === 0) {
                    isLeftMouseDown = false;
                }
            });

            renderer.domElement.addEventListener('mousemove', function(e) {
                // PointerLock mode (FPS-style) - ONLY in Spectator mode
                if (isMouseLocked && freeCameraEnabled && fpsMode) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                }
                // Click+drag mode (Admin mode or fallback)
                else if (isLeftMouseDown && freeCameraEnabled && !selectedScreen) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            // PointerLock API setup for FPS-style controls (only in FPS mode)
            renderer.domElement.addEventListener('click', function() {
                if (!selectedScreen && freeCameraEnabled && fpsMode) {
                    renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                             renderer.domElement.mozRequestPointerLock ||
                                                             renderer.domElement.webkitRequestPointerLock;
                    renderer.domElement.requestPointerLock();
                }
            });

            // PointerLock change event
            document.addEventListener('pointerlockchange', lockChangeCallback, false);
            document.addEventListener('mozpointerlockchange', lockChangeCallback, false);
            document.addEventListener('webkitpointerlockchange', lockChangeCallback, false);

            function lockChangeCallback() {
                if (document.pointerLockElement === renderer.domElement ||
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    isMouseLocked = true;
                    console.log('🔒 PointerLock activé (ESC pour quitter)');
                } else {
                    isMouseLocked = false;
                    console.log('🔓 PointerLock désactivé');

                    // Pointer lock released (ESC) — do NOT auto-show pause screen
                    // Info screen is triggered by ALT key
                    if (fpsMode && !isPaused) {
                        console.log('🔓 PointerLock libéré — ALT pour les infos');
                    }
                }
            }

            // Mouse wheel movement - SCROLL LISSÉ (smooth scroll)
            // Utiliser window pour recevoir les wheel events même sans focus sur le canvas
            window.addEventListener('wheel', function(e) {
                e.preventDefault();

                // Bloquer le scroll si en pause
                if (isPaused) return;

                // Compteur de scroll pour cacher les instructions
                if (fpsMode && !instructionsHidden) {
                    scrollCount++;
                    checkHideInstructions();
                }

                // Accumuler la vitesse de scroll (au lieu d'appliquer directement)
                const scrollSpeed = fpsSettings.fpsScrollSpeed;
                const delta = e.deltaY > 0 ? 1 : -1;
                scrollVelocity += -delta * scrollSpeed * SCROLL_SMOOTHING;
            }, { passive: false });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            // Display controls in console
            console.log('═══════════════════════════════════════════════════════');
            console.log('🏛️  SIMULATION MUSÉE - CONTRÔLES');
            console.log('═══════════════════════════════════════════════════════');
            console.log('');
            console.log('🔄 BASCULER ENTRE MODES:');
            console.log('   B            - Basculer MODE FPS ↔ MODE NORMAL');
            console.log('   N            - Afficher/Cacher interfaces (cachées par défaut)');
            console.log('   F            - Afficher/Cacher FPS Settings (bas gauche)');
            console.log('   Ctrl+S       - Exporter paramètres FPS dans console');
            console.log('');
            console.log('📍 MODE NORMAL (par défaut - ADMIN):');
            console.log('   Flèches/WASD - Déplacement horizontal');
            console.log('   O/L          - Monter/Descendre librement');
            console.log('   Clic gauche  - Rotation caméra');
            console.log('   Molette      - Zoom');
            console.log('');
            console.log('🎮 MODE FPS (touche B - SPECTATEUR):');
            console.log('   WASD/Flèches - Se déplacer');
            console.log('   Shift        - Sprint (x2.5)');
            console.log('   Clic canvas  - PointerLock (ESC pour quitter)');
            console.log('   Gravité      - Marche sur sols (écrans 6, 10, 11)');
            console.log('   Collisions   - Activées avec murs');
            console.log('   H            - Afficher/Masquer hitbox (debug)');
            console.log('');
            console.log('📍 Spawn: Centre forme 11, quelques unités au-dessus');
            console.log('🙈 Interfaces cachées - Appuyez sur N pour afficher');
            console.log('');
            console.log('🖱️ MODE NORMAL ACTIVÉ - Caméra libre');
            console.log('   Appuyez sur B pour activer le mode FPS/Spectateur');
            console.log('═══════════════════════════════════════════════════════');

            console.log('');
            console.log('🚀 Démarrage de la boucle d\'animation...');
            animate();

            // Initialize DOM cache (avoid repeated getElementById in animate loop)
            fpsDOMCache.counter = document.getElementById('fps-counter');
            fpsDOMCache.value = fpsDOMCache.counter.querySelector('.fps-value');
            fpsDOMCache.gameInstructions = document.getElementById('game-instructions');

            console.log('═══════════════════════════════════════════════════════');
            console.log('✅ INIT() TERMINÉ AVEC SUCCÈS');
            console.log('═══════════════════════════════════════════════════════');
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Clear panoramic video so generate() uses this manually loaded video
                panoramicVideo = null;

                // Show preview (safe DOM construction)
                const previewEl = document.getElementById('preview');
                previewEl.textContent = '';
                const previewVideo = document.createElement('video');
                previewVideo.src = url;
                previewVideo.muted = true;
                previewVideo.loop = true;
                previewVideo.playsInline = true;
                previewVideo.style.cssText = 'max-width:100%;max-height:100%';
                previewEl.appendChild(previewVideo);
                previewEl.classList.add('loaded');
                previewVideo.play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 15;
                    document.getElementById('depth').value = 0.1;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.8;
                    document.getElementById('glow').value = 0.0;
                    document.getElementById('contrast').value = 1.1;
                    document.getElementById('saturation').value = 0.70;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');
                    updateValueDisplay('glow');
                    updateValueDisplay('contrast');
                    updateValueDisplay('saturation');

                    // Keep both load-section and controls visible
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    // Interfaces visibility managed by mode system (Spectator/Admin)
                }

                // Auto-play
                videoElement.play();

                // Apply automatiquement (générer les particules)
                console.log('🎬 Apply automatique après chargement vidéo...');
                generate(videoElement); // updateScreenList() is called at the end of this function

                // Double-check: réappliquer après un court délai pour être sûr
                setTimeout(() => {
                    console.log('🎬 Apply automatique (2ème passe)...');
                    generate(videoElement);
                }, 100);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        /**
         * Calcule les paramètres de densité adaptatifs (step + résolution dynamique)
         * Density 1-15 : Comportement classique (step variable, résolution fixe 800x450)
         * Density 16-30 : Résolution progressive + step=1 pour plus de détails
         */
        function calculateDensityParams(density, baseWidth, baseHeight) {
            baseWidth = baseWidth || 800;
            baseHeight = baseHeight || 450;
            let step, TARGET_WIDTH, TARGET_HEIGHT;

            if (density <= 15) {
                // Mode classique (backward compatible)
                step = Math.max(1, Math.floor(10 / density));
                TARGET_WIDTH = baseWidth;
                TARGET_HEIGHT = baseHeight;
            } else {
                // Mode haute densité : augmentation progressive de la résolution
                step = 1; // Step fixé à 1
                const resolutionMultiplier = 1 + ((density - 15) / 30); // 1.0 à 1.5x
                TARGET_WIDTH = Math.floor(baseWidth * resolutionMultiplier);
                TARGET_HEIGHT = Math.floor(baseHeight * resolutionMultiplier);
            }

            return { step, TARGET_WIDTH, TARGET_HEIGHT };
        }

        // ═══════════════════════════════════════════════════════
        // GPU VOLUMETRIC PIPELINE - Shaders + Material
        // Eliminates ALL per-frame CPU video analysis (getImageData)
        // Video texture is read directly on GPU by vertex/fragment shaders
        // ═══════════════════════════════════════════════════════

        const GPU_VOLUME_VERTEX_SHADER = `
            attribute vec2 particleUV;

            uniform sampler2D videoTexture;
            uniform float uDepthSpread;
            uniform float uPointSize;

            varying vec2 vUV;

            void main() {
                vUV = particleUV;

                // Read video pixel at this particle's UV
                vec4 texColor = texture2D(videoTexture, vUV);
                float luminance = (texColor.r + texColor.g + texColor.b) / 3.0;

                // Depth displacement: luminance -> z
                float depth = luminance * uDepthSpread;

                #ifdef USE_INSTANCING
                    // InstancedMesh: XY from instanceMatrix, Z from shader
                    vec4 instancePos = instanceMatrix * vec4(position, 1.0);
                    instancePos.z += depth;
                    vec4 mvPosition = modelViewMatrix * instancePos;
                #else
                    // Points: XY from position attribute, Z computed by shader
                    vec3 displaced = vec3(position.xy, depth);
                    vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
                #endif

                gl_Position = projectionMatrix * mvPosition;

                #ifndef USE_INSTANCING
                    gl_PointSize = uPointSize * (300.0 / max(1.0, -mvPosition.z));
                #endif
            }
        `;

        const GPU_VOLUME_FRAGMENT_SHADER = `
            uniform sampler2D videoTexture;
            uniform float uBrightness;
            uniform float uContrast;
            uniform float uSaturation;
            uniform float uGlowIntensity;
            uniform float uBlackThreshold;
            uniform float uDepthCullPower;

            #ifdef USE_MAP
                uniform sampler2D map;
            #endif

            varying vec2 vUV;

            void main() {
                vec4 texColor = texture2D(videoTexture, vUV);
                vec3 color = texColor.rgb;

                // Hide black pixels
                float maxChannel = max(color.r, max(color.g, color.b));
                if (maxChannel < uBlackThreshold) {
                    discard;
                }

                // Depth culling (approximate GPU version)
                if (uDepthCullPower > 0.0) {
                    float luminance = (color.r + color.g + color.b) / 3.0;
                    if (luminance < uDepthCullPower) {
                        discard;
                    }
                }

                // Apply contrast
                if (uContrast != 1.0) {
                    color = clamp((color - 0.5) * uContrast + 0.5, 0.0, 1.0);
                }

                // Apply saturation
                if (uSaturation != 1.0) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    color = clamp(mix(vec3(gray), color, uSaturation), 0.0, 1.0);
                }

                // Apply brightness
                color *= uBrightness;

                // Glow effect
                if (uGlowIntensity > 0.0) {
                    float lum = dot(color, vec3(0.299, 0.587, 0.114));
                    float emissive = pow(lum, 2.0) * uGlowIntensity;
                    color += emissive * color;
                }

                color = clamp(color, 0.0, 1.0);

                #ifdef USE_MAP
                    vec4 mapTexel = texture2D(map, gl_PointCoord);
                    if (mapTexel.a < 0.1) discard;
                    gl_FragColor = vec4(color, mapTexel.a);
                #else
                    gl_FragColor = vec4(color, 1.0);
                #endif
            }
        `;

        // Global reference to GPU materials for uniform updates
        let gpuVolumeMaterials = [];
        let gpuVideoTexture = null;
        let lastVideoTime = -1; // Track video frame changes for texture update optimization

        // Create GPU volumetric ShaderMaterial
        function createGPUVolumeMaterial(videoTexture, portionOffset, portionWidth, options) {
            options = options || {};
            const depthSpread = (options.depthSpread !== undefined) ? options.depthSpread : 0;
            const shapeTexture = options.shapeTexture || null;

            // Adjust vertex shader for panoramic portion
            const vertexShader = GPU_VOLUME_VERTEX_SHADER.replace(
                'vec4 texColor = texture2D(videoTexture, vUV);',
                `vec2 videoUV = vec2(vUV.x * ${portionWidth.toFixed(6)} + ${portionOffset.toFixed(6)}, vUV.y);
                vec4 texColor = texture2D(videoTexture, videoUV);`
            );

            const fragmentShader = GPU_VOLUME_FRAGMENT_SHADER.replace(
                'vec4 texColor = texture2D(videoTexture, vUV);',
                `vec2 videoUV = vec2(vUV.x * ${portionWidth.toFixed(6)} + ${portionOffset.toFixed(6)}, vUV.y);
                vec4 texColor = texture2D(videoTexture, videoUV);`
            );

            const defines = {};
            if (shapeTexture) defines.USE_MAP = '';

            const uniforms = {
                videoTexture: { value: videoTexture },
                uDepthSpread: { value: depthSpread },
                uPointSize: { value: pointSize },
                uBrightness: { value: brightness },
                uContrast: { value: contrast },
                uSaturation: { value: saturation },
                uGlowIntensity: { value: glowIntensity },
                uBlackThreshold: { value: hideBlack ? blackThreshold / 255.0 : 0.0 },
                uDepthCullPower: { value: enableDepthCull ? depthCullPower : 0.0 }
            };

            if (shapeTexture) {
                uniforms.map = { value: shapeTexture };
            }

            const mat = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: uniforms,
                defines: defines,
                transparent: true,
                depthWrite: true,
                depthTest: true
            });

            // Store reference for uniform updates
            gpuVolumeMaterials.push(mat);
            return mat;
        }

        // Update all GPU volume materials when sliders change
        function updateGPUVolumeUniforms() {
            const depthSpread = videoSamplingData ? videoSamplingData.TARGET_HEIGHT * videoSamplingData.scaleFactor * depthMultiplier : 0;
            for (const mat of gpuVolumeMaterials) {
                mat.uniforms.uDepthSpread.value = depthSpread;
                mat.uniforms.uPointSize.value = pointSize;
                mat.uniforms.uBrightness.value = brightness;
                mat.uniforms.uContrast.value = contrast;
                mat.uniforms.uSaturation.value = saturation;
                mat.uniforms.uGlowIntensity.value = glowIntensity;
                mat.uniforms.uBlackThreshold.value = hideBlack ? blackThreshold / 255.0 : 0.0;
                mat.uniforms.uDepthCullPower.value = enableDepthCull ? depthCullPower : 0.0;
            }
        }

        // Helper function: Extract particle data from video for multi-video system
        function createParticleDataFromVideo(video, customWidth, customHeight) {
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity, customWidth, customHeight);

            // Create or reuse sampling canvas
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // Cover behavior: scale video to fill canvas
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = TARGET_WIDTH / TARGET_HEIGHT;

            let sourceWidth, sourceHeight, offsetX, offsetY;
            if (videoAspect > targetAspect) {
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw frame and get pixel data
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            const positions = [];
            const colors = [];
            const initialZ = [];
            const uvs = []; // GPU pipeline: UV coordinates for each particle
            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            const rgbToLumFactor = 1 / (3 * 255);

            // Contrast/Saturation flags (use global variables)
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with safety cap
            let particleCount = 0;
            outerLoopMulti: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }

                        // Safety cap: prevent performance issues
                        if (particleCount >= MAX_PARTICLES) {
                            console.warn(`⚠️ Multi-video: Cap MAX_PARTICLES atteint (${MAX_PARTICLES.toLocaleString()})`);
                            break outerLoopMulti;
                        }

                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        uvs.push(x / TARGET_WIDTH, y / TARGET_HEIGHT);
                        particleCount++;

                        let rNorm = r * 0.00392156862745098;
                        let gNorm = g * 0.00392156862745098;
                        let bNorm = b * 0.00392156862745098;

                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // Apply depth culling if enabled
            if (enableDepthCull && depthCullPower > 0) {
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }
                const zRange = maxZ - minZ;
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;
                    for (let i = 0; i < initialZ.length; i++) {
                        if (initialZ[i] < cullThreshold) {
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            return { positions, colors, initialZ, uvs, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor };
        }

        // === PANORAMIC VIDEO SYSTEM ===
        // Single panoramic video (8640x1080) projected across 5 screens
        // Video divided into 9 equal columns (960px each):
        //   Screen 1: 2/9 (0-1920px), Screen 2: 2/9 (1920-3840px),
        //   Screen 3: 1/9 (3840-4800px, center), Screen 4: 2/9 (4800-6720px),
        //   Screen 5: 2/9 (6720-8640px)
        let panoramicVideo = null; // Single video for all screens
        const PANORAMIC_SCREENS = [1, 2, 3, 4, 5]; // Screens that show panoramic portions (excluding 6=floor)
        const PANORAMIC_WIDTH = 8640; // Total panoramic video width (9 x 960)
        const PANORAMIC_HEIGHT = 1080; // Panoramic video height

        // Portion mapping: offset and width as fractions of total video width
        const PANORAMIC_PORTIONS = [
            { offset: 0,     width: 2/9 },  // Screen 1: columns 0-1
            { offset: 2/9,   width: 2/9 },  // Screen 2: columns 2-3
            { offset: 4/9,   width: 1/9 },  // Screen 3: column 4 (center, narrower)
            { offset: 5/9,   width: 2/9 },  // Screen 4: columns 5-6
            { offset: 7/9,   width: 2/9 },  // Screen 5: columns 7-8
        ];

        // Helper function: Extract particle data from a PORTION of the panoramic video
        // offsetFraction: start position as fraction of video width (0.0 to 1.0)
        // widthFraction: width of portion as fraction of video width
        function createParticleDataFromVideoPortion(video, offsetFraction, widthFraction) {
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create sampling canvas
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // Calculate portion bounds in the panoramic video
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;

            // Source coordinates for this portion (fraction-based)
            const sourceX = offsetFraction * videoWidth;
            const sourceY = 0;
            const sourceWidth = widthFraction * videoWidth;
            const sourceHeight = videoHeight;

            // Draw only this portion of the video, scaled to fill the target canvas
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            const positions = [];
            const colors = [];
            const initialZ = [];
            const uvs = []; // GPU pipeline: UV coordinates for each particle
            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            const rgbToLumFactor = 1 / (3 * 255);

            // Contrast/Saturation flags
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with safety cap
            let particleCount = 0;
            outerLoopPanorama: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }

                        // Safety cap: prevent performance issues
                        if (particleCount >= MAX_PARTICLES) {
                            console.warn(`⚠️ Panorama portion ${portionIndex}: Cap MAX_PARTICLES atteint (${MAX_PARTICLES.toLocaleString()})`);
                            break outerLoopPanorama;
                        }

                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        uvs.push(x / TARGET_WIDTH, y / TARGET_HEIGHT);
                        particleCount++;

                        let rNorm = r * 0.00392156862745098;
                        let gNorm = g * 0.00392156862745098;
                        let bNorm = b * 0.00392156862745098;

                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // Apply depth culling if enabled
            if (enableDepthCull && depthCullPower > 0) {
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }
                const zRange = maxZ - minZ;
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;
                    for (let i = 0; i < initialZ.length; i++) {
                        if (initialZ[i] < cullThreshold) {
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            console.log(`🎬 Panorama portion offset=${(offsetFraction*100).toFixed(1)}% width=${(widthFraction*100).toFixed(1)}%: ${particleCount.toLocaleString()} particules`);
            return { positions, colors, initialZ, uvs, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor };
        }

        function generate(video) {
            console.log('═══════════════════════════════════════════════════════');
            console.log('🎬 GENERATE() APPELÉ');
            console.log('═══════════════════════════════════════════════════════');
            console.log('📦 allScreens avant:', Object.keys(allScreens || {}));
            console.log('🎥 Vidéo:', video ? `${video.videoWidth}x${video.videoHeight}` : 'null');

            // PANORAMIC MODE: Check if panoramic video is available
            const isPanoramicMode = panoramicVideo !== null;
            if (isPanoramicMode) {
                console.log('🌅 MODE PANORAMIQUE ACTIVÉ');
                console.log(`   Vidéo: ${panoramicVideo.videoWidth}x${panoramicVideo.videoHeight}`);
                console.log(`   9 colonnes de 960px = 8640px (2/9+2/9+1/9+2/9+2/9)`);
                video = panoramicVideo; // Use panoramic video as base
            } else if (screenVideos[1]) {
                console.log('🎬 Multi-video mode: Utilisation de video_01.mp4 pour génération');
                video = screenVideos[1];
            }

            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded in generate()!');
                alert('THREE.js not loaded.');
                return;
            }
            console.log('✅ THREE.js disponible');

            console.log('⚙️ Lecture des paramètres des sliders...');
            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value); // Plage ajustée 0-0.2 pour plus de précision
            depthSmoothing = parseFloat(document.getElementById('smoothing').value); // Seuil atténuation micro-mouvements
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            glowIntensity = parseFloat(document.getElementById('glow').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Adaptive density system: resolution increases with density > 15
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            } else {
                // Update canvas size if density changed (for density > 15)
                if (videoSamplingCanvas.width !== TARGET_WIDTH || videoSamplingCanvas.height !== TARGET_HEIGHT) {
                    videoSamplingCanvas.width = TARGET_WIDTH;
                    videoSamplingCanvas.height = TARGET_HEIGHT;
                }
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            let positions = [];
            let colors = [];
            let uvs = []; // GPU pipeline: UV coordinates
            let initialZ = [];
            let scaleFactor = 0.5;

            // === PANORAMIC MODE: Use portion-based generation for screen 1 ===
            if (isPanoramicMode) {
                console.log('🌅 Génération écran 1 depuis portion 0 (gauche) du panorama');
                const screen1Data = createParticleDataFromVideoPortion(panoramicVideo, PANORAMIC_PORTIONS[0].offset, PANORAMIC_PORTIONS[0].width);
                positions = screen1Data.positions;
                colors = screen1Data.colors;
                initialZ = screen1Data.initialZ;
                uvs = screen1Data.uvs;
                scaleFactor = screen1Data.scaleFactor;
                console.log(`   ✅ ${(positions.length / 3).toLocaleString()} particules générées`);
            } else {
            // === STANDARD MODE: Inline generation ===

            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            console.log('🔍 Analyse de création des particules:');
            console.log(`   🎚️ DENSITÉ demandée: ${particleDensity}X`);
            console.log(`   📏 step: ${step}, TARGET: ${TARGET_WIDTH}x${TARGET_HEIGHT}`);
            console.log(`   🔢 Pixels à scanner: ~${Math.floor((TARGET_WIDTH / step) * (TARGET_HEIGHT / step))}`);
            console.log(`   🛡️ Cap MAX_PARTICLES: ${MAX_PARTICLES.toLocaleString()}`);
            console.log(`   🎨 hideBlack: ${hideBlack}, blackThreshold: ${blackThreshold}`);
            console.log(`   🖼️ hideBackground: ${hideBackground}, bgThreshold: ${bgThreshold || 'N/A'}`);
            console.log(`   💡 minLuminance trouvée: ${minLuminance.toFixed(3)}`);

            let totalPixelsScanned = 0;
            let pixelsWithAlpha = 0;
            let pixelsFilteredByBlack = 0;
            let pixelsFilteredByBackground = 0;
            let pixelsAdded = 0;
            let capReached = false;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            outerLoop: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    totalPixelsScanned++;
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        pixelsWithAlpha++;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            pixelsFilteredByBlack++;
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                pixelsFilteredByBackground++;
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Safety cap: prevent performance issues
                        if (pixelsAdded >= MAX_PARTICLES) {
                            capReached = true;
                            break outerLoop;
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 — Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        uvs.push(x / TARGET_WIDTH, y / TARGET_HEIGHT);
                        pixelsAdded++;

                        // v1.3.1 — Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            console.log('📊 Résultats de la génération:');
            console.log(`   📏 Pixels scannés: ${totalPixelsScanned}`);
            console.log(`   ✅ Pixels avec alpha > 30: ${pixelsWithAlpha}`);
            console.log(`   ⚫ Filtrés par hideBlack: ${pixelsFilteredByBlack}`);
            console.log(`   🖼️ Filtrés par hideBackground: ${pixelsFilteredByBackground}`);
            console.log(`   ✨ Particules AJOUTÉES: ${pixelsAdded.toLocaleString()}`);
            console.log(`   📦 positions.length: ${positions.length} (${(positions.length / 3).toLocaleString()} particules)`);
            if (capReached) {
                console.warn(`   ⚠️ CAP ATTEINT! Limite MAX_PARTICLES (${MAX_PARTICLES.toLocaleString()}) appliquée pour éviter lag.`);
            }
            } // END: Standard mode (else block)

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < initialZ.length; i++) {
                        const z = initialZ[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // CRITICAL: Preserve custom shapes (>23) before clearing
            const customShapesToPreserve = {};
            if (allScreens) {
                Object.keys(allScreens).forEach(key => {
                    const num = parseInt(key);
                    if (num > 24) {
                        customShapesToPreserve[num] = allScreens[num];
                        // Remove from screensGroup temporarily to avoid disposal
                        if (allScreens[num].parent === screensGroup) {
                            screensGroup.remove(allScreens[num]);
                        }
                    }
                });
            }
            console.log('💾 Formes personnalisées préservées (>24):', Object.keys(customShapesToPreserve));

            // CRITICAL: Detach transform controls before clearing to avoid "object must be part of scene graph" error
            const wasScreenSelected = selectedScreen;
            if (transformControls && selectedScreen) {
                transformControls.detach();
            }

            console.log('🧹 Nettoyage du groupe d\'écrans...');
            // Clear group before adding new screens (only default screens 1-7 now)
            screensGroup.clear();
            console.log('✅ Groupe nettoyé');

            console.log(`🎨 Mode de rendu: ${is3DMode ? '3D (InstancedMesh)' : '2D (Points)'}`);
            console.log(`📊 Nombre de particules: ${positions.length / 3}`);

            // ═══ GPU VOLUMETRIC PIPELINE ═══
            // Create VideoTexture from panoramic or main video (auto-updates on GPU)
            gpuVolumeMaterials = []; // Reset material references
            if (!video || !video.videoWidth) {
                console.warn('⚠️ GPU Pipeline: vidéo invalide ou non prête, abandon');
                return;
            }
            if (!gpuVideoTexture || gpuVideoTexture.image !== video) {
                if (gpuVideoTexture) gpuVideoTexture.dispose(); // Clean up previous texture
                gpuVideoTexture = new THREE.VideoTexture(video);
                gpuVideoTexture.minFilter = THREE.LinearFilter;
                gpuVideoTexture.magFilter = THREE.LinearFilter;
                gpuVideoTexture.format = THREE.RGBFormat;
                gpuVideoTexture.flipY = false; // UVs are computed top-down (y/H), matching video pixel order
                lastVideoTime = -1; // Reset frame tracking for new video
            }

            const depthSpreadForShader = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            // Screen 1: portion 0/5 in panoramic mode, full video otherwise
            const screen1PortionOffset = isPanoramicMode ? PANORAMIC_PORTIONS[0].offset : 0.0;
            const screen1PortionWidth = isPanoramicMode ? PANORAMIC_PORTIONS[0].width : 1.0;

            if (is3DMode) {
                console.log('🔷 Création des particules en mode 3D (GPU pipeline)...');
                const count = positions.length / 3;
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                // GPU ShaderMaterial for screen 1
                material = createGPUVolumeMaterial(gpuVideoTexture, screen1PortionOffset, screen1PortionWidth, {
                    depthSpread: depthSpreadForShader
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                // Add instanced UV attribute for GPU shader
                const instanceUVs = new Float32Array(uvs);
                baseGeometry.setAttribute('particleUV', new THREE.InstancedBufferAttribute(instanceUVs, 2));

                // Set instance matrices (XY only, Z=0 — shader computes depth)
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        0 // Z set to 0, GPU shader computes depth from video luminance
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                }
                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.uvs = uvs;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Points with GPU ShaderMaterial
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));
                // GPU pipeline: add UV attribute
                geometry.setAttribute('particleUV', new THREE.Float32BufferAttribute(uvs, 2));

                const shapeTexture = getShapeTexture(currentShape);

                console.log('🔸 Création des particules en mode 2D (GPU pipeline)...');
                material = createGPUVolumeMaterial(gpuVideoTexture, screen1PortionOffset, screen1PortionWidth, {
                    depthSpread: depthSpreadForShader,
                    shapeTexture: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
                particles.userData.uvs = uvs;
                console.log('✅ Points GPU créés');
            }

            // Volumétrie unilatérale : les particules sombres restent à z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des écrans : z=0 invariant au DEPTH SPREAD

            // Écran 1 - Position de base
            particles.position.set(0, 0, 0);
            particles.rotation.set(0, 0, 0);
            particles.userData.screenNumber = 1;

            // Add first screen to group
            console.log('➕ Ajout des particules au screensGroup...');
            screensGroup.add(particles);
            console.log('✅ Particules ajoutées au groupe');

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // === ÉCRAN 2: Generate from panorama portion 1 or video_02.mp4 ===
            let particlesRight;
            let screen2Data = null;
            if (isPanoramicMode) {
                console.log('🌅 Génération écran 2 depuis portion 1 du panorama');
                screen2Data = createParticleDataFromVideoPortion(panoramicVideo, PANORAMIC_PORTIONS[1].offset, PANORAMIC_PORTIONS[1].width);
            } else if (screenVideos[2] && screenVideos[2] !== video) {
                console.log('🎬 Génération écran 2 depuis video_02.mp4');
                screen2Data = createParticleDataFromVideo(screenVideos[2]);
            }

            if (screen2Data) {
                // GPU material for screen 2 (panorama portion 2/9)
                const screen2Material = createGPUVolumeMaterial(gpuVideoTexture,
                    isPanoramicMode ? PANORAMIC_PORTIONS[1].offset : 0.0, isPanoramicMode ? PANORAMIC_PORTIONS[1].width : 1.0,
                    { depthSpread: depthSpreadForShader, shapeTexture: is3DMode ? null : getShapeTexture(currentShape) });

                if (is3DMode) {
                    const count2 = screen2Data.positions.length / 3;
                    let baseGeometry2;
                    const size = pointSize * 3;
                    switch(currentShape) {
                        case 'square': baseGeometry2 = new THREE.BoxGeometry(size, size, size); break;
                        case 'circle': baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6); break;
                        case 'diamond': baseGeometry2 = new THREE.OctahedronGeometry(size * 0.5); break;
                        case 'star': baseGeometry2 = new THREE.TetrahedronGeometry(size * 0.6); break;
                        default: baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    particlesRight = new THREE.InstancedMesh(baseGeometry2, screen2Material, count2);
                    particlesRight.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    // GPU: Add instanced UV attribute
                    if (screen2Data.uvs) {
                        baseGeometry2.setAttribute('particleUV', new THREE.InstancedBufferAttribute(new Float32Array(screen2Data.uvs), 2));
                    }

                    for (let i = 0; i < count2; i++) {
                        reusableMatrix.setPosition(screen2Data.positions[i * 3], screen2Data.positions[i * 3 + 1], 0);
                        particlesRight.setMatrixAt(i, reusableMatrix);
                    }
                    particlesRight.instanceMatrix.needsUpdate = true;
                    particlesRight.userData.initialZ = screen2Data.initialZ;
                    particlesRight.userData.positions = screen2Data.positions;
                    particlesRight.userData.is3D = true;
                } else {
                    const geometry2 = new THREE.BufferGeometry();
                    geometry2.setAttribute('position', new THREE.Float32BufferAttribute(screen2Data.positions, 3));
                    geometry2.setAttribute('color', new THREE.Float32BufferAttribute(screen2Data.colors, 3));
                    geometry2.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen2Data.initialZ, 1));
                    if (screen2Data.uvs) geometry2.setAttribute('particleUV', new THREE.Float32BufferAttribute(screen2Data.uvs, 2));

                    particlesRight = new THREE.Points(geometry2, screen2Material);
                }
            } else {
                // Fallback: Clone screen 1 if no video available
                console.log('🎬 Écran 2: Clonage de l\'écran 1 (fallback)');
                particlesRight = particles.clone();
                particlesRight.geometry = particles.geometry;
                particlesRight.material = particles.material;
            }

            // Écran 2 - Position de base
            particlesRight.position.set(400, 0, 0);
            particlesRight.rotation.set(0, 0, 0);
            particlesRight.userData.screenNumber = 2;

            // Add second screen to group
            screensGroup.add(particlesRight);

            // === ÉCRAN 6: SOL - Utilise floorVideo si disponible ===
            let screen3Positions = [];
            let screen3Colors = [];
            let screen3InitialZ = [];
            let screen3Uvs = [];

            const FLOOR_CANVAS_WIDTH = 800;
            const FLOOR_CANVAS_HEIGHT = 229; // Canvas au ratio exact du sol (800:229 ≈ 3.5:1)
            const floorHalfTargetY = 228.534 / 4; // Demi-hauteur pré-*2 pour correspondre à forme 10
            if (floorVideo && floorVideo.videoWidth > 0) {
                // Utiliser la vidéo du sol avec canvas au bon ratio (pas de crop nécessaire)
                console.log('🏠 Génération écran 6 (sol) depuis ecran_06.webm — canvas ' + FLOOR_CANVAS_WIDTH + '×' + FLOOR_CANVAS_HEIGHT);
                const floorData = createParticleDataFromVideo(floorVideo, FLOOR_CANVAS_WIDTH, FLOOR_CANVAS_HEIGHT);
                if (floorData) {
                    // Multiplier X et Y par 2 pour surface doublée (pas de crop Y — canvas déjà au bon ratio)
                    for (let i = 0; i < floorData.positions.length / 3; i++) {
                        screen3Positions.push(floorData.positions[i * 3] * 2, floorData.positions[i * 3 + 1] * 2, floorData.positions[i * 3 + 2]);
                        screen3Colors.push(floorData.colors[i * 3], floorData.colors[i * 3 + 1], floorData.colors[i * 3 + 2]);
                        screen3InitialZ.push(floorData.initialZ[i]);
                        if (floorData.uvs) screen3Uvs.push(floorData.uvs[i * 2], floorData.uvs[i * 2 + 1]);
                    }
                }
            } else {
                // Fallback: Filtrer les particules de l'écran 1
                console.log('🏠 Génération écran 6 (sol) depuis écran 1 (fallback)');

                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];

                    if (y >= -floorHalfTargetY && y <= floorHalfTargetY) {
                        screen3Positions.push(x * 2, y * 2, 0);
                        screen3Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                        screen3InitialZ.push(initialZ[i]);
                        if (uvs.length > 0) screen3Uvs.push(uvs[i * 2], uvs[i * 2 + 1]);
                    }
                }
            }

            // GPU material for screen 6 (sol) — uses screen 1's panoramic portion
            const screen6SolMaterial = createGPUVolumeMaterial(gpuVideoTexture,
                screen1PortionOffset, screen1PortionWidth,
                { depthSpread: depthSpreadForShader, shapeTexture: is3DMode ? null : getShapeTexture(currentShape) });

            let screen3;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du rectangle
                const count3 = screen3Positions.length / 3;
                let baseGeometry3;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry3 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry3 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry3 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen3 = new THREE.InstancedMesh(baseGeometry3, screen6SolMaterial, count3);
                screen3.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                // GPU: Add instanced UV attribute
                if (screen3Uvs.length > 0) {
                    baseGeometry3.setAttribute('particleUV', new THREE.InstancedBufferAttribute(new Float32Array(screen3Uvs), 2));
                }

                for (let i = 0; i < count3; i++) {
                    reusableMatrix.setPosition(
                        screen3Positions[i * 3],
                        screen3Positions[i * 3 + 1],
                        0 // Z=0, GPU shader computes depth from video luminance
                    );
                    screen3.setMatrixAt(i, reusableMatrix);
                }

                screen3.instanceMatrix.needsUpdate = true;
                screen3.userData.initialZ = screen3InitialZ;
                screen3.userData.positions = screen3Positions;
                screen3.userData.is3D = true;
                screen3.userData.screenNumber = 6; // Sol - anciennement 5 → 6

            } else {
                // Mode 2D : créer Points avec les particules du rectangle
                const geometry3 = new THREE.BufferGeometry();
                geometry3.setAttribute('position', new THREE.Float32BufferAttribute(screen3Positions, 3));
                geometry3.setAttribute('color', new THREE.Float32BufferAttribute(screen3Colors, 3));
                geometry3.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen3InitialZ, 1));
                if (screen3Uvs.length > 0) geometry3.setAttribute('particleUV', new THREE.Float32BufferAttribute(screen3Uvs, 2));

                screen3 = new THREE.Points(geometry3, screen6SolMaterial);
                screen3.userData.screenNumber = 6; // Sol - anciennement 5 → 6
            }

            // Position et orientation de base
            screen3.position.set(200.858, -112.500, 112.500);
            screen3.rotation.set(1.570796, 0.000000, 0.000000); // 90° sur X
            screen3.scale.set(1, 1, 1); // Pas de scale (particules déjà croppées en hauteur)

            screensGroup.add(screen3);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // === ÉCRAN 5 (allScreens[5]): Generate from panorama portion 4 or video_05.mp4 ===
            let wallOppA;
            let screen5Data = null;
            if (isPanoramicMode) {
                console.log('🌅 Génération écran 5 depuis portion 4 (droite) du panorama');
                screen5Data = createParticleDataFromVideoPortion(panoramicVideo, PANORAMIC_PORTIONS[4].offset, PANORAMIC_PORTIONS[4].width);
            } else if (screenVideos[5]) {
                console.log('🎬 Génération écran 5 depuis video_05.mp4');
                screen5Data = createParticleDataFromVideo(screenVideos[5]);
            }

            if (screen5Data) {
                // GPU material for screen 5 (panorama portion 2/9)
                const screen5Material = createGPUVolumeMaterial(gpuVideoTexture,
                    isPanoramicMode ? PANORAMIC_PORTIONS[4].offset : 0.0, isPanoramicMode ? PANORAMIC_PORTIONS[4].width : 1.0,
                    { depthSpread: depthSpreadForShader, shapeTexture: is3DMode ? null : getShapeTexture(currentShape) });

                if (is3DMode) {
                    const count5 = screen5Data.positions.length / 3;
                    let baseGeometry5;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry5 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry5 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry5 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppA = new THREE.InstancedMesh(baseGeometry5, screen5Material, count5);
                    wallOppA.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    // GPU: Add instanced UV attribute
                    if (screen5Data.uvs) {
                        baseGeometry5.setAttribute('particleUV', new THREE.InstancedBufferAttribute(new Float32Array(screen5Data.uvs), 2));
                    }

                    for (let i = 0; i < count5; i++) {
                        reusableMatrix.setPosition(screen5Data.positions[i * 3], screen5Data.positions[i * 3 + 1], 0);
                        wallOppA.setMatrixAt(i, reusableMatrix);
                    }

                    wallOppA.instanceMatrix.needsUpdate = true;
                    wallOppA.userData.initialZ = screen5Data.initialZ;
                    wallOppA.userData.positions = screen5Data.positions;
                    wallOppA.userData.is3D = true;
                    wallOppA.userData.screenNumber = 5; // Mur droit - anciennement 6 → 5
                } else {
                    const geometry5 = new THREE.BufferGeometry();
                    geometry5.setAttribute('position', new THREE.Float32BufferAttribute(screen5Data.positions, 3));
                    geometry5.setAttribute('color', new THREE.Float32BufferAttribute(screen5Data.colors, 3));
                    geometry5.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen5Data.initialZ, 1));
                    if (screen5Data.uvs) geometry5.setAttribute('particleUV', new THREE.Float32BufferAttribute(screen5Data.uvs, 2));

                    wallOppA = new THREE.Points(geometry5, screen5Material);
                }
            } else {
                // Fallback: Clone screen 1 if no video available
                console.log('🎬 Écran 5: Clonage de l\'écran 1 (fallback)');
                wallOppA = particles.clone();
                wallOppA.geometry = particles.geometry;
                wallOppA.material = particles.material;
            }

            // Écran 5 - Position de base
            wallOppA.position.set(0, 0, 225);
            wallOppA.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppA.userData.screenNumber) wallOppA.userData.screenNumber = 5; // Mur droit - anciennement 6 → 5

            screensGroup.add(wallOppA);

            // === ÉCRAN 6 (allScreens[4]): Generate from panorama portion 3 or video_06.mp4 ===
            let wallOppB;
            let screen6Data = null;
            if (isPanoramicMode) {
                console.log('🌅 Génération écran 4 depuis portion 3 du panorama');
                screen6Data = createParticleDataFromVideoPortion(panoramicVideo, PANORAMIC_PORTIONS[3].offset, PANORAMIC_PORTIONS[3].width);
            } else if (screenVideos[4]) {
                console.log('🎬 Génération écran 4 depuis ecran4.mp4');
                screen6Data = createParticleDataFromVideo(screenVideos[4]);
            }

            if (screen6Data) {
                // GPU material for screen 4 (panorama portion 2/9)
                const screen4Material = createGPUVolumeMaterial(gpuVideoTexture,
                    isPanoramicMode ? PANORAMIC_PORTIONS[3].offset : 0.0, isPanoramicMode ? PANORAMIC_PORTIONS[3].width : 1.0,
                    { depthSpread: depthSpreadForShader, shapeTexture: is3DMode ? null : getShapeTexture(currentShape) });

                if (is3DMode) {
                    const count6 = screen6Data.positions.length / 3;
                    let baseGeometry6;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry6 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry6 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry6 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppB = new THREE.InstancedMesh(baseGeometry6, screen4Material, count6);
                    wallOppB.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    // GPU: Add instanced UV attribute
                    if (screen6Data.uvs) {
                        baseGeometry6.setAttribute('particleUV', new THREE.InstancedBufferAttribute(new Float32Array(screen6Data.uvs), 2));
                    }

                    for (let i = 0; i < count6; i++) {
                        reusableMatrix.setPosition(screen6Data.positions[i * 3], screen6Data.positions[i * 3 + 1], 0);
                        wallOppB.setMatrixAt(i, reusableMatrix);
                    }

                    wallOppB.instanceMatrix.needsUpdate = true;
                    wallOppB.userData.initialZ = screen6Data.initialZ;
                    wallOppB.userData.positions = screen6Data.positions;
                    wallOppB.userData.is3D = true;
                    wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4
                } else {
                    const geometry6 = new THREE.BufferGeometry();
                    geometry6.setAttribute('position', new THREE.Float32BufferAttribute(screen6Data.positions, 3));
                    geometry6.setAttribute('color', new THREE.Float32BufferAttribute(screen6Data.colors, 3));
                    geometry6.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen6Data.initialZ, 1));
                    if (screen6Data.uvs) geometry6.setAttribute('particleUV', new THREE.Float32BufferAttribute(screen6Data.uvs, 2));

                    wallOppB = new THREE.Points(geometry6, screen4Material);
                }
            } else {
                // Fallback: Clone screen 2 if no video available
                console.log('🎬 Écran 4: Clonage de l\'écran 2 (fallback)');
                wallOppB = particlesRight.clone();
                wallOppB.geometry = particles.geometry;
                wallOppB.material = particles.material;
            }

            // Écran 4 (anciennement 6) - Position de base
            wallOppB.position.set(400, 0, 225);
            wallOppB.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppB.userData.screenNumber) wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4

            screensGroup.add(wallOppB);

            // === ÉCRAN 7 (allScreens[3]): Generate from panorama portion 2 or video_07.mp4 ===
            let screen7Positions, screen7Colors, screen7InitialZ, screen7Uvs;
            let useVideo7 = false;

            if (isPanoramicMode) {
                // Use panorama portion 2 (middle)
                console.log('🌅 Génération écran 3 depuis portion 2 (centre) du panorama');
                const screen7Data = createParticleDataFromVideoPortion(panoramicVideo, PANORAMIC_PORTIONS[2].offset, PANORAMIC_PORTIONS[2].width);
                screen7Positions = screen7Data.positions;
                screen7Colors = screen7Data.colors;
                screen7InitialZ = screen7Data.initialZ;
                screen7Uvs = screen7Data.uvs || null;
                useVideo7 = true;
            } else if (screenVideos[3]) {
                // Use ecran3.mp4
                console.log('🎬 Génération écran 3 depuis ecran3.mp4');
                const screen7Data = createParticleDataFromVideo(screenVideos[3]);
                screen7Positions = screen7Data.positions;
                screen7Colors = screen7Data.colors;
                screen7InitialZ = screen7Data.initialZ;
                screen7Uvs = screen7Data.uvs || null;
                useVideo7 = true;
            } else {
                // Fallback: Filter from screen 1 video to create square
                console.log('🎬 Écran 3: Filtrage depuis l\'écran 1 (fallback)');
                screen7Positions = [];
                screen7Colors = [];
                screen7InitialZ = [];

                // Réutilise halfH déjà déclaré pour l'écran 3 (screenH / 2 = 112.5)
                // Filtrer les particules pour faire un carré : X et Y entre -halfH et +halfH
                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];

                    // Carré centré : -112.5 <= X <= 112.5 ET -112.5 <= Y <= 112.5
                    if (x >= -halfH && x <= halfH && y >= -halfH && y <= halfH) {
                        screen7Positions.push(x, y, z);
                        screen7Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                        screen7InitialZ.push(initialZ[i]);
                    }
                }
            }

            // Screen 3: scale to fit 225-unit width instead of cropping
            // Particles span [-200, 200] in local X (from 800px canvas * 0.5 scaleFactor)
            // Screen 3 physical width = 225 units, so scale X by 112.5/200 = 0.5625
            // This preserves all particles and their UVs (0-1 range) for correct GPU shader mapping
            const screen3ScaleX = isPanoramicMode ? (112.5 / 200) : 1.0;
            if (!isPanoramicMode) {
                // Non-panoramic fallback: still crop for backward compatibility
                const croppedPositions = [];
                const croppedColors = [];
                const croppedInitialZ = [];
                const croppedUvs = [];
                const cropHalfWidth = 112.5;
                for (let i = 0; i < screen7Positions.length / 3; i++) {
                    const x = screen7Positions[i * 3];
                    if (x >= -cropHalfWidth && x <= cropHalfWidth) {
                        croppedPositions.push(screen7Positions[i * 3], screen7Positions[i * 3 + 1], screen7Positions[i * 3 + 2]);
                        croppedColors.push(screen7Colors[i * 3], screen7Colors[i * 3 + 1], screen7Colors[i * 3 + 2]);
                        croppedInitialZ.push(screen7InitialZ[i]);
                        if (screen7Uvs) croppedUvs.push(screen7Uvs[i * 2], screen7Uvs[i * 2 + 1]);
                    }
                }
                screen7Positions = croppedPositions;
                screen7Colors = croppedColors;
                screen7InitialZ = croppedInitialZ;
                screen7Uvs = croppedUvs.length > 0 ? croppedUvs : null;
                console.log(`✂️ Écran 3 croppé: aligné écrans 2-4 (X: [-112.5, 112.5], ${croppedPositions.length / 3} particules)`);
            } else {
                console.log(`📐 Écran 3 panorama: scale X=${screen3ScaleX.toFixed(4)} (${screen7Positions.length / 3} particules)`);
            }

            // GPU material for screen 3 (panorama portion 4/9)
            const screen3Material = createGPUVolumeMaterial(gpuVideoTexture,
                isPanoramicMode ? PANORAMIC_PORTIONS[2].offset : 0.0, isPanoramicMode ? PANORAMIC_PORTIONS[2].width : 1.0,
                { depthSpread: depthSpreadForShader, shapeTexture: is3DMode ? null : getShapeTexture(currentShape) });

            let screen7;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du carré
                const count7 = screen7Positions.length / 3;
                let baseGeometry7;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry7 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry7 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry7 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen7 = new THREE.InstancedMesh(baseGeometry7, screen3Material, count7);
                screen7.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                // GPU: Add instanced UV attribute
                if (screen7Uvs) {
                    baseGeometry7.setAttribute('particleUV', new THREE.InstancedBufferAttribute(new Float32Array(screen7Uvs), 2));
                }

                for (let i = 0; i < count7; i++) {
                    reusableMatrix.setPosition(screen7Positions[i * 3], screen7Positions[i * 3 + 1], 0);
                    screen7.setMatrixAt(i, reusableMatrix);
                }

                screen7.instanceMatrix.needsUpdate = true;
                screen7.userData.initialZ = screen7InitialZ;
                screen7.userData.positions = screen7Positions;
                screen7.userData.is3D = true;
                screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            } else {
                // Mode 2D : créer Points avec les particules du carré
                const geometry7 = new THREE.BufferGeometry();
                geometry7.setAttribute('position', new THREE.Float32BufferAttribute(screen7Positions, 3));
                geometry7.setAttribute('color', new THREE.Float32BufferAttribute(screen7Colors, 3));
                geometry7.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen7InitialZ, 1));
                if (screen7Uvs) geometry7.setAttribute('particleUV', new THREE.Float32BufferAttribute(screen7Uvs, 2));

                screen7 = new THREE.Points(geometry7, screen3Material);
            }

            // Position et orientation de base (coordonnées ajustées par l'utilisateur)
            screen7.position.set(599.938, -0.064, 112.5); // Centré entre écran 2 (Z=0) et écran 4 (Z=225)
            screen7.rotation.set(0, -1.570796, 0); // -90° en Y
            screen7.scale.set(screen3ScaleX, 1, 1); // Scale X pour ajuster la largeur (panorama: 0.5625, sinon: 1)
            if (!screen7.userData.screenNumber) screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            screensGroup.add(screen7);

            // ======================
            // ============================================================
            // HELPER: Matériau avec shader subtil pour MURS-FORMES uniquement
            // (gradient + dithering - amélioration qualité visuelle)
            // ============================================================
            function createWallFormMaterial(baseColorHex, gradientStrength = 0.03) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        baseColor: { value: new THREE.Color(baseColorHex) },
                        gradientStrength: { value: gradientStrength }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 baseColor;
                        uniform float gradientStrength;
                        varying vec2 vUv;

                        // Dithering Bayer 4x4 ultra subtil
                        float bayerDither4x4(vec2 screenPos) {
                            int x = int(mod(screenPos.x, 4.0));
                            int y = int(mod(screenPos.y, 4.0));
                            int index = x + y * 4;
                            float bayer[16];
                            bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                            bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                            bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                            bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                            return bayer[index];
                        }

                        void main() {
                            // Gradient vertical subtil (du haut vers le bas)
                            float gradient = vUv.y * gradientStrength;

                            // Dithering ultra fin (opacité 0.006)
                            float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                            // Couleur finale
                            vec3 finalColor = baseColor + vec3(gradient + dither);
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    side: THREE.DoubleSide
                });
            }

            // SCREEN 4: Custom shape (color surface) - FORME 7 (plafond)
            // ======================
            const width4 = 964.573;
            const height4 = 228.534;
            const geometry4 = new THREE.PlaneGeometry(width4, height4);
            const material4 = new THREE.MeshBasicMaterial({ color: 0x060606, side: THREE.DoubleSide });
            const screen4 = new THREE.Mesh(geometry4, material4);

            // Position et orientation (from user JSON)
            screen4.position.set(132.131, 109.022, 112.031);
            screen4.rotation.set(1.570796, 0, 0); // 90° on X
            screen4.scale.set(1, 1, 1);

            // Mark as color surface
            screen4.userData.screenNumber = 7;
            screen4.userData.isColorSurface = true;
            screen4.userData.color = 0x060606;

            screensGroup.add(screen4);

            // ======================
            // SCREEN 8: Custom shape (color surface) - beige/pink panel
            // ======================
            const width8 = 983.983;
            const height8 = 231.29;
            const geometry8 = new THREE.PlaneGeometry(width8, height8);
            const material8 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen8 = new THREE.Mesh(geometry8, material8);

            // Position et orientation (from user JSON)
            screen8.position.set(137.097, -6.589, -0.072);
            screen8.rotation.set(0, 0, 0);
            screen8.scale.set(1, 1, 1);

            // Mark as color surface
            screen8.userData.screenNumber = 8;
            screen8.userData.isColorSurface = true;
            screen8.userData.color = 0x000000;

            screensGroup.add(screen8);

            // ======================
            // SCREEN 9: Custom shape (color surface) - gray panel back
            // ======================
            const width9 = 983.983;
            const height9 = 231.29;
            const geometry9 = new THREE.PlaneGeometry(width9, height9);
            const material9 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen9 = new THREE.Mesh(geometry9, material9);
            screen9.position.set(137.097, -6.589, 226.306);
            screen9.rotation.set(0, 0, 0);
            screen9.scale.set(1, 1, 1);
            screen9.userData.screenNumber = 9;
            screen9.userData.isColorSurface = true;
            screen9.userData.color = 0x000000;
            screensGroup.add(screen9);

            // ======================
            // SCREEN 10: Custom shape (glassmorphisme) - transparent glass floor panel
            // ======================
            const width10 = 804.246;
            const height10 = 228.534;
            const geometry10 = new THREE.PlaneGeometry(width10, height10);
            const material10 = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: fpsSettings.glassMetalness,
                roughness: fpsSettings.glassRoughness,
                opacity: fpsSettings.glassOpacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 1.0
            });
            const screen10 = new THREE.Mesh(geometry10, material10);
            screen10.position.set(205.307, -111.773, 112.611);
            screen10.rotation.set(1.570796, 0, 0);
            screen10.scale.set(1, 1, 1);
            screen10.userData.screenNumber = 10;
            screen10.userData.isColorSurface = true;
            screen10.userData.isGlass = true; // Marquer comme verre
            screen10.userData.color = 0xaaaaaa;
            screen10.visible = true; // Écran 10 visible
            screen10.renderOrder = 1000; // Rendre après les objets opaques
            screensGroup.add(screen10);

            // ======================
            // SCREEN 11: Custom shape (color surface) - dark green small panel (sol avec ombre fake)
            // ======================
            const width11 = 155.945;
            const height11 = 228.534;
            const geometry11 = new THREE.PlaneGeometry(width11, height11);

            // Shader spécial pour sol avec ombre fake mur-sol (dégradé radial subtil)
            const material11 = new THREE.ShaderMaterial({
                uniforms: {
                    baseColor: { value: new THREE.Color(0x080808) },
                    gradientStrength: { value: 0.03 },
                    shadowStrength: { value: 0.025 } // 2.5% assombrissement aux bords
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float gradientStrength;
                    uniform float shadowStrength;
                    varying vec2 vUv;

                    float bayerDither4x4(vec2 screenPos) {
                        int x = int(mod(screenPos.x, 4.0));
                        int y = int(mod(screenPos.y, 4.0));
                        int index = x + y * 4;
                        float bayer[16];
                        bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                        bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                        bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                        bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                        return bayer[index];
                    }

                    void main() {
                        // Gradient vertical
                        float gradient = vUv.y * gradientStrength;

                        // Ombre fake mur-sol : dégradé radial depuis les bords
                        vec2 center = vec2(0.5, 0.5);
                        float distFromCenter = distance(vUv, center);
                        float shadow = smoothstep(0.3, 0.7, distFromCenter) * shadowStrength;

                        // Dithering
                        float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                        // Couleur finale (assombrie aux bords)
                        vec3 finalColor = baseColor + vec3(gradient + dither) - vec3(shadow);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const screen11 = new THREE.Mesh(geometry11, material11);
            screen11.position.set(-274.876, -111.773, 112.79);
            screen11.rotation.set(1.570796, 0, 0);
            screen11.scale.set(1, 1, 1);
            screen11.userData.screenNumber = 11;
            screen11.userData.isColorSurface = true;
            screen11.userData.color = 0x080808;
            screensGroup.add(screen11);

            // ======================
            // SCREEN 12: Custom shape (color surface) - dark green vertical panel
            // ======================
            const width12 = 235.076;
            const height12 = 231.29;
            const geometry12 = new THREE.PlaneGeometry(width12, height12);
            const material12 = createWallFormMaterial(0x999999); // Gris clair
            const screen12 = new THREE.Mesh(geometry12, material12);
            screen12.position.set(-348.048, -6.589, 115.234);
            screen12.rotation.set(0, 1.570796, 0);
            screen12.scale.set(1, 1, 1);
            screen12.userData.screenNumber = 12;
            screen12.userData.isColorSurface = true;
            screen12.userData.color = 0x999999;
            screensGroup.add(screen12);

            // ======================
            // SCREEN 14: Custom shape (color surface) - FORME 13 (couleur unie presque noire)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width14 = 96.102;
            const height14 = 231.269; // Ajusté pour bas = -111.773
            const geometry14 = new THREE.PlaneGeometry(width14, height14);
            const material14 = new THREE.MeshBasicMaterial({ color: 0x060606, side: THREE.DoubleSide });
            const screen14 = new THREE.Mesh(geometry14, material14);
            screen14.position.set(-197.183, 3.862, 178.672); // Y ajusté
            screen14.rotation.set(0, 1.570796, 0);
            screen14.scale.set(1, 1, 1);
            screen14.userData.screenNumber = 13; // Renuméroté: 14 → 13
            screen14.userData.isColorSurface = true;
            screen14.userData.color = 0x060606;
            screensGroup.add(screen14);

            // ======================
            // SCREEN 15: Custom shape (color surface) - FORME 14 (couleur unie presque noire)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width15 = 96.102;
            const height15 = 231.187; // Ajusté pour bas = -111.773
            const geometry15 = new THREE.PlaneGeometry(width15, height15);
            const material15 = new THREE.MeshBasicMaterial({ color: 0x060606, side: THREE.DoubleSide });
            const screen15 = new THREE.Mesh(geometry15, material15);
            screen15.position.set(-197.107, 3.821, 47.768); // Y ajusté
            screen15.rotation.set(0, 1.570796, 0);
            screen15.scale.set(1, 1, 1);
            screen15.userData.screenNumber = 14; // Renuméroté: 15 → 14
            screen15.userData.isColorSurface = true;
            screen15.userData.color = 0x060606;
            screensGroup.add(screen15);

            // ======================
            // SCREEN 16: Custom shape (color surface) - FORME 15 (couleur unie presque noire)
            // ======================
            const width16 = 163.506;
            const height16 = 239.079;
            const geometry16 = new THREE.PlaneGeometry(width16, height16);
            const material16 = new THREE.MeshBasicMaterial({ color: 0x060606, side: THREE.DoubleSide });
            const screen16 = new THREE.Mesh(geometry16, material16);
            screen16.position.set(-197.04, 27.158, 110.291);
            screen16.rotation.set(1.570796, 1.570796, 0);
            screen16.scale.set(1, 1, 1);
            screen16.userData.screenNumber = 15; // Renuméroté: 16 → 15
            screen16.userData.isColorSurface = true;
            screen16.userData.color = 0x060606;
            screensGroup.add(screen16);

            // ======================
            // SCREEN 17: Custom shape (color surface) - gray thin panel (FORME 16)
            // Config mise à jour selon spécifications
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width17 = 96.102;
            const height17 = 221.302; // Ajusté: ancien haut (109.529) - sol (-111.773)
            const geometry17 = new THREE.PlaneGeometry(width17, height17);
            const material17 = createWallFormMaterial(0x070707);
            const screen17 = new THREE.Mesh(geometry17, material17);
            screen17.position.set(-200.492, -1.122, 47.776);
            screen17.rotation.set(0, 1.570796, 0);
            screen17.scale.set(1, 1, 1);
            screen17.userData.screenNumber = 16; // Renuméroté: 17 → 16
            screen17.userData.isColorSurface = true;
            screen17.userData.color = 0x070707;
            screensGroup.add(screen17);

            // ======================
            // SCREEN 18: Custom shape (color surface) - gray thin panel (FORME 17)
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width18 = 96.102;
            const height18 = 226.947; // Ajusté: ancien haut (115.174) - sol (-111.773)
            const geometry18 = new THREE.PlaneGeometry(width18, height18);
            const material18 = createWallFormMaterial(0x070707);
            const screen18 = new THREE.Mesh(geometry18, material18);
            screen18.position.set(-200.734, 1.7, 178.493);
            screen18.rotation.set(0, 1.570796, 0);
            screen18.scale.set(1, 1, 1);
            screen18.userData.screenNumber = 17; // Renuméroté: 18 → 17
            screen18.userData.isColorSurface = true;
            screen18.userData.color = 0x070707;
            screensGroup.add(screen18);

            // ======================
            // SCREEN 21: Custom shape (color surface) - gray horizontal panel (FORME 18)
            // ======================
            const width21 = 163.506;
            const height21 = 239.079;
            const geometry21 = new THREE.PlaneGeometry(width21, height21);
            const material21 = createWallFormMaterial(0x999999); // Gris clair
            const screen21 = new THREE.Mesh(geometry21, material21);
            screen21.position.set(-200.871, 27.391, 110.392);
            screen21.rotation.set(1.570796, 1.570796, 0);
            screen21.scale.set(1, 1, 1);
            screen21.userData.screenNumber = 18; // Renuméroté: 21 → 18 (après suppression forme 18)
            screen21.userData.isColorSurface = true;
            screen21.userData.color = 0x999999;
            screensGroup.add(screen21);

            // ======================
            // FORME 19: Gray floor panel (sol gris)
            // ======================
            const width19 = 163.506;
            const height19 = 239.079;
            const geometry19 = new THREE.PlaneGeometry(width19, height19);
            const material19 = createWallFormMaterial(0x060606); // Même couleur que forme 22
            const screen19 = new THREE.Mesh(geometry19, material19);
            screen19.position.set(-278.532, -54.6, 110.305);
            screen19.rotation.set(1.570796, 0, 0);
            screen19.scale.set(1, 1, 1);
            screen19.userData.screenNumber = 19;
            screen19.userData.isColorSurface = true;
            screen19.userData.color = 0x060606;
            screensGroup.add(screen19);

            // ======================
            // FORME 20: Gray thin vertical panel 1
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width20 = 3.246;
            const height20 = 131.518; // Ajusté: ancien haut (19.745) - sol (-111.773)
            const geometry20 = new THREE.PlaneGeometry(width20, height20);
            const material20 = createWallFormMaterial(0x070707);
            const screen20 = new THREE.Mesh(geometry20, material20);
            screen20.position.set(-198.905, -46.014, 95.8);
            screen20.rotation.set(-3.141593, 0, -3.141593);
            screen20.scale.set(1, 1, 1);
            screen20.userData.screenNumber = 20;
            screen20.userData.isColorSurface = true;
            screen20.userData.color = 0x070707;
            screensGroup.add(screen20);

            // ======================
            // FORME 21: Gray thin vertical panel 2
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width21b = 3.576;
            const height21b = 131.518; // Ajusté: ancien haut (19.745) - sol (-111.773)
            const geometry21b = new THREE.PlaneGeometry(width21b, height21b);
            const material21b = createWallFormMaterial(0x070707);
            const screen21b = new THREE.Mesh(geometry21b, material21b);
            screen21b.position.set(-198.975, -46.014, 130.621);
            screen21b.rotation.set(-3.141593, 0, -3.141593);
            screen21b.scale.set(1, 1, 1);
            screen21b.userData.screenNumber = 21;
            screen21b.userData.isColorSurface = true;
            screen21b.userData.color = 0x070707;
            screensGroup.add(screen21b);

            // ======================
            // FORME 22: Dark panel back
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width22 = 235.076;
            const height22 = 60.24; // Ajusté pour bas = -111.773
            const geometry22 = new THREE.PlaneGeometry(width22, height22);
            const material22 = createWallFormMaterial(0x999999); // Gris clair
            const screen22 = new THREE.Mesh(geometry22, material22);
            screen22.position.set(-315.617, -81.653, 180.248); // Y ajusté
            screen22.rotation.set(-3.141593, 0, -3.141593);
            screen22.scale.set(1, 1, 1);
            screen22.userData.screenNumber = 22;
            screen22.userData.isColorSurface = true;
            screen22.userData.color = 0x999999;
            screensGroup.add(screen22);

            // ======================
            // FORME 23: Dark panel front
            // Hauteur ajustée pour ne pas dépasser sous le sol 11 (Y=-111.773)
            // ======================
            const width23 = 235.076;
            const height23 = 60.24; // Ajusté pour bas = -111.773
            const geometry23 = new THREE.PlaneGeometry(width23, height23);
            const material23 = createWallFormMaterial(0x999999); // Gris clair
            const screen23 = new THREE.Mesh(geometry23, material23);
            screen23.position.set(-315.617, -81.653, 48.644); // Y ajusté
            screen23.rotation.set(-3.141593, 0, -3.141593);
            screen23.scale.set(1, 1, 1);
            screen23.userData.screenNumber = 23;
            screen23.userData.isColorSurface = true;
            screen23.userData.color = 0x999999;
            screensGroup.add(screen23);

            // ======================
            // FORME 24: Gray surface right side
            // ======================
            const width24 = 235.076;
            const height24 = 231.29;
            const geometry24 = new THREE.PlaneGeometry(width24, height24);
            const material24 = createWallFormMaterial(0x000000); // Noir absolu
            const screen24 = new THREE.Mesh(geometry24, material24);
            screen24.position.set(600.959, -6.589, 116.138);
            screen24.rotation.set(0, 1.570796, 0); // 90° en Y
            screen24.scale.set(1, 1, 1);
            screen24.userData.screenNumber = 24;
            screen24.userData.isColorSurface = true;
            screen24.userData.color = 0x000000;
            screensGroup.add(screen24);

            // Restore custom shapes (>24) - both in allScreens and screensGroup
            console.log('🔄 Restauration des formes personnalisées (>24):', Object.keys(customShapesToPreserve));
            Object.keys(customShapesToPreserve).forEach(key => {
                const shape = customShapesToPreserve[key];
                screensGroup.add(shape); // Re-add to scene
                allScreens[key] = shape; // CRITICAL: Re-add to allScreens to prevent orphaning
                console.log(`  ✓ Forme #${key} réajoutée à la scène et à allScreens`);
            });

            // Update volumetric screens & shapes - RENUMÉROTÉS (1-23)
            // ÉCRANS volumétriques: 1-6 | FORMES: 7-23
            allScreens = {
                1: particles,           // ÉCRAN: Wall back left (volumetric)
                2: particlesRight,      // ÉCRAN: Wall back right (volumetric)
                3: screen7,             // ÉCRAN: Side panel (volumetric)
                4: wallOppB,            // ÉCRAN: Wall front right (volumetric)
                5: wallOppA,            // ÉCRAN: Wall front left (volumetric)
                6: screen3,             // ÉCRAN: Floor rectangle (volumetric)
                7: screen4,             // FORME: Ceiling gray panel
                8: screen8,             // FORME: Center gray panel
                9: screen9,             // FORME: Back gray panel
                10: screen10,           // FORME: Floor lighter green panel
                11: screen11,           // FORME: Small dark green panel
                12: screen12,           // FORME: Dark green vertical panel
                13: screen14,           // FORME: Dark green thin panel 1
                14: screen15,           // FORME: Dark green thin panel 2
                15: screen16,           // FORME: Dark green horizontal panel
                16: screen17,           // FORME: Gray thin panel 1
                17: screen18,           // FORME: Gray thin panel 2
                18: screen21,           // FORME: Gray horizontal panel
                19: screen19,           // FORME: Gray floor panel
                20: screen20,           // FORME: Gray thin vertical panel 1
                21: screen21b,          // FORME: Gray thin vertical panel 2
                22: screen22,           // FORME: Dark panel back
                23: screen23,           // FORME: Dark panel front
                24: screen24,           // FORME: Gray surface right side
                ...customShapesToPreserve // Restore custom shapes (>24)
            };
            console.log('✅ Tous les écrans (1-24 + custom):', Object.keys(allScreens));

            // CRITICAL: Update screen list UI immediately after allScreens is populated
            updateScreenList();
            console.log('🎨 Interface de gestion des écrans mise à jour');

            // Update screen number labels for volumetric screens (Admin mode only)
            updateScreenLabels();
            console.log('🔢 Numéros des écrans volumétriques mis à jour');

            // CRITICAL: Reattach transform controls to the same screen after regeneration
            if (transformControls && wasScreenSelected && allScreens[wasScreenSelected]) {
                selectedScreen = wasScreenSelected;
                transformControls.attach(allScreens[wasScreenSelected]);
            }

            console.log('');
            console.log('=== CONTRÔLES 3D DISPONIBLES ===');
            console.log('Touches 1-9 : Sélectionner un écran/forme');
            console.log('G : Mode Translation');
            console.log('R : Mode Rotation');
            console.log('E : Mode Scale');
            console.log('Maj enfoncé : rotation 15°, translation 1000');
            console.log('Échap : Désélectionner');
            console.log('Ctrl+Z : Annuler | Ctrl+Shift+Z : Refaire');
            console.log('S : Sauvegarder positions');
            console.log('Magnétisme auto à 0/90/180/270°');
            console.log('================================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }

            console.log('🏁 generate() terminé - allScreens final:', Object.keys(allScreens));
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 15;
            document.getElementById('depth').value = 0.1;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('glow').value = 0.0;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.70;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.70;
            hideBackground = false;
            bgThreshold = 40;
            glowIntensity = 0.0;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('glow');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            // Show visual indicator to user
            const pausedIndicator = document.getElementById('video-paused-indicator');
            if (currentVideo.paused) {
                if (pausedIndicator && !pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.add('visible');
                }
                return;
            } else {
                if (pausedIndicator && pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.remove('visible');
                }
            }

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            // MODE PANORAMIQUE: Écran 1 = portion 0 (2/9 gauche) de la vidéo
            if (panoramicVideo && currentVideo === panoramicVideo) {
                // Extraire la portion gauche (2/9) de la vidéo panoramique
                offsetX = PANORAMIC_PORTIONS[0].offset * videoWidth; // 0
                offsetY = 0;
                sourceWidth = PANORAMIC_PORTIONS[0].width * videoWidth; // 2/9 du total
                sourceHeight = videoHeight;
            } else if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // v1.3.1 — Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Calculate colors with effects
                        {
                            // v1.3.1 — Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply brightness boost
                            let finalR = rNorm * brightness;
                            let finalG = gNorm * brightness;
                            let finalB = bNorm * brightness;

                            // Professional emissive effect: brighter particles glow more (non-linear power curve)
                            if (glowIntensity > 0) {
                                // Calculate luminance of the pixel
                                const pixelLuminance = 0.299 * finalR + 0.587 * finalG + 0.114 * finalB;

                                // Power curve: bright pixels get boosted more (quadratic for smooth glow)
                                const emissiveBoost = Math.pow(pixelLuminance, 2.0) * glowIntensity;

                                // Add emissive glow to bright particles
                                finalR += emissiveBoost * finalR;
                                finalG += emissiveBoost * finalG;
                                finalB += emissiveBoost * finalB;
                            }

                            // Update color with brightness + emissive
                            newColors.push(
                                Math.min(1.0, finalR),
                                Math.min(1.0, finalG),
                                Math.min(1.0, finalB)
                            );
                        }
                    }
                }
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < newDepths.length; i++) {
                        const z = newDepths[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            newColors[i * 3] = 0;
                            newColors[i * 3 + 1] = 0;
                            newColors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation with smoothing
                // AND apply depth to instance matrices directly (volumetry)
                if (particles.userData.initialZ) {
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = initialZs[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            initialZs[i] = newDepth;
                        }

                        // VOLUMETRY: Update instance matrix position
                        if (positions) {
                            reusableMatrix.setPosition(positions[i * 3], positions[i * 3 + 1], initialZs[i]);
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                    }
                    particles.instanceMatrix.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (3D mode) - now at position 3
                // SKIP if multi-video system has a dedicated video for this screen
                // SKIP in panoramic mode (updateMultiScreenColors handles it with the correct portion)
                if (allScreens[3] && allScreens[3].instanceColor && !screenVideos[3] && !panoramicVideo) {
                    const screen7 = allScreens[3];
                    const colors7 = screen7.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen7.userData.initialZ) {
                                        const oldDepth = screen7.userData.initialZ[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen7.userData.initialZ[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen7.instanceColor.needsUpdate = true;
                }

                // CRITICAL: Also update screen 6 (sol) if it exists (3D mode)
                // Skip if floor has its own video (handled by updateMultiScreenColors)
                if (allScreens[6] && allScreens[6].instanceColor && !screenVideos[6]) {
                    const screen3 = allScreens[6];
                    const colors3 = screen3.instanceColor.array;
                    const screen3Positions = screen3.userData.positions;
                    const screen3InitialZ = screen3.userData.initialZ;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2;
                    const halfH_screen3 = 228.534 / 4; // Correspondre à forme 10

                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const py = -(y - halfHeight) * scaleFactor;

                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen3InitialZ) {
                                        const oldDepth = screen3InitialZ[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen3InitialZ[screen3Index] = newDepth;
                                        }
                                        // VOLUMETRY: Update instance matrix position
                                        if (screen3Positions) {
                                            reusableMatrix.setPosition(
                                                screen3Positions[screen3Index * 3],
                                                screen3Positions[screen3Index * 3 + 1],
                                                screen3InitialZ[screen3Index]
                                            );
                                            screen3.setMatrixAt(screen3Index, reusableMatrix);
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen3.instanceColor.needsUpdate = true;
                    screen3.instanceMatrix.needsUpdate = true;
                }

            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation with smoothing
                // AND apply depth to position.z directly (volumetry)
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    const positionsArray = geometry.attributes.position.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = initialZArray[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            initialZArray[i] = newDepth;
                        }
                        // VOLUMETRY: Update position.z
                        positionsArray[i * 3 + 2] = initialZArray[i];
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                    geometry.attributes.position.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (2D mode) - now at position 3
                // SKIP if multi-video system has a dedicated video for this screen
                // SKIP in panoramic mode (updateMultiScreenColors handles it with the correct portion)
                if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.color && !screenVideos[3] && !panoramicVideo) {
                    const screen7 = allScreens[3];
                    const geom7 = screen7.geometry;
                    const colors7 = geom7.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom7.attributes.initialZ) {
                                        const oldDepth = geom7.attributes.initialZ.array[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom7.attributes.initialZ.array[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom7.attributes.color.needsUpdate = true;
                    if (geom7.attributes.initialZ) {
                        geom7.attributes.initialZ.needsUpdate = true;
                    }
                }

                // CRITICAL: Also update screen 6 (sol) if it exists (2D mode)
                // Skip if floor has its own video (handled by updateMultiScreenColors)
                if (allScreens[6] && allScreens[6].geometry && allScreens[6].geometry.attributes.color && !screenVideos[6]) {
                    const screen3 = allScreens[6];
                    const geom3 = screen3.geometry;
                    const colors3 = geom3.attributes.color.array;
                    const positions3 = geom3.attributes.position.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2;
                    const halfH_screen3 = 228.534 / 4; // Correspondre à forme 10

                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const py = -(y - halfHeight) * scaleFactor;

                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom3.attributes.initialZ) {
                                        const oldDepth = geom3.attributes.initialZ.array[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom3.attributes.initialZ.array[screen3Index] = newDepth;
                                        }
                                        // VOLUMETRY: Update position.z
                                        positions3[screen3Index * 3 + 2] = geom3.attributes.initialZ.array[screen3Index];
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom3.attributes.color.needsUpdate = true;
                    geom3.attributes.position.needsUpdate = true;
                    if (geom3.attributes.initialZ) {
                        geom3.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Update colors AND depth for screens 2-5 from their respective videos
        let lastMultiScreenUpdate = 0;
        const MULTI_SCREEN_UPDATE_INTERVAL = 50; // ms between updates
        const reusableMatrix2 = new THREE.Matrix4();
        const reusableColor2 = new THREE.Color();

        function updateMultiScreenColors() {
            const now = performance.now();
            if (now - lastMultiScreenUpdate < MULTI_SCREEN_UPDATE_INTERVAL) return;
            lastMultiScreenUpdate = now;

            // Screens to update: 2, 3, 4, 5 (screen 1 is updated by updateColorsFromVideo)
            // Screen 6 (floor) added when it has its own video
            const screensToUpdate = [2, 3, 4, 5];
            if (screenVideos[6]) screensToUpdate.push(6);
            const scaleFactor = 0.5;
            const rgbToLumFactor = 1 / (3 * 255);

            // Mapping from allScreens index to PANORAMIC_PORTIONS index
            // allScreens[2] (particlesRight) → PANORAMIC_PORTIONS[1] (2/9)
            // allScreens[3] (screen7/Side panel) → PANORAMIC_PORTIONS[2] (1/9)
            // allScreens[4] (wallOppB = ÉCRAN 6) → PANORAMIC_PORTIONS[3] (2/9)
            // allScreens[5] (wallOppA = ÉCRAN 5) → PANORAMIC_PORTIONS[4] (2/9)
            const screenToPortionIndex = {
                2: 1,  // allScreens[2] → PANORAMIC_PORTIONS[1]
                3: 2,  // allScreens[3] → PANORAMIC_PORTIONS[2]
                4: 3,  // allScreens[4] → PANORAMIC_PORTIONS[3]
                5: 4   // allScreens[5] → PANORAMIC_PORTIONS[4]
            };

            for (const screenNum of screensToUpdate) {
                const screen = allScreens[screenNum];

                // Screen 6 (floor) always uses its own dedicated video
                const video = (screenNum === 6) ? screenVideos[6] : (panoramicVideo || screenVideos[screenNum]);

                if (!screen || !video || video.paused || video.videoWidth === 0) continue;

                // Create or get sampling canvas for this screen
                if (!screenSamplingCanvases[screenNum]) {
                    const canvas = document.createElement('canvas');
                    if (screenNum === 6) {
                        // Floor: canvas au ratio exact du sol (800×229 ≈ 3.5:1)
                        canvas.width = 800;
                        canvas.height = 229;
                    } else {
                        canvas.width = 800;
                        canvas.height = 450;
                    }
                    screenSamplingCanvases[screenNum] = {
                        canvas: canvas,
                        ctx: canvas.getContext('2d', { willReadFrequently: true })
                    };
                }

                const { canvas, ctx } = screenSamplingCanvases[screenNum];
                const TARGET_WIDTH = canvas.width;
                const TARGET_HEIGHT = canvas.height;
                const halfWidth = TARGET_WIDTH / 2;
                const halfHeight = TARGET_HEIGHT / 2;
                const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

                // Draw video frame to canvas
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;

                let sourceX, sourceY, sourceWidth, sourceHeight;

                if (panoramicVideo && screenNum !== 6) {
                    // PANORAMIC MODE: Extract the correct portion using ninths mapping
                    const portionIdx = screenToPortionIndex[screenNum];
                    const portion = PANORAMIC_PORTIONS[portionIdx];

                    sourceX = portion.offset * videoWidth;
                    sourceY = 0;
                    sourceWidth = portion.width * videoWidth;
                    sourceHeight = videoHeight;
                } else {
                    // MULTI-VIDEO / FLOOR MODE: Use the whole video with aspect ratio handling
                    const videoAspect = videoWidth / videoHeight;
                    const targetAspect = TARGET_WIDTH / TARGET_HEIGHT;

                    if (videoAspect > targetAspect) {
                        sourceHeight = videoHeight;
                        sourceWidth = videoHeight * targetAspect;
                        sourceX = (videoWidth - sourceWidth) / 2;
                        sourceY = 0;
                    } else {
                        sourceWidth = videoWidth;
                        sourceHeight = videoWidth / targetAspect;
                        sourceX = 0;
                        sourceY = (videoHeight - sourceHeight) / 2;
                    }
                }

                ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                const data = imageData.data;

                // Calculate step based on particle density
                const step = Math.max(1, Math.floor(10 / particleDensity));
                const useContrast = contrast !== 1.0;
                const useSaturation = saturation !== 1.0;

                // First pass: find min luminance
                let minLuminance = Infinity;
                for (let y = 0; y < TARGET_HEIGHT; y += step) {
                    for (let x = 0; x < TARGET_WIDTH; x += step) {
                        const i = (y * TARGET_WIDTH + x) * 4;
                        if (data[i + 3] > 30) {
                            const luminance = (data[i] + data[i + 1] + data[i + 2]) * rgbToLumFactor;
                            minLuminance = Math.min(minLuminance, luminance);
                        }
                    }
                }
                if (minLuminance === Infinity) minLuminance = 0;

                // Check if 3D mode (InstancedMesh) or 2D mode (Points)
                const is3DMode = screen.userData && screen.userData.is3D;

                if (is3DMode && screen.instanceColor && screen.userData.initialZ) {
                    // 3D MODE: Update instance colors and positions
                    const colorsArray = screen.instanceColor.array;
                    const initialZs = screen.userData.initialZ;
                    const positions = screen.userData.positions;

                    let particleIndex = 0;
                    for (let y = 0; y < TARGET_HEIGHT && particleIndex < initialZs.length; y += step) {
                        for (let x = 0; x < TARGET_WIDTH && particleIndex < initialZs.length; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            if (data[i + 3] > 30) {
                                const r = data[i], g = data[i + 1], b = data[i + 2];
                                const luminance = (r + g + b) * rgbToLumFactor;
                                const newDepth = (luminance - minLuminance) * depthSpread;

                                // Update depth with smoothing
                                const oldDepth = initialZs[particleIndex];
                                const depthDelta = Math.abs(newDepth - oldDepth);
                                if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                    initialZs[particleIndex] = newDepth;
                                }

                                // Update color
                                let rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                                if (useContrast) {
                                    rNorm = Math.max(0, Math.min(1, (rNorm - 0.5) * contrast + 0.5));
                                    gNorm = Math.max(0, Math.min(1, (gNorm - 0.5) * contrast + 0.5));
                                    bNorm = Math.max(0, Math.min(1, (bNorm - 0.5) * contrast + 0.5));
                                }
                                if (useSaturation) {
                                    const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                    rNorm = Math.max(0, Math.min(1, gray + saturation * (rNorm - gray)));
                                    gNorm = Math.max(0, Math.min(1, gray + saturation * (gNorm - gray)));
                                    bNorm = Math.max(0, Math.min(1, gray + saturation * (bNorm - gray)));
                                }

                                colorsArray[particleIndex * 3] = Math.min(1.0, rNorm * brightness);
                                colorsArray[particleIndex * 3 + 1] = Math.min(1.0, gNorm * brightness);
                                colorsArray[particleIndex * 3 + 2] = Math.min(1.0, bNorm * brightness);

                                // Update instance matrix position
                                if (positions) {
                                    const px = positions[particleIndex * 3];
                                    const py = positions[particleIndex * 3 + 1];
                                    const targetZ = initialZs[particleIndex];
                                    reusableMatrix2.setPosition(px, py, targetZ);
                                    screen.setMatrixAt(particleIndex, reusableMatrix2);
                                }

                                particleIndex++;
                            }
                        }
                    }
                    screen.instanceColor.needsUpdate = true;
                    screen.instanceMatrix.needsUpdate = true;

                } else if (screen.geometry && screen.geometry.attributes.color) {
                    // 2D MODE: Update point colors and positions
                    const colorsArray = screen.geometry.attributes.color.array;
                    const positionsArray = screen.geometry.attributes.position.array;
                    const initialZArray = screen.geometry.attributes.initialZ ? screen.geometry.attributes.initialZ.array : null;

                    let particleIndex = 0;
                    for (let y = 0; y < TARGET_HEIGHT && particleIndex * 3 < colorsArray.length; y += step) {
                        for (let x = 0; x < TARGET_WIDTH && particleIndex * 3 < colorsArray.length; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            if (data[i + 3] > 30) {
                                const r = data[i], g = data[i + 1], b = data[i + 2];
                                const luminance = (r + g + b) * rgbToLumFactor;
                                const newDepth = (luminance - minLuminance) * depthSpread;

                                // Update depth
                                if (initialZArray) {
                                    const oldDepth = initialZArray[particleIndex];
                                    const depthDelta = Math.abs(newDepth - oldDepth);
                                    if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                        initialZArray[particleIndex] = newDepth;
                                        positionsArray[particleIndex * 3 + 2] = newDepth;
                                    }
                                }

                                // Update color
                                let rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                                if (useContrast) {
                                    rNorm = Math.max(0, Math.min(1, (rNorm - 0.5) * contrast + 0.5));
                                    gNorm = Math.max(0, Math.min(1, (gNorm - 0.5) * contrast + 0.5));
                                    bNorm = Math.max(0, Math.min(1, (bNorm - 0.5) * contrast + 0.5));
                                }
                                if (useSaturation) {
                                    const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                    rNorm = Math.max(0, Math.min(1, gray + saturation * (rNorm - gray)));
                                    gNorm = Math.max(0, Math.min(1, gray + saturation * (gNorm - gray)));
                                    bNorm = Math.max(0, Math.min(1, gray + saturation * (bNorm - gray)));
                                }

                                colorsArray[particleIndex * 3] = Math.min(1.0, rNorm * brightness);
                                colorsArray[particleIndex * 3 + 1] = Math.min(1.0, gNorm * brightness);
                                colorsArray[particleIndex * 3 + 2] = Math.min(1.0, bNorm * brightness);

                                particleIndex++;
                            }
                        }
                    }
                    screen.geometry.attributes.color.needsUpdate = true;
                    screen.geometry.attributes.position.needsUpdate = true;
                    if (initialZArray) {
                        screen.geometry.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Collision detection function (for FPS mode) - VERSION FINALE
        // FIX: Épaisseur minimale pour les PlaneGeometry qui n'ont pas d'épaisseur intrinsèque
        const WALL_THICKNESS = 10; // Épaisseur minimale des murs pour la collision (en unités)

        function checkCollision(newPosition, prevPosition) {
            if (!fpsMode) return false;

            const hitboxWidth = fpsSettings.fpsHitboxWidth / 2; // Demi-largeur
            const hitboxHeight = fpsSettings.fpsHitboxHeight / 2; // Demi-hauteur

            // Collecter tous les murs (pas les sols 3, 10 et 11)
            // Inclut à la fois les écrans volumétriques (1,2,5,6,7) et les surfaces de couleur (4,8-21+)
            const walls = [];
            for (const key in allScreens) {
                if (key === '3' || key === '10' || key === '11') continue; // Skip floors

                const screen = allScreens[key];
                // Include both volumetric screens and color surfaces (all non-floor screens)
                if (screen && screen.visible !== false) {
                    walls.push(screen);
                }
            }

            if (walls.length === 0) return false;

            // OPTIMIZED: Reuse global Box3 objects instead of creating new ones
            reusablePlayerBox.min.set(
                newPosition.x - hitboxWidth,
                newPosition.y - hitboxHeight,
                newPosition.z - hitboxWidth
            );
            reusablePlayerBox.max.set(
                newPosition.x + hitboxWidth,
                newPosition.y + hitboxHeight,
                newPosition.z + hitboxWidth
            );

            // Tester collision avec chaque mur
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                reusableWallBox.setFromObject(wall);

                // FIX: Épaissir les bounding boxes qui sont trop fines (PlaneGeometry)
                // Calculer les dimensions de la box
                const sizeX = reusableWallBox.max.x - reusableWallBox.min.x;
                const sizeY = reusableWallBox.max.y - reusableWallBox.min.y;
                const sizeZ = reusableWallBox.max.z - reusableWallBox.min.z;

                // Si une dimension est trop fine (< WALL_THICKNESS), l'épaissir
                if (sizeX < WALL_THICKNESS) {
                    const centerX = (reusableWallBox.max.x + reusableWallBox.min.x) / 2;
                    reusableWallBox.min.x = centerX - WALL_THICKNESS / 2;
                    reusableWallBox.max.x = centerX + WALL_THICKNESS / 2;
                }
                if (sizeY < WALL_THICKNESS) {
                    const centerY = (reusableWallBox.max.y + reusableWallBox.min.y) / 2;
                    reusableWallBox.min.y = centerY - WALL_THICKNESS / 2;
                    reusableWallBox.max.y = centerY + WALL_THICKNESS / 2;
                }
                if (sizeZ < WALL_THICKNESS) {
                    const centerZ = (reusableWallBox.max.z + reusableWallBox.min.z) / 2;
                    reusableWallBox.min.z = centerZ - WALL_THICKNESS / 2;
                    reusableWallBox.max.z = centerZ + WALL_THICKNESS / 2;
                }

                if (reusablePlayerBox.intersectsBox(reusableWallBox)) {
                    return true; // Collision détectée !
                }
            }

            return false; // Pas de collision
        }

        // Animation with subtle breathing movement and video texture updates
        let animateFrameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // FPS Counter calculation
            fpsFrameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - fpsLastTime;

            if (deltaTime >= fpsUpdateInterval) {
                fpsCurrentFPS = Math.round((fpsFrameCount * 1000) / deltaTime);
                fpsFrameCount = 0;
                fpsLastTime = currentTime;

                // OPTIMIZED: Use cached DOM elements, only touch DOM when value changes
                if (fpsDOMCache.value && fpsDOMCache.counter) {
                    fpsDOMCache.value.textContent = fpsCurrentFPS;

                    // Only update class when threshold zone changes
                    const newZone = fpsCurrentFPS < 30 ? 'critical-fps' : (fpsCurrentFPS < 50 ? 'low-fps' : '');
                    if (newZone !== fpsDOMCache._lastZone) {
                        fpsDOMCache.counter.classList.remove('low-fps', 'critical-fps');
                        if (newZone) fpsDOMCache.counter.classList.add(newZone);
                        fpsDOMCache._lastZone = newZone;
                    }
                }
            }

            animateFrameCount++;
            if (animateFrameCount === 1) {
                if (DEBUG_MODE) _log('ANIMATE() - Première frame');
            }

            time += 0.001 * breathSpeed;

            // SCROLL LISSÉ: Appliquer progressivement la vitesse de scroll
            if (Math.abs(scrollVelocity) > 0.01) {
                camera.getWorldDirection(reusableForward);

                if (fpsMode) {
                    // MODE FPS: Déplacement horizontal uniquement
                    const savedY = camera.position.y;
                    reusableForward.y = 0;
                    reusableForward.normalize();

                    reusablePrevPosition.copy(camera.position);
                    camera.position.addScaledVector(reusableForward, scrollVelocity);
                    camera.position.y = savedY;

                    // Vérifier collision
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                        scrollVelocity = 0; // Arrêter le mouvement en cas de collision
                    }
                } else {
                    // Mode admin: zoom libre
                    camera.position.addScaledVector(reusableForward, scrollVelocity);
                }

                // Décroissance de la vitesse (effet d'inertie)
                scrollVelocity *= SCROLL_DECAY;

                // Arrêter si très petit
                if (Math.abs(scrollVelocity) < 0.01) {
                    scrollVelocity = 0;
                }
            }

            // GPU PIPELINE: Only update texture when video frame actually changes
            // Avoids re-uploading 28MB (8640×1080×RGB) to GPU on every frame
            if (gpuVideoTexture && panoramicVideo) {
                const currentVideoTime = panoramicVideo.currentTime;
                if (currentVideoTime !== lastVideoTime) {
                    gpuVideoTexture.needsUpdate = true;
                    lastVideoTime = currentVideoTime;
                }
            } else if (gpuVideoTexture && currentVideo) {
                const currentVideoTime = currentVideo.currentTime;
                if (currentVideoTime !== lastVideoTime) {
                    gpuVideoTexture.needsUpdate = true;
                    lastVideoTime = currentVideoTime;
                }
            }

            // PERFORMANCE: Skip particle animation loop entirely if no breathing and no flow
            const needsParticleAnimation = breathSpeed > 0 || flowIntensity > 0;

            if (particles && flowOffsets && needsParticleAnimation) {
                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {
                        // Optimization: reuse matrix object instead of creating new one
                        const epsilon = 0.3 * breathSpeed;

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            // GPU pipeline: Z=breathOffset only (shader adds depth from luminance)
                            const newZ = breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 7 if it has its own geometry (3D mode) - now at position 3
                    // SKIP if multi-video system has a dedicated video for this screen
                    if (allScreens[3] && allScreens[3].userData && allScreens[3].userData.is3D && !screenVideos[3]) {
                        const screen7 = allScreens[3];
                        const positions7 = screen7.userData.positions;

                        if (positions7 && positions7.length > 0) {
                            const epsilon = 0.3 * breathSpeed;
                            const count7 = positions7.length / 3;

                            for (let i = 0; i < count7; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions7[i * 3] + flowX,
                                    positions7[i * 3 + 1] + flowY,
                                    breathOffset // GPU pipeline: shader adds depth
                                );
                                screen7.setMatrixAt(i, reusableMatrix);
                            }
                            screen7.instanceMatrix.needsUpdate = true;
                        }
                    }

                    // CRITICAL: Also update screen 6 (floor) if it has its own geometry (3D mode)
                    if (allScreens[6] && allScreens[6].userData && allScreens[6].userData.is3D) {
                        const screen3 = allScreens[6];
                        const positions3 = screen3.userData.positions;

                        if (positions3 && positions3.length > 0) {
                            const epsilon = 0.3 * breathSpeed;
                            const count3 = positions3.length / 3;

                            for (let i = 0; i < count3; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions3[i * 3] + flowX,
                                    positions3[i * 3 + 1] + flowY,
                                    breathOffset // GPU pipeline: shader adds depth
                                );
                                screen3.setMatrixAt(i, reusableMatrix);
                            }
                            screen3.instanceMatrix.needsUpdate = true;
                        }
                    }

                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        // GPU pipeline: Z=breathOffset only (shader adds depth from luminance)
                        positions[i * 3 + 2] = breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;

                    // CRITICAL: Also update screen 7 if it has its own geometry (2D mode) - now at position 3
                    // SKIP if multi-video system has a dedicated video for this screen
                    if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.position && !screenVideos[3]) {
                        const screen7 = allScreens[3];
                        const geom7 = screen7.geometry;
                        const positions7 = geom7.attributes.position.array;

                        // Store initial positions if not already stored
                        if (!geom7.userData.initialPositions) {
                            geom7.userData.initialPositions = new Float32Array(positions7.length);
                            for (let i = 0; i < positions7.length; i++) {
                                geom7.userData.initialPositions[i] = positions7[i];
                            }
                        }

                        const initialPositions7 = geom7.userData.initialPositions;

                        for (let i = 0; i < positions7.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions7[i * 3] = initialPositions7[i * 3] + flowX;
                            positions7[i * 3 + 1] = initialPositions7[i * 3 + 1] + flowY;
                            positions7[i * 3 + 2] = breathOffset; // GPU pipeline: shader adds depth
                        }

                        geom7.attributes.position.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 6 (floor) if it has its own geometry (2D mode)
                    if (allScreens[6] && allScreens[6].geometry && allScreens[6].geometry.attributes.position) {
                        const screen3 = allScreens[6];
                        const geom3 = screen3.geometry;
                        const positions3 = geom3.attributes.position.array;

                        // Store initial positions if not already stored
                        if (!geom3.userData.initialPositions) {
                            geom3.userData.initialPositions = new Float32Array(positions3.length);
                            for (let i = 0; i < positions3.length; i++) {
                                geom3.userData.initialPositions[i] = positions3[i];
                            }
                        }

                        const initialPositions3 = geom3.userData.initialPositions;

                        for (let i = 0; i < positions3.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions3[i * 3] = initialPositions3[i * 3] + flowX;
                            positions3[i * 3 + 1] = initialPositions3[i * 3 + 1] + flowY;
                            positions3[i * 3 + 2] = breathOffset; // GPU pipeline: shader adds depth
                        }

                        geom3.attributes.position.needsUpdate = true;
                    }
                }
            }

            // Mobile joystick movement
            if (typeof applyJoystickMovement === 'function') {
                applyJoystickMovement();
            }

            // Free camera rotation (smoothed mouse look)
            if (freeCameraEnabled && camera) {
                if (smoothYaw === null) { smoothYaw = cameraYaw; smoothPitch = cameraPitch; }
                smoothYaw += (cameraYaw - smoothYaw) * MOUSE_SMOOTHING;
                smoothPitch += (cameraPitch - smoothPitch) * MOUSE_SMOOTHING;
                camera.rotation.order = 'YXZ';
                camera.rotation.y = smoothYaw;
                camera.rotation.x = smoothPitch;
                camera.rotation.z = cameraTilt;
            }

            // Camera movement (only when no screen selected and free camera enabled)
            if (!selectedScreen && freeCameraEnabled && camera) {
                // OPTIMIZED: Reuse global Vector3 objects
                camera.getWorldDirection(reusableForward);
                reusableForward.y = 0; // Mouvement horizontal uniquement
                reusableForward.normalize();

                reusableRight.crossVectors(reusableForward, reusableUp);
                reusableRight.normalize();

                // Check if any movement key is pressed
                const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;

                if (fpsMode) {
                    // ===== MODE FPS: Vitesse graduée avec accélération =====

                    if (isMoving) {
                        // On mobile, scale max speed by analog joystick magnitude
                        const effectiveMaxSpeed = (isMobile && mobileSpeedMultiplier > 0)
                            ? fpsSettings.fpsMaxSpeed * mobileSpeedMultiplier
                            : fpsSettings.fpsMaxSpeed;
                        currentSpeed = Math.min(currentSpeed + fpsSettings.fpsAcceleration, effectiveMaxSpeed);
                        if (cameraKeys.sprint) {
                            currentSpeed = Math.min(currentSpeed, fpsSettings.fpsMaxSpeed * 1.5);
                        }
                    } else {
                        currentSpeed = Math.max(currentSpeed - fpsSettings.fpsDeceleration, MIN_SPEED);
                    }

                    // Camera sway (tilt on strafe)
                    let targetTilt = 0;
                    if (cameraKeys.left) targetTilt = CAMERA_TILT_AMOUNT;
                    if (cameraKeys.right) targetTilt = -CAMERA_TILT_AMOUNT;
                    cameraTilt += (targetTilt - cameraTilt) * CAMERA_TILT_SPEED;

                    // OPTIMIZED: Reuse global Vector3 for previous position
                    reusablePrevPosition.copy(camera.position);

                    // Apply movement
                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, currentSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -currentSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -currentSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, currentSpeed);
                    }

                    // Check collisions
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                    }
                } else {
                    // ===== MODE NORMAL: Vitesse fixe, pas de collision =====

                    const normalSpeed = cameraKeys.sprint ? CAMERA_SPEED * CAMERA_SPRINT_MULTIPLIER : CAMERA_SPEED;

                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, normalSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -normalSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -normalSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, normalSpeed);
                    }
                }

                if (fpsMode) {
                    // ===== MODE FPS: Gravité et marche sur le sol =====

                    // PERFORMANCE: Throttle raycasting (coûteux) - 1 frame sur 3
                    raycastCounter++;
                    if (raycastCounter >= RAYCAST_INTERVAL) {
                        raycastCounter = 0;
                        reusableRaycaster.set(camera.position, downVector);

                        const floorScreens = [];
                        if (allScreens[6]) floorScreens.push(allScreens[6]);
                        if (allScreens[10]) floorScreens.push(allScreens[10]);
                        if (allScreens[11]) floorScreens.push(allScreens[11]);

                        const intersects = reusableRaycaster.intersectObjects(floorScreens, false);
                        lastGroundY = intersects.length > 0 ? intersects[0].point.y + fpsSettings.fpsPlayerHeight : null;
                    }

                    if (lastGroundY !== null) {
                        const distanceToGround = camera.position.y - lastGroundY;

                        if (distanceToGround <= 1) {
                            camera.position.y = lastGroundY;
                            playerVelocityY = 0;
                            isOnGround = true;
                        } else {
                            isOnGround = false;
                            playerVelocityY += fpsSettings.fpsGravity;
                            camera.position.y += playerVelocityY;
                        }
                    } else {
                        // Pas de sol détecté - tomber
                        isOnGround = false;
                        playerVelocityY += fpsSettings.fpsGravity;
                        camera.position.y += playerVelocityY;
                    }

                    // Head bobbing: dual-sine (vertical + lateral)
                    const isMovingBob = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;
                    const speedRatio = Math.min(currentSpeed / fpsSettings.fpsMaxSpeed, 1);
                    if (isMovingBob && playerVelocityY === 0) {
                        headBobTimer += HEAD_BOB_SPEED * (cameraKeys.sprint ? 1.4 : 1);
                        const bobY = Math.sin(headBobTimer) * HEAD_BOB_AMOUNT * speedRatio;
                        const bobX = Math.cos(headBobTimer * 0.5) * HEAD_BOB_SIDE_AMOUNT * speedRatio;
                        camera.position.y += bobY;
                        camera.position.x += reusableRight.x * bobX;
                        camera.position.z += reusableRight.z * bobX;
                    } else {
                        headBobTimer *= 0.92;
                    }

                    // FOV kick during sprint
                    targetFOV = cameraKeys.sprint ? DEFAULT_FOV + SPRINT_FOV_INCREASE : DEFAULT_FOV;

                    // Visualisation de la hitbox
                    if (showHitbox) {
                        // Créer ou mettre à jour le helper
                        if (!hitboxHelper) {
                            // Créer un wireframe box pour visualiser la hitbox
                            const hitboxGeometry = new THREE.BoxGeometry(1, 1, 1); // Base size
                            const hitboxMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00ff00,
                                wireframe: true,
                                transparent: true,
                                opacity: 0.5
                            });
                            hitboxHelper = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                            scene.add(hitboxHelper);
                        }

                        // Mettre à jour la position et la taille de la hitbox dynamiquement
                        hitboxHelper.position.copy(camera.position);
                        hitboxHelper.scale.set(
                            fpsSettings.fpsHitboxWidth,
                            fpsSettings.fpsHitboxHeight,
                            fpsSettings.fpsHitboxWidth
                        );
                        hitboxHelper.visible = true;
                    } else if (hitboxHelper) {
                        hitboxHelper.visible = false;
                    }

                } else {
                    // ===== MODE NORMAL: Déplacement libre avec O/L =====

                    if (cameraKeys.up) {
                        camera.position.y += currentSpeed;
                    }
                    if (cameraKeys.down) {
                        camera.position.y -= currentSpeed;
                    }

                    // Pas de collision en mode normal (mode édition)
                    targetFOV = DEFAULT_FOV;
                }
            }

            // Smooth FOV transition
            if (camera && Math.abs(currentFOV - targetFOV) > 0.1) {
                currentFOV += (targetFOV - currentFOV) * 0.1;
                camera.fov = currentFOV;
                camera.updateProjectionMatrix();
            }


            // Show persistent instructions (ALT + ESC) in FPS mode, hide when paused
            const persistentInstr = document.getElementById('persistent-instructions');
            if (persistentInstr) {
                persistentInstr.style.display = (fpsMode && !isPaused) ? 'flex' : 'none';
            }

            // Update game instructions visibility based on Y position
            // Floor 11 is at Y=-111.773, with eye height 25, camera should be at Y≈-86.773
            const instructionsElement = fpsDOMCache.gameInstructions;
            if (instructionsElement) {
                // Show instructions ONLY in FPS mode when on floor 11
                if (fpsMode && !isPaused) {
                    const FLOOR_11_Y = -111.773;
                    const expectedCameraY = FLOOR_11_Y + fpsSettings.fpsPlayerHeight;
                    const tolerance = 8;

                    const isOnFloor11 = Math.abs(camera.position.y - expectedCameraY) < tolerance;

                    if (isOnFloor11 && !instructionsHidden) {
                        // Show instructions until user interacts enough
                        instructionsElement.classList.remove('hidden');
                    } else {
                        instructionsElement.classList.add('hidden');
                    }
                } else {
                    // Hide instructions in admin mode or when paused
                    instructionsElement.classList.add('hidden');
                }
            }

            if (animateFrameCount === 1) {
                console.log('🖼️ RENDER() - Premier rendu de la scène');
            }
            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Only resize if camera and renderer are initialized
            if (!camera || !renderer) return;

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                updateGPUVolumeUniforms();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                updateGPUVolumeUniforms();
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                // hideBackground is not a GPU uniform — needs regeneration if used
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        // Update glass material for screen 10
        function updateGlassMaterial() {
            if (allScreens[10] && allScreens[10].userData.isGlass) {
                const mat = allScreens[10].material;
                mat.metalness = fpsSettings.glassMetalness;
                mat.roughness = fpsSettings.glassRoughness;
                mat.opacity = fpsSettings.glassOpacity;
                mat.needsUpdate = true;
                console.log('🔄 Matériau verre mis à jour:', {
                    opacity: fpsSettings.glassOpacity,
                    metalness: fpsSettings.glassMetalness,
                    roughness: fpsSettings.glassRoughness
                });
            } else {
                console.warn('⚠️ Écran 10 pas encore créé ou pas marqué comme verre');
            }
        }

        // FPS Settings Panel Management
        function setupFPSSettings() {
            const panel = document.getElementById('fps-settings-panel');
            const sliders = {
                'fps-speed': { var: 'fpsMaxSpeed', display: 'val-fps-speed', decimals: 2 },
                'fps-scroll': { var: 'fpsScrollSpeed', display: 'val-fps-scroll', decimals: 1 },
                'fps-accel': { var: 'fpsAcceleration', display: 'val-fps-accel', decimals: 2 },
                'fps-decel': { var: 'fpsDeceleration', display: 'val-fps-decel', decimals: 2 },
                'fps-height': { var: 'fpsCameraHeight', display: 'val-fps-height', decimals: 0 },
                'fps-gravity': { var: 'fpsGravity', display: 'val-fps-gravity', decimals: 2 },
                'fps-eye': { var: 'fpsPlayerHeight', display: 'val-fps-eye', decimals: 0 },
                'fps-mouse': { var: 'fpsMouseSensitivity', display: 'val-fps-mouse', decimals: 4 },
                'fps-hitbox-width': { var: 'fpsHitboxWidth', display: 'val-fps-hitbox-width', decimals: 1 },
                'fps-hitbox-height': { var: 'fpsHitboxHeight', display: 'val-fps-hitbox-height', decimals: 0 },
                'glass-opacity': { var: 'glassOpacity', display: 'val-glass-opacity', decimals: 2, callback: updateGlassMaterial },
                'glass-roughness': { var: 'glassRoughness', display: 'val-glass-roughness', decimals: 2, callback: updateGlassMaterial },
                'glass-metalness': { var: 'glassMetalness', display: 'val-glass-metalness', decimals: 2, callback: updateGlassMaterial }
            };

            // Setup sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const config = sliders[sliderId];

                // Skip if slider doesn't exist in DOM
                if (!slider) {
                    console.warn(`⚠️ Slider "${sliderId}" not found in HTML`);
                    return;
                }

                slider.addEventListener('input', function() {
                    const value = parseFloat(this.value);

                    // Update variable in fpsSettings
                    fpsSettings[config.var] = value;

                    // Update display
                    const displayValue = value.toFixed(config.decimals);
                    document.getElementById(config.display).textContent = displayValue;

                    console.log(`✅ ${config.var} = ${displayValue}`);

                    // Call callback if provided
                    if (config.callback) {
                        config.callback();
                    }

                    // Log hitbox changes specifically
                    if (config.var === 'fpsHitboxWidth' || config.var === 'fpsHitboxHeight') {
                        console.log('🎯 Hitbox mise à jour:', {
                            largeur: fpsSettings.fpsHitboxWidth,
                            hauteur: fpsSettings.fpsHitboxHeight
                        });
                    }
                });
            });

            // Export button
            document.getElementById('fps-export-btn').addEventListener('click', exportFPSSettings);

            // Ctrl+S to export
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.code === 'KeyS') {
                    e.preventDefault();
                    exportFPSSettings();
                }
            });
        }

        function exportFPSSettings() {
            const exportText = Object.entries(fpsSettings)
                .map(([key, value]) => key + ' = ' + value + ';')
                .join('\n');

            // Copy to clipboard with user feedback
            navigator.clipboard.writeText(exportText).then(() => {
                const btn = document.getElementById('fps-export-btn');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = 'Copié !';
                    setTimeout(() => { btn.textContent = original; }, 1500);
                }
            }).catch(() => {
                // Fallback: log to console
                console.log('FPS Settings Export:\n' + exportText);
            });
        }

        // Toggle FPS panel with F key (Admin mode only)
        document.addEventListener('keydown', function(e) {
            if (e.code === 'KeyF' && !e.ctrlKey && !e.shiftKey && !e.altKey && !fpsMode) {
                const panel = document.getElementById('fps-settings-panel');
                panel.classList.toggle('hidden');
                console.log(panel.classList.contains('hidden') ? '🔧 FPS Settings cachés (F pour afficher)' : '🔧 FPS Settings affichés (F pour cacher)');
            }
        });

        // Draggable panels system
        function makeDraggable(element) {
            if (!element) return;

            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                // Don't drag if clicking on interactive elements
                const tagName = e.target.tagName;
                const classList = e.target.classList;

                // Exclude interactive elements
                if (tagName === 'BUTTON' || tagName === 'INPUT' || tagName === 'SELECT' ||
                    tagName === 'VIDEO' || tagName === 'A' || tagName === 'TEXTAREA') {
                    return;
                }

                // Exclude specific classes
                if (classList.contains('screen-list') || classList.contains('slider') ||
                    classList.contains('param-row') || classList.contains('slider-wrapper') ||
                    classList.contains('video-controls') || classList.contains('timeline-container') ||
                    classList.contains('preview') || classList.contains('arrow-btn') ||
                    classList.contains('value')) {
                    return;
                }

                // Only drag from the title or empty areas
                // Allow drag from h2, h3, or the main container background
                const isTitle = tagName === 'H2' || tagName === 'H3';
                const isContainer = e.target === element;

                if (!isTitle && !isContainer) {
                    return;
                }

                e.preventDefault();
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                element.style.cursor = 'grabbing';
            }

            function elementDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                const newTop = element.offsetTop - pos2;
                const newLeft = element.offsetLeft - pos1;

                // Keep within viewport bounds
                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;

                element.style.top = Math.max(0, Math.min(newTop, maxY)) + "px";
                element.style.left = Math.max(0, Math.min(newLeft, maxX)) + "px";
                element.style.bottom = "auto";
                element.style.right = "auto";
            }

            function closeDragElement() {
                isDragging = false;
                document.onmouseup = null;
                document.onmousemove = null;
                element.style.cursor = 'move';
            }
        }

        // Audio system with progressive fade
        let backgroundMusic = null;
        let footstepSound = null;
        let isPaused = false;
        let lastPauseToggleTime = 0; // Debounce pour éviter double ESC
        const PAUSE_DEBOUNCE_MS = 300; // Délai minimum entre toggles pause
        let lastFullscreenExitTime = 0; // Track fullscreen exit to prevent ESC re-entry

        // Instructions timer (hide after 5 seconds)
        // Track keyboard interactions instead of time
        let uniqueKeysPressed = new Set();
        let scrollCount = 0; // Compteur de scrolls pour cacher les instructions
        let instructionsHidden = false;
        const REQUIRED_UNIQUE_KEYS = 2;  // Au moins 2 touches distinctes
        const REQUIRED_SCROLLS = 3;      // Au moins 3 scrolls après les touches
        const KEY_HOLD_DURATION = 1000;  // Ou 1 touche maintenue ≥ 1 seconde
        let keyHoldTimer = null;
        let keyHoldStartTime = null;

        // Legacy audio variables (for backward compatibility)
        let targetVolume = 0.7;
        let currentVolume = 0.7;
        let volumeFadeInterval = null;
        let isMuted = false;

        // ═══════════════════════════════════════════════════════════════
        // AUDIO MANAGER - Professional audio system
        // ═══════════════════════════════════════════════════════════════
        const AudioManager = {
            // State
            music: null,
            clickSound: null,
            audioContext: null,
            clickBuffer: null,
            masterVolume: 0.3,
            currentMusicVolume: 0.3,
            isMuted: false,
            fadeInterval: null,

            // Initialize audio system
            init() {
                // Background music
                this.music = new Audio('son/Teimo.mp3');
                this.music.loop = true;
                this.music.volume = this.masterVolume;
                this.currentMusicVolume = this.masterVolume;

                // Web Audio Context for instant UI sounds (zero latency)
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Pre-decode click sound into AudioBuffer for instant playback
                    fetch('son/immersivecontrol-button-click-sound-463065.mp3')
                        .then(r => r.arrayBuffer())
                        .then(buf => this.audioContext.decodeAudioData(buf))
                        .then(decoded => {
                            this.clickBuffer = decoded;
                            console.log('🔊 Click sound pre-decoded (Web Audio API)');
                        })
                        .catch(e => console.warn('Click buffer decode error:', e));
                } catch(e) {
                    console.warn('Web Audio API not supported');
                }

                // Fallback HTML Audio click sound
                this.clickSound = new Audio('son/immersivecontrol-button-click-sound-463065.mp3');
                this.clickSound.volume = 0.5;

                console.log('🔊 AudioManager initialized');
            },

            // Play background music
            playMusic() {
                if (!this.music) return;

                this.music.play().catch(err => {
                    console.warn('⚠️ Autoplay blocked:', err);
                });
                this.fadeMusicTo(this.masterVolume, 500);
            },

            // Pause background music
            pauseMusic() {
                if (!this.music) return;

                this.fadeMusicTo(0, 500);
                setTimeout(() => {
                    if (this.music) this.music.pause();
                }, 500);
            },

            // Fade music volume
            fadeMusicTo(targetVolume, duration = 800) {
                if (this.fadeInterval) clearInterval(this.fadeInterval);

                const steps = 30;
                const stepDuration = duration / steps;
                const volumeDelta = (targetVolume - this.currentMusicVolume) / steps;

                let step = 0;
                this.fadeInterval = setInterval(() => {
                    step++;
                    this.currentMusicVolume += volumeDelta;

                    if (!this.isMuted && this.music) {
                        this.music.volume = Math.max(0, Math.min(1, this.currentMusicVolume));
                    }

                    if (step >= steps) {
                        clearInterval(this.fadeInterval);
                        this.fadeInterval = null;
                        this.currentMusicVolume = targetVolume;
                    }
                }, stepDuration);
            },

            // Set master volume
            setVolume(volume) {
                this.masterVolume = volume;
                if (!this.isMuted && this.music) {
                    this.music.volume = volume;
                    this.currentMusicVolume = volume;
                }
            },

            // Toggle mute
            toggleMute() {
                this.isMuted = !this.isMuted;

                const soundWaves = document.getElementById('sound-waves');
                const muteSlash = document.getElementById('mute-slash');

                if (this.isMuted) {
                    // Mute everything
                    if (this.music) this.music.volume = 0;
                    soundWaves.style.display = 'none';
                    muteSlash.style.display = 'block';
                } else {
                    // Unmute
                    if (this.music) this.music.volume = this.currentMusicVolume;
                    soundWaves.style.display = 'block';
                    muteSlash.style.display = 'none';

                    // Play confirmation sound
                    this.playClick();
                }
            },

            // Play click sound (Web Audio API for zero-latency)
            playClick() {
                if (this.isMuted) return;

                // Primary: Web Audio API with pre-decoded buffer (instant, no delay)
                if (this.audioContext && this.clickBuffer) {
                    try {
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                        const source = this.audioContext.createBufferSource();
                        const gainNode = this.audioContext.createGain();
                        source.buffer = this.clickBuffer;
                        gainNode.gain.value = 0.5 * this.masterVolume;
                        source.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        source.start(0);
                        return;
                    } catch(e) {
                        // Fall through to HTML Audio fallback
                    }
                }

                // Fallback: HTML Audio element
                if (this.clickSound) {
                    try {
                        this.clickSound.currentTime = 0;
                        this.clickSound.volume = 0.5 * this.masterVolume;
                        this.clickSound.play().catch(() => {});
                    } catch(e) {}
                }
            }
        };

        // Legacy function wrappers (for backward compatibility)
        function initAudio() {
            AudioManager.init();
            backgroundMusic = AudioManager.music;
        }

        function playClickSound() {
            AudioManager.playClick();
        }

        function playAudio() {
            AudioManager.playMusic();
        }

        function pauseAudio() {
            AudioManager.pauseMusic();
        }

        function fadeVolume(target, duration = 800) {
            AudioManager.fadeMusicTo(target, duration);
        }

        function updateVolume(value) {
            const volumePercent = parseInt(value);

            const newVolume = volumePercent / 100;
            AudioManager.setVolume(newVolume);

            // Update legacy variables
            targetVolume = newVolume;
            currentVolume = newVolume;
        }

        function toggleMute() {
            AudioManager.toggleMute();
            isMuted = AudioManager.isMuted;
        }

        // Footstep sounds (trigger when moving)
        let footstepTimer = 0;
        let isMoving = false;
        function playFootsteps() {
            // Placeholder - add footstep sound file if you have one
            // if (footstepSound && fpsMode) {
            //     footstepSound.currentTime = 0;
            //     footstepSound.play().catch(err => {});
            // }
        }

        // Welcome screen functions
        window.handlePlayClick = function() {
            playClickSound(); // Click feedback

            // Request fullscreen immediately (user gesture required — click IS a valid gesture)
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                const el = document.documentElement;
                if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            }

            // Phase 1: Fondu au noir (texte + bouton disparaissent)
            document.body.classList.remove('hoverPlay');
            document.body.classList.add('clickedPlay');

            // Phase 2: Après le fondu du texte (320ms), faire disparaître le logo PNG
            const fadeMs = 350; // Légèrement après --clickFadeMs (320ms)
            setTimeout(() => {
                const logoStatic = document.getElementById('welcome-logo');
                if (logoStatic) {
                    logoStatic.style.opacity = '0'; // Fade out (200ms CSS transition)
                }

                // Phase 3: Attendre que le logo soit totalement invisible, puis lancer le loading screen
                // 250ms = 200ms (transition CSS opacity logo) + 50ms (marge de sécurité)
                setTimeout(() => {
                    startExperience();
                }, 250);
            }, fadeMs);
        }

        // Gérer le hover sur le bouton play
        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('mouseenter', () => {
                document.body.classList.add('hoverPlay');
            });

            playButton.addEventListener('mouseleave', () => {
                if (!document.body.classList.contains('clickedPlay')) {
                    document.body.classList.remove('hoverPlay');
                }
            });
        }

        function startExperience() {
            const welcomeScreen = document.getElementById('welcome-screen');
            const loadingScreen = document.getElementById('loading-screen');

            // Hide welcome screen instantly (fade overlay is already black from clickedPlay)
            welcomeScreen.style.transition = 'none';
            welcomeScreen.style.opacity = '0';
            welcomeScreen.style.pointerEvents = 'none';

            // Show loading screen IMMEDIATELY
            loadingScreen.classList.add('active');
            loadingScreen.classList.remove('hidden');

            // Immediately hide cursor - user should enter FPS mode directly
            document.body.style.cursor = 'none';

            // Start the auto-load sequence after welcome screen
            setTimeout(() => {
                welcomeScreen.style.display = 'none';
                init();
                setupFPSSettings();

                // Make panels draggable
                makeDraggable(document.getElementById('screen-manager-panel'));
                makeDraggable(document.getElementById('fps-settings-panel'));
                makeDraggable(document.getElementById('ui'));

                // Setup pause screen click handler (click anywhere to resume)
                document.getElementById('pause-screen').addEventListener('click', function(e) {
                    // Only resume if clicking on the background (not on controls)
                    if (e.target.id === 'pause-screen') {
                        resumeExperience();
                    }
                });

                // Alt key opens/closes info/pause screen
                document.addEventListener('keydown', function(e) {
                    if (e.code === 'AltLeft' || e.code === 'AltRight') {
                        if (!fpsMode) return;
                        e.preventDefault();
                        if (isPaused) {
                            resumeExperience();
                        } else {
                            // Release pointer lock if active
                            if (document.exitPointerLock) {
                                document.exitPointerLock();
                            }
                            showPauseScreen();
                        }
                    }
                });

                // Track fullscreen exits to prevent ESC from re-entering immediately
                document.addEventListener('fullscreenchange', function() {
                    if (!document.fullscreenElement) {
                        lastFullscreenExitTime = performance.now();
                    }
                    updateFullscreenIcon();
                    updateEscInstructionVisibility();
                });
                document.addEventListener('webkitfullscreenchange', function() {
                    if (!document.webkitFullscreenElement) {
                        lastFullscreenExitTime = performance.now();
                    }
                    updateFullscreenIcon();
                    updateEscInstructionVisibility();
                });

                autoLoadSequence();
            }, 100);
        }

        // Pause screen functions
        function showPauseScreen() {
            if (!fpsMode) return; // Only in Spectator mode

            // Debounce: évite la double action ESC
            const now = performance.now();
            if (now - lastPauseToggleTime < PAUSE_DEBOUNCE_MS) {
                console.log('⏳ showPauseScreen ignoré (debounce)');
                return;
            }
            lastPauseToggleTime = now;

            isPaused = true;
            document.getElementById('pause-screen').classList.add('active');

            // Update fullscreen icon in pause panel
            updateFullscreenIcon();

            // Mobile: cacher contrôles et instructions, transformer bouton info en croix
            if (isMobile) {
                document.getElementById('gyro-toggle-btn')?.classList.add('hidden');
                document.getElementById('manual-toggle-btn')?.classList.add('hidden');
                document.getElementById('mobile-joystick')?.classList.add('hidden');
                document.getElementById('mobile-fullscreen-btn')?.classList.add('hidden');
                document.getElementById('mobile-pause-btn')?.classList.add('active-infos');
                const mobileInstr = document.getElementById('mobile-instructions');
                if (mobileInstr) mobileInstr.classList.add('hidden');
            }

            // Volume constant - pas de fade
            // Note: Pointer lock is automatically released by ESC key before this function is called
        }

        function resumeExperience() {
            playClickSound(); // Satisfying click feedback

            // Debounce: évite la double action ESC
            lastPauseToggleTime = performance.now();

            isPaused = false;
            document.getElementById('pause-screen').classList.remove('active');

            // Réafficher les contrôles mobiles, retransformer croix en info
            if (isMobile) {
                document.getElementById('mobile-pause-btn')?.classList.remove('active-infos');
                const gyroToggle = document.getElementById('gyro-toggle-btn');
                if (gyroToggle) {
                    gyroToggle.classList.remove('hidden');
                    gyroToggle.style.display = 'flex';
                }
                const manualToggle = document.getElementById('manual-toggle-btn');
                if (manualToggle) {
                    manualToggle.classList.remove('hidden');
                    manualToggle.style.display = 'flex';
                }
                document.getElementById('mobile-joystick')?.classList.remove('hidden');
                const fsBtn = document.getElementById('mobile-fullscreen-btn');
                if (fsBtn) {
                    fsBtn.classList.remove('hidden');
                    fsBtn.style.display = 'flex';
                }
            }

            // Volume constant - pas de fade

            // Request pointer lock (desktop only) — may fail if not triggered by user gesture
            if (fpsMode && renderer && renderer.domElement && !isMobile) {
                const p = renderer.domElement.requestPointerLock();
                if (p && p.catch) p.catch(() => console.log('🔒 Pointer lock sera activé au prochain clic'));
            }
        }

        window.onload = function() {
            // Don't auto-start - wait for user interaction on welcome screen
            initAudio();
            console.log('═══════════════════════════════════════════════════════');
            console.log('📦 WINDOW.ONLOAD - Page chargée');
            console.log('💡 Cliquez sur PLAY pour démarrer');
            console.log('═══════════════════════════════════════════════════════');

            // Remove initial black loader
            const initialLoader = document.getElementById('initial-loader');
            if (initialLoader) {
                initialLoader.classList.add('fade-out');
                setTimeout(() => {
                    initialLoader.remove();
                }, 300);
            }

            // Handle background video loading
            const welcomeVideo = document.getElementById('welcome-video-bg');
            if (welcomeVideo) {
                if (welcomeVideo.readyState >= 3) {
                    welcomeVideo.classList.add('loaded');
                    console.log('✅ Vidéo d\'arrière-plan déjà prête');
                } else {
                    welcomeVideo.addEventListener('canplaythrough', function() {
                        welcomeVideo.classList.add('loaded');
                        console.log('✅ Vidéo d\'arrière-plan chargée');
                    });
                }

                welcomeVideo.addEventListener('error', function() {
                    console.log('⚠️ Vidéo d\'arrière-plan non disponible - fond noir utilisé');
                    welcomeVideo.style.display = 'none';
                });
            }
        };

        // Helper: keep loading video alive during heavy JS work
        function ensureLoadingVideoPlaying() {
            const loadingVideo = document.querySelector('#loading-screen .loading-video');
            if (loadingVideo && loadingVideo.paused) {
                loadingVideo.play().catch(() => {});
            }
        }

        // Auto-load sequence: Load default video → Activate FPS → Show UI → Apply
        async function autoLoadSequence() {
            const loadingScreen = document.getElementById('loading-screen');
            const revealOverlay = document.getElementById('scene-reveal-overlay');

            // Activate reveal overlay (solid black behind loading screen)
            revealOverlay.classList.add('active');

            try {
                // Step 1: Load videos for all volumetric screens
                console.log('🎬 AUTO-LOAD: Chargement des vidéos multi-écrans...');
                ensureLoadingVideoPlaying();
                await loadVolumetricScreenVideos();

                // Fallback: also load default video for backward compatibility
                ensureLoadingVideoPlaying();
                await loadDefaultVideo();
                await sleep(500);

                // Step 2: Activate FPS mode (Spectator mode)
                console.log('🎮 AUTO-LOAD: Activation du mode SPECTATEUR...');
                fpsMode = true;

                // Hide all interfaces in Spectator mode
                document.getElementById('ui')?.classList.add('hidden');
                document.getElementById('screen-manager-panel')?.classList.add('hidden');
                document.getElementById('shape-selector')?.classList.add('hidden');
                document.getElementById('fps-settings-panel')?.classList.add('hidden');
                document.getElementById('fps-counter')?.classList.add('hidden');

                // Play background music in Spectator mode
                playAudio();
                ensureLoadingVideoPlaying();
                await sleep(300);

                // Step 3: Apply settings
                // Yield to browser so loading video/animation stays alive before heavy work
                console.log('⚙️ AUTO-LOAD: Application des paramètres...');
                ensureLoadingVideoPlaying();
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                applySettings();
                // Yield again after heavy work to let compositor recover
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                // Force re-play loading video after heavy applySettings work
                ensureLoadingVideoPlaying();
                await sleep(300);

                // Step 4: Synchroniser et lancer toutes les vidéos ensemble
                console.log('🔄 AUTO-LOAD: Synchronisation des vidéos...');
                ensureLoadingVideoPlaying();
                syncStartAllVideos();
                await sleep(200);

                // Step 5: Wait for first frame to render before hiding loading screen
                console.log('✅ AUTO-LOAD: Séquence terminée!');
                // Let the 3D scene render a few frames before revealing
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(() => requestAnimationFrame(r))));
                await sleep(300);

                // Step 6: Hide loading screen (reveal overlay stays black behind it)
                loadingScreen.classList.add('hidden');

                // After loading screen fades out (500ms), trigger the fade-from-black reveal
                setTimeout(() => {
                    loadingScreen.style.display = 'none';

                    // Now fade the black overlay to transparent — smooth reveal of 3D scene
                    revealOverlay.classList.add('revealed');

                    // Remove overlay from DOM after transition completes (1200ms)
                    setTimeout(() => {
                        revealOverlay.style.display = 'none';
                    }, 1300);
                }, 550);

                // Fullscreen is already requested from handlePlayClick (user gesture)

                // Request pointer lock — may fail as setTimeout breaks user gesture chain
                // The click handler on the canvas will request it on next click
                const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 2);
                setTimeout(() => {
                    if (fpsMode && renderer && renderer.domElement && !isMobileDevice) {
                        console.log('🔒 Demande de pointer lock automatique...');
                        const p = renderer.domElement.requestPointerLock();
                        if (p && p.catch) p.catch(() => console.log('🔒 Pointer lock sera activé au prochain clic'));
                    }
                }, 800);

            } catch (error) {
                console.error('❌ AUTO-LOAD: Erreur:', error);

                // Hide loading screen anyway after 2s with fade-from-black reveal
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        revealOverlay.classList.add('revealed');
                        setTimeout(() => {
                            revealOverlay.style.display = 'none';
                        }, 1300);
                    }, 550);
                }, 2000);
            }
        }

        // Helper function to load default video (uses panoramic video if available, fallback to test_01.mp4)
        function loadDefaultVideo() {
            return new Promise((resolve, reject) => {
                // If panoramic video loaded, use it as main video
                if (screenVideos[1] && screenVideos[1].videoWidth > 0) {
                    console.log('✅ Utilisation de la vidéo panoramique comme vidéo principale');
                    currentVideo = screenVideos[1];

                    // Show preview (safe DOM construction)
                    const previewSrc = screenVideos[1].src;
                    const prevEl = document.getElementById('preview');
                    prevEl.textContent = '';
                    const pvid = document.createElement('video');
                    pvid.src = previewSrc;
                    pvid.muted = true;
                    pvid.loop = true;
                    pvid.playsInline = true;
                    pvid.style.cssText = 'max-width:100%;max-height:100%';
                    prevEl.appendChild(pvid);
                    prevEl.classList.add('loaded');
                    pvid.play();

                    // Auto-apply
                    console.log('🎬 Apply automatique après chargement vidéo multi-écrans...');
                    applySettings();

                    setTimeout(() => {
                        console.log('🎬 Apply automatique (2ème passe)...');
                        applySettings();
                        resolve();
                    }, 100);
                    return;
                }

                // Fallback: load test_01.mp4
                const videoElement = document.getElementById('video-source');
                const videoPath = 'videos/test_01.mp4';

                videoElement.src = videoPath;
                videoElement.load();

                videoElement.onloadeddata = function() {
                    console.log('✅ Vidéo fallback chargée:', videoPath);
                    currentVideo = videoElement;

                    // CRITICAL: Start playing the source video
                    videoElement.muted = true;
                    videoElement.loop = true;
                    videoElement.play().catch(err => {
                        console.warn('⚠️ Autoplay vidéo source bloqué:', err);
                    });

                    // Show preview (safe DOM construction)
                    const prevEl2 = document.getElementById('preview');
                    prevEl2.textContent = '';
                    const pvid2 = document.createElement('video');
                    pvid2.src = videoPath;
                    pvid2.muted = true;
                    pvid2.loop = true;
                    pvid2.playsInline = true;
                    pvid2.style.cssText = 'max-width:100%;max-height:100%';
                    prevEl2.appendChild(pvid2);
                    prevEl2.classList.add('loaded');
                    pvid2.play();

                    // Auto-apply after loading
                    console.log('🎬 Apply automatique après chargement vidéo...');
                    applySettings();

                    // Second apply pass (like in original code)
                    setTimeout(() => {
                        console.log('🎬 Apply automatique (2ème passe)...');
                        applySettings();
                        resolve();
                    }, 100);
                };

                videoElement.onerror = function(error) {
                    console.error('❌ Erreur chargement vidéo:', error);
                    reject(error);
                };

                // Timeout fallback
                setTimeout(() => {
                    if (!currentVideo) {
                        reject(new Error('Timeout loading video'));
                    }
                }, 5000);
            });
        }

        // Charger la vidéo de l'écran 6 (sol)
        let floorVideo = null;
        async function loadFloorVideo() {
            return new Promise((resolve) => {
                const videoElement = document.createElement('video');
                videoElement.id = 'video-floor';
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.playsInline = true;
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);

                const primaryPath = 'videos/ecran_06.webm';
                const fallbackPath = 'videos/test_01.mp4';

                function onVideoReady(loadedPath) {
                    console.log(`✅ Vidéo écran 6 chargée: ${loadedPath}`);
                    console.log(`   Dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);

                    floorVideo = videoElement;
                    screenVideos[6] = videoElement;

                    videoElement.currentTime = 0.1;
                    videoElement.play().then(() => {
                        setTimeout(() => {
                            videoElement.pause();
                            console.log('🏠 Vidéo écran 6 prête');
                            resolve(true);
                        }, 100);
                    }).catch(() => {
                        resolve(true);
                    });
                }

                let videoReady = false;
                videoElement.oncanplaythrough = function() {
                    if (videoReady) return;
                    videoReady = true;
                    videoElement.oncanplaythrough = null;
                    onVideoReady(primaryPath);
                };

                videoElement.onerror = function() {
                    console.warn('⚠️ Vidéo écran 6 non trouvée:', primaryPath, '→ fallback test_01.mp4');
                    videoReady = false;
                    videoElement.onerror = null;

                    videoElement.oncanplaythrough = function() {
                        if (videoReady) return;
                        videoReady = true;
                        videoElement.oncanplaythrough = null;
                        onVideoReady(fallbackPath);
                    };
                    videoElement.onerror = function() {
                        console.warn('⚠️ Fallback vidéo écran 6 non trouvée:', fallbackPath);
                        resolve(false);
                    };

                    videoElement.src = fallbackPath;
                    videoElement.load();
                };

                videoElement.src = primaryPath;
                videoElement.load();

                setTimeout(() => {
                    if (!floorVideo) resolve(false);
                }, 10000);
            });
        }

        // PANORAMIC VIDEO SYSTEM: Load single panoramic video for all screens
        async function loadVolumetricScreenVideos() {
            console.log('🎬 Tentative de chargement de la vidéo panoramique...');

            // Charger aussi la vidéo du sol en parallèle
            loadFloorVideo();

            return new Promise((resolve) => {
                // Create hidden video element for panoramic video
                const videoElement = document.createElement('video');
                videoElement.id = 'video-panorama';
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.playsInline = true;
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);

                // Try to load panoramic video with fallback
                const videoPaths = ['videos/ecran_panorama_v2.webm', 'videos/ecran_panorama.webm', 'videos/panorama_opti.webm'];
                let currentPathIndex = 0;

                function tryLoadVideo(pathIndex) {
                    if (pathIndex >= videoPaths.length) {
                        console.log('Aucune vidéo panoramique disponible');
                        panoramicVideo = null;
                        resolve(false);
                        return;
                    }

                    const videoPath = videoPaths[pathIndex];
                    console.log('Tentative chargement:', videoPath);
                    videoElement.src = videoPath;
                    videoElement.load();

                    let videoReady = false;
                    videoElement.oncanplaythrough = function() {
                        if (videoReady) return;
                        videoReady = true;
                        videoElement.oncanplaythrough = null;
                        videoElement.onerror = null;

                        console.log('Vidéo panoramique chargée:', videoPath,
                            videoElement.videoWidth + 'x' + videoElement.videoHeight);

                        panoramicVideo = videoElement;
                        screenVideos[1] = videoElement;

                        videoElement.currentTime = 0.1;
                        videoElement.play().then(() => {
                            setTimeout(() => {
                                videoElement.pause();
                                console.log('Mode panoramique activé');
                                resolve(true);
                            }, 100);
                        }).catch(() => {
                            console.log('Mode panoramique activé');
                            resolve(true);
                        });
                    };

                    videoElement.onerror = function() {
                        console.log('Vidéo non trouvée:', videoPath);
                        tryLoadVideo(pathIndex + 1);
                    };
                }

                tryLoadVideo(0);

                // Timeout fallback
                setTimeout(() => {
                    if (!panoramicVideo) {
                        console.log('Timeout chargement vidéo panoramique');
                        resolve(false);
                    }
                }, 15000);
            });
        }

        // Synchroniser et lancer toutes les vidéos en même temps
        function syncStartAllVideos() {
            console.log('🔄 Synchronisation et lancement de toutes les vidéos...');

            // Lancer la vidéo du sol si disponible
            if (floorVideo) {
                floorVideo.currentTime = 0;
                floorVideo.play().catch(err => {
                    console.warn('⚠️ Erreur play sol:', err);
                });
                console.log('✅ Vidéo sol lancée');
            }

            // Mode panoramique: vidéo principale
            if (panoramicVideo) {
                panoramicVideo.currentTime = 0;
                panoramicVideo.play().catch(err => {
                    console.warn('⚠️ Erreur play panorama:', err);
                });
                console.log('✅ Vidéo panoramique lancée');
                return;
            }

            // Mode multi-vidéos: synchroniser toutes les vidéos
            const videos = Object.values(screenVideos).filter(v => v && v.videoWidth > 0);

            if (videos.length === 0) {
                console.warn('⚠️ Aucune vidéo à synchroniser');
                return;
            }

            // Mettre toutes les vidéos à 0 et les lancer en même temps
            videos.forEach(video => {
                video.currentTime = 0;
            });

            // Petit délai pour s'assurer que currentTime est appliqué
            setTimeout(() => {
                videos.forEach(video => {
                    video.play().catch(err => {
                        console.warn('⚠️ Erreur play:', err);
                    });
                });
                console.log(`✅ ${videos.length} vidéos lancées en synchronisation`);
            }, 50);
        }

        // Helper sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /* ═══════════════════════════════════════════════════════════════
           MOBILE CONTROLS - Gyroscope, Joystick, Pull-to-refresh
           ═══════════════════════════════════════════════════════════════ */

        // Détection mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

        // Variables globales mobile
        let gyroEnabled = false;
        let gyroPermissionGranted = false;
        let initialAlpha = null;
        let initialBeta = null;
        let initialGamma = null;
        let baseYaw = 0;
        let basePitch = 0;
        let joystickActive = false;
        let joystickData = { x: 0, y: 0 };
        let mobileSpeedMultiplier = 0; // Analog joystick multiplier (0-1)
        let mobileInstructionsHidden = false;
        let touchDragEnabled = true; // Mode tap-and-drag actif par défaut (manuel)
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Professional mobile control state
        let _gyroFilteredYaw = 0;
        let _gyroFilteredPitch = 0;
        let _gyroLastTimestamp = 0;
        let _touchVelocityX = 0;
        let _touchVelocityY = 0;
        let _touchLastMoveTime = 0;
        let _touchMomentumRAF = null;

        // ═══════════════════════════════════════════════════════════════
        // VISIBILITY CHANGE - Couper le son quand page inactive
        // ═══════════════════════════════════════════════════════════════
        let wasPlayingBeforeHidden = false;

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page cachee (telephone verrouille, onglet change, etc.)
                if (AudioManager.music && !AudioManager.music.paused) {
                    wasPlayingBeforeHidden = true;
                    AudioManager.music.pause();
                }
            } else {
                // Page redevient visible
                if (wasPlayingBeforeHidden && AudioManager.music && fpsMode && !isPaused) {
                    AudioManager.music.play().catch(() => {});
                    wasPlayingBeforeHidden = false;
                }
            }
        });

        // Aussi gerer pagehide pour iOS Safari
        window.addEventListener('pagehide', () => {
            if (AudioManager.music) {
                AudioManager.music.pause();
            }
        });

        // ═══════════════════════════════════════════════════════════════
        // VOLUME SLIDER DYNAMIQUE
        // ═══════════════════════════════════════════════════════════════
        let volumeSliderTimeout = null;

        window.showVolumeSlider = function() {
            const volumeControl = document.getElementById('volume-control');
            if (volumeControl) {
                volumeControl.classList.add('active');
                // Auto-hide apres 3 secondes d'inactivite
                clearTimeout(volumeSliderTimeout);
                volumeSliderTimeout = setTimeout(() => {
                    hideVolumeSlider();
                }, 3000);
            }
        };

        window.hideVolumeSlider = function() {
            const volumeControl = document.getElementById('volume-control');
            if (volumeControl) {
                volumeControl.classList.remove('active');
            }
        };

        // Garder ouvert si on interagit avec le slider
        document.addEventListener('DOMContentLoaded', () => {
            const slider = document.getElementById('volume-slider');
            if (slider) {
                slider.addEventListener('input', () => {
                    clearTimeout(volumeSliderTimeout);
                    volumeSliderTimeout = setTimeout(() => {
                        hideVolumeSlider();
                    }, 3000);
                });
                slider.addEventListener('touchstart', () => {
                    clearTimeout(volumeSliderTimeout);
                });
                slider.addEventListener('touchend', () => {
                    volumeSliderTimeout = setTimeout(() => {
                        hideVolumeSlider();
                    }, 2000);
                });
            }
        });

        // ═══════════════════════════════════════════════════════════════
        // FULLSCREEN API
        // ═══════════════════════════════════════════════════════════════
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(() => {});
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // PULL-TO-REFRESH (Welcome screen only)
        // ═══════════════════════════════════════════════════════════════
        let ptrStartY = 0;
        let ptrCurrentY = 0;
        let ptrTriggered = false;
        const PTR_THRESHOLD = 80;

        function initPullToRefresh() {
            if (!isMobile) return;

            const welcomeScreen = document.getElementById('welcome-screen');
            const ptrIndicator = document.getElementById('pull-to-refresh');

            if (!welcomeScreen || !ptrIndicator) return;

            welcomeScreen.addEventListener('touchstart', (e) => {
                if (welcomeScreen.scrollTop === 0) {
                    ptrStartY = e.touches[0].clientY;
                    ptrIndicator.classList.add('visible');
                }
            }, { passive: true });

            welcomeScreen.addEventListener('touchmove', (e) => {
                if (ptrStartY === 0) return;

                ptrCurrentY = e.touches[0].clientY;
                const pullDistance = ptrCurrentY - ptrStartY;

                if (pullDistance > 0 && welcomeScreen.scrollTop === 0) {
                    if (pullDistance > PTR_THRESHOLD) {
                        ptrIndicator.classList.add('pulling');
                        ptrTriggered = true;
                    } else {
                        ptrIndicator.classList.remove('pulling');
                        ptrTriggered = false;
                    }
                }
            }, { passive: true });

            welcomeScreen.addEventListener('touchend', () => {
                if (ptrTriggered) {
                    const ptrIndicator = document.getElementById('pull-to-refresh');
                    ptrIndicator.classList.add('loading');
                    ptrIndicator.querySelector('.ptr-text').textContent = 'Actualisation...';

                    setTimeout(() => {
                        location.reload();
                    }, 500);
                } else {
                    ptrIndicator.classList.remove('visible', 'pulling');
                }
                ptrStartY = 0;
                ptrTriggered = false;
            }, { passive: true });
        }

        // ═══════════════════════════════════════════════════════════════
        // GYROSCOPE CAMERA CONTROL
        // ═══════════════════════════════════════════════════════════════
        window.requestGyroPermission = async function() {
            const permissionBtn = document.getElementById('gyro-permission-btn');

            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        gyroPermissionGranted = true;
                        enableGyroscope();
                        permissionBtn.style.display = 'none';
                    }
                } catch (error) {
                    console.warn('Gyroscope permission denied:', error);
                    permissionBtn.style.display = 'none';
                }
            } else {
                // Non-iOS ou ancien navigateur
                gyroPermissionGranted = true;
                enableGyroscope();
                permissionBtn.style.display = 'none';
            }
        };

        function enableGyroscope() {
            if (!isMobile || gyroEnabled) return;

            window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            gyroEnabled = true;
            console.log('📱 Gyroscope activé');
        }

        function handleDeviceOrientation(event) {
            if (!fpsMode || isPaused || !gyroEnabled || touchDragEnabled) return;

            const alpha = event.alpha || 0; // Compass/yaw (Z rotation)
            const beta = event.beta || 0;   // Pitch (X tilt front/back)
            const gamma = event.gamma || 0; // Roll (Y tilt left/right)

            // Time-based smoothing for frame-rate independence
            const now = performance.now();
            const dt = _gyroLastTimestamp ? Math.min((now - _gyroLastTimestamp) / 1000, 0.1) : 0.016;
            _gyroLastTimestamp = now;

            // Initialize reference on first event
            if (initialAlpha === null) {
                initialAlpha = alpha;
                initialBeta = beta;
                initialGamma = gamma;
                baseYaw = cameraYaw;
                basePitch = cameraPitch;
                _gyroFilteredYaw = 0;
                _gyroFilteredPitch = 0;
                return;
            }

            // Compute deltas from reference orientation
            let deltaAlpha = alpha - initialAlpha;
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;

            let deltaBeta = beta - initialBeta;

            // Dead zone: filter micro-movements from hand tremor (1.5 degrees)
            const DEAD_ZONE = 1.5;
            if (Math.abs(deltaAlpha) < DEAD_ZONE) deltaAlpha = 0;
            else deltaAlpha = (deltaAlpha - Math.sign(deltaAlpha) * DEAD_ZONE);

            if (Math.abs(deltaBeta) < DEAD_ZONE) deltaBeta = 0;
            else deltaBeta = (deltaBeta - Math.sign(deltaBeta) * DEAD_ZONE);

            // Tuned sensitivity - higher for responsive feel
            const yawSensitivity = 0.028;
            const pitchSensitivity = 0.022;

            // Calibration: offset pitch down ~70° so perpendicular phone = looking forward
            const GYRO_PITCH_OFFSET = -(70 * Math.PI / 180); // -1.22 radians

            // Target orientation (yaw inverted for correct left/right)
            const rawTargetYaw = baseYaw + (deltaAlpha * yawSensitivity);
            const rawTargetPitch = basePitch + (deltaBeta * pitchSensitivity) + GYRO_PITCH_OFFSET;

            // Low-pass filter (exponential moving average, frame-rate independent)
            // Higher SMOOTH_FACTOR = more responsive, lower = smoother
            const SMOOTH_FACTOR = 10;
            const filterAlpha = 1 - Math.exp(-SMOOTH_FACTOR * dt);

            _gyroFilteredYaw += (rawTargetYaw - _gyroFilteredYaw) * filterAlpha;
            _gyroFilteredPitch += (rawTargetPitch - _gyroFilteredPitch) * filterAlpha;

            // Clamp pitch (wider range to accommodate calibration offset)
            const maxPitch = Math.PI / 2;
            _gyroFilteredPitch = Math.max(-maxPitch, Math.min(maxPitch, _gyroFilteredPitch));

            cameraYaw = _gyroFilteredYaw;
            cameraPitch = _gyroFilteredPitch;
        }

        // Reset gyroscope reference orientation
        function resetGyroReference() {
            initialAlpha = null;
            initialBeta = null;
            initialGamma = null;
            baseYaw = cameraYaw;
            basePitch = cameraPitch;
            _gyroFilteredYaw = cameraYaw;
            _gyroFilteredPitch = cameraPitch;
            _gyroLastTimestamp = 0;
        }

        // ═══════════════════════════════════════════════════════════════
        // JOYSTICK TACTILE
        // ═══════════════════════════════════════════════════════════════
        function initJoystick() {
            if (!isMobile) return;

            const joystick = document.getElementById('mobile-joystick');
            const thumb = joystick?.querySelector('.joystick-thumb');

            if (!joystick || !thumb) return;

            // Variables recalculees au premier touch (quand visible)
            let baseRadius = 0;
            let maxDistance = 0;
            let touchId = null;
            let centerX = 0;
            let centerY = 0;

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchId !== null) return;

                // Recalculer les dimensions maintenant que le joystick est visible
                if (baseRadius === 0) {
                    baseRadius = joystick.offsetWidth / 2;
                    maxDistance = baseRadius - (thumb.offsetWidth / 2);
                    if (maxDistance <= 0) maxDistance = 35; // Fallback
                }

                const touch = e.changedTouches[0];
                touchId = touch.identifier;

                const rect = joystick.getBoundingClientRect();
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;

                joystick.classList.add('active');
                updateJoystick(touch.clientX, touch.clientY);

                // Cacher instructions mobile au premier mouvement
                hideMobileInstructions();
            });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                        break;
                    }
                }
            });

            joystick.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        touchId = null;
                        joystick.classList.remove('active');
                        resetJoystick();
                        break;
                    }
                }
            });

            joystick.addEventListener('touchcancel', () => {
                touchId = null;
                joystick.classList.remove('active');
                resetJoystick();
            });

            function updateJoystick(clientX, clientY) {
                let deltaX = clientX - centerX;
                let deltaY = clientY - centerY;

                // Clamp to circle
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }

                // Update thumb visual
                thumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                // Normalize to -1..1
                const normX = deltaX / maxDistance;
                const normY = deltaY / maxDistance;

                // Dead zone with smooth ramp (0.15 threshold)
                const DEAD_ZONE = 0.15;
                const mag = Math.sqrt(normX * normX + normY * normY);
                if (mag < DEAD_ZONE) {
                    joystickData.x = 0;
                    joystickData.y = 0;
                    mobileSpeedMultiplier = 0;
                } else {
                    // Remap [DEAD_ZONE..1] to [0..1] with quadratic curve for fine control
                    const remapped = (mag - DEAD_ZONE) / (1 - DEAD_ZONE);
                    const curved = remapped * remapped; // Quadratic for precision near center
                    const angle = Math.atan2(normY, normX);
                    joystickData.x = Math.cos(angle) * curved;
                    joystickData.y = Math.sin(angle) * curved;
                    mobileSpeedMultiplier = curved;
                }
                joystickActive = mag >= DEAD_ZONE;
            }

            function resetJoystick() {
                thumb.style.transform = 'translate(-50%, -50%)';
                joystickData.x = 0;
                joystickData.y = 0;
                mobileSpeedMultiplier = 0;
                joystickActive = false;
            }
        }

        // Apply analog joystick movement to camera (MOBILE ONLY)
        function applyJoystickMovement() {
            if (!isMobile || !fpsMode || isPaused) return;

            if (!joystickActive) {
                cameraKeys.forward = false;
                cameraKeys.backward = false;
                cameraKeys.left = false;
                cameraKeys.right = false;
                mobileSpeedMultiplier = 0;
                return;
            }

            // Set direction keys based on joystick direction
            // The speed will be modulated by mobileSpeedMultiplier in the movement system
            const threshold = 0.01; // Very low since dead zone is already handled
            cameraKeys.forward = joystickData.y < -threshold;
            cameraKeys.backward = joystickData.y > threshold;
            cameraKeys.left = joystickData.x < -threshold;
            cameraKeys.right = joystickData.x > threshold;
        }

        // ═══════════════════════════════════════════════════════════════
        // GYROSCOPE TOGGLE ET TAP-AND-DRAG
        // ═══════════════════════════════════════════════════════════════
        function initGyroToggle() {
            if (!isMobile) return;

            const gyroBtn = document.getElementById('gyro-toggle-btn');
            const manualBtn = document.getElementById('manual-toggle-btn');

            if (gyroBtn) {
                gyroBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setControlMode('gyro');
                });
                gyroBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }

            if (manualBtn) {
                manualBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setControlMode('manual');
                });
                manualBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }
        }

        function setControlMode(mode) {
            const gyroBtn = document.getElementById('gyro-toggle-btn');
            const manualBtn = document.getElementById('manual-toggle-btn');

            if (mode === 'gyro') {
                touchDragEnabled = false;
                gyroBtn?.classList.add('mode-active');
                manualBtn?.classList.remove('mode-active');
                resetGyroReference();
                console.log('Mode gyroscope activé');
            } else {
                touchDragEnabled = true;
                manualBtn?.classList.add('mode-active');
                gyroBtn?.classList.remove('mode-active');
                resetGyroReference();
                console.log('Mode manuel activé');
            }
        }

        function initTouchDrag() {
            if (!isMobile) return;

            const canvas = document.getElementById('canvas');
            if (!canvas) return;

            let touchId = null;
            let prevTouchX = 0;
            let prevTouchY = 0;
            let touchActive = false;

            // Sensitivity tuned for natural feel (relative to screen size)
            const baseSensitivity = 0.004;

            document.addEventListener('touchstart', (e) => {
                if (!touchDragEnabled || !fpsMode || isPaused) return;
                if (touchId !== null) return;

                // Ignore UI controls
                if (e.target.closest('#mobile-joystick') ||
                    e.target.closest('#mobile-pause-btn') ||
                    e.target.closest('#mobile-fullscreen-btn') ||
                    e.target.closest('#gyro-toggle-btn') ||
                    e.target.closest('#manual-toggle-btn') ||
                    e.target.closest('.pause-controls')) return;

                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                prevTouchX = touch.clientX;
                prevTouchY = touch.clientY;
                touchActive = true;
                _touchVelocityX = 0;
                _touchVelocityY = 0;
                _touchLastMoveTime = performance.now();

                // Cancel any ongoing momentum animation
                if (_touchMomentumRAF) {
                    cancelAnimationFrame(_touchMomentumRAF);
                    _touchMomentumRAF = null;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!touchDragEnabled || !fpsMode || isPaused || !touchActive) return;

                let activeTouch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        activeTouch = e.changedTouches[i];
                        break;
                    }
                }
                if (!activeTouch) return;

                const touchX = activeTouch.clientX;
                const touchY = activeTouch.clientY;

                // Delta-based (frame-to-frame) for smoother continuous rotation
                const deltaX = touchX - prevTouchX;
                const deltaY = touchY - prevTouchY;

                // Screen-relative sensitivity: scale by screen width for consistency
                const screenScale = 400 / Math.min(window.innerWidth, window.innerHeight);
                const sensitivity = baseSensitivity * screenScale;

                // Apply rotation (inverted for natural touch feel)
                cameraYaw += deltaX * sensitivity;
                cameraPitch -= deltaY * sensitivity;

                // Clamp pitch
                const maxPitch = Math.PI / 2.2;
                cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));

                // Track velocity for momentum (exponential moving average)
                const now = performance.now();
                const timeDelta = Math.max(now - _touchLastMoveTime, 1);
                const instantVelX = (deltaX * sensitivity) / (timeDelta / 16.67);
                const instantVelY = (deltaY * sensitivity) / (timeDelta / 16.67);
                _touchVelocityX = _touchVelocityX * 0.7 + instantVelX * 0.3;
                _touchVelocityY = _touchVelocityY * 0.7 + instantVelY * 0.3;
                _touchLastMoveTime = now;

                prevTouchX = touchX;
                prevTouchY = touchY;
            }, { passive: true });

            const handleTouchEnd = (e) => {
                if (!touchActive) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        touchId = null;
                        touchActive = false;

                        // Apply momentum if velocity is significant
                        const speed = Math.sqrt(_touchVelocityX * _touchVelocityX + _touchVelocityY * _touchVelocityY);
                        if (speed > 0.0005) {
                            applyTouchMomentum();
                        }
                        break;
                    }
                }
            };

            document.addEventListener('touchend', handleTouchEnd, { passive: true });
            document.addEventListener('touchcancel', handleTouchEnd, { passive: true });

            function applyTouchMomentum() {
                const FRICTION = 0.92; // Deceleration per frame
                const MIN_VELOCITY = 0.0002;

                function momentumStep() {
                    if (!touchDragEnabled || isPaused || touchActive) return;

                    _touchVelocityX *= FRICTION;
                    _touchVelocityY *= FRICTION;

                    cameraYaw += _touchVelocityX;
                    cameraPitch -= _touchVelocityY;

                    const maxPitch = Math.PI / 2.2;
                    cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));

                    const speed = Math.sqrt(_touchVelocityX * _touchVelocityX + _touchVelocityY * _touchVelocityY);
                    if (speed > MIN_VELOCITY) {
                        _touchMomentumRAF = requestAnimationFrame(momentumStep);
                    } else {
                        _touchMomentumRAF = null;
                    }
                }

                _touchMomentumRAF = requestAnimationFrame(momentumStep);
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE PAUSE BUTTON
        // ═══════════════════════════════════════════════════════════════
        function initMobilePauseButton() {
            if (!isMobile) return;

            const pauseBtn = document.getElementById('mobile-pause-btn');
            if (!pauseBtn) return;

            pauseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (isPaused) {
                    resumeExperience();
                } else {
                    showPauseScreen();
                }
            });

            // Empêcher les événements tactiles de se propager
            pauseBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: false });
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE FULLSCREEN BUTTON
        // ═══════════════════════════════════════════════════════════════
        function initMobileFullscreenButton() {
            if (!isMobile) return;

            const btn = document.getElementById('mobile-fullscreen-btn');
            if (!btn) return;

            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFullscreen();
            });

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFullscreen();
            }, { passive: false });
        }

        let _fsPending = false;
        function toggleFullscreen() {
            if (_fsPending) return;
            _fsPending = true;

            const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement);

            if (isFS) {
                const p = document.exitFullscreen ? document.exitFullscreen()
                        : document.webkitExitFullscreen ? (document.webkitExitFullscreen(), Promise.resolve())
                        : Promise.resolve();
                Promise.resolve(p).finally(() => { _fsPending = false; });
            } else {
                const el = document.documentElement;
                const p = el.requestFullscreen ? el.requestFullscreen()
                        : el.webkitRequestFullscreen ? (el.webkitRequestFullscreen(), Promise.resolve())
                        : Promise.resolve();
                Promise.resolve(p).catch(() => {}).finally(() => { _fsPending = false; });
            }
        }

        function updateFullscreenIcon() {
            const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement);
            // Update mobile button
            const btn = document.getElementById('mobile-fullscreen-btn');
            if (btn) {
                const enterIcon = btn.querySelector('.fs-enter-icon');
                const exitIcon = btn.querySelector('.fs-exit-icon');
                if (enterIcon) enterIcon.style.display = isFS ? 'none' : 'block';
                if (exitIcon) exitIcon.style.display = isFS ? 'block' : 'none';
            }
            // Update pause panel fullscreen button
            const pauseBtn = document.getElementById('pause-close-btn');
            if (pauseBtn) {
                const enterIcon = pauseBtn.querySelector('.fs-enter-icon');
                const exitIcon = pauseBtn.querySelector('.fs-exit-icon');
                if (enterIcon) enterIcon.style.display = isFS ? 'none' : 'block';
                if (exitIcon) exitIcon.style.display = isFS ? 'block' : 'none';
            }
        }

        function handlePauseFullscreenClick() {
            playClickSound();
            toggleFullscreen();
            // Ne ferme PAS le panneau info — seulement basculer le plein écran
        }

        function updateEscInstructionVisibility() {
            // ESC instruction is now always visible in persistent-instructions (no toggle needed)
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE INSTRUCTIONS
        // ═══════════════════════════════════════════════════════════════
        function showMobileInstructions() {
            if (!isMobile || mobileInstructionsHidden) return;

            const instructions = document.getElementById('mobile-instructions');
            if (instructions) {
                instructions.classList.remove('hidden');
            }
        }

        function hideMobileInstructions() {
            if (mobileInstructionsHidden) return;

            const instructions = document.getElementById('mobile-instructions');
            if (instructions) {
                instructions.classList.add('hidden');
            }
            mobileInstructionsHidden = true;
        }

        // ═══════════════════════════════════════════════════════════════
        // MOBILE INITIALIZATION
        // ═══════════════════════════════════════════════════════════════
        function initMobile() {
            if (!isMobile) {
                console.log('💻 Mode desktop détecté');
                return;
            }

            console.log('📱 Mode mobile détecté');

            // Initialiser les contrôles
            initPullToRefresh();
            initJoystick();
            initMobilePauseButton();
            initMobileFullscreenButton();
            initGyroToggle();
            initTouchDrag();

            // Vérifier si on doit demander la permission gyroscope (iOS)
            if (isIOS && typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // La permission sera demandée au clic sur Play
            } else {
                // Activer directement le gyroscope
                enableGyroscope();
            }

            // Modifier handlePlayClick pour mobile
            const originalHandlePlayClick = window.handlePlayClick;
            window.handlePlayClick = function() {
                // Demander fullscreen
                requestFullscreen();

                // Demander permission gyroscope sur iOS
                if (isIOS && !gyroPermissionGranted &&
                    typeof DeviceOrientationEvent !== 'undefined' &&
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // Afficher le bouton de permission
                    document.getElementById('gyro-permission-btn').style.display = 'block';
                }

                // Appeler la fonction originale
                originalHandlePlayClick();
            };
        }

        // Hook dans startExperience pour afficher les contrôles mobiles
        const originalStartExperience = startExperience;
        startExperience = function() {
            originalStartExperience();

            if (isMobile) {
                // Afficher les contrôles mobiles
                document.getElementById('mobile-pause-btn')?.classList.remove('hidden');
                document.getElementById('mobile-joystick')?.classList.remove('hidden');
                const fsBtn = document.getElementById('mobile-fullscreen-btn');
                if (fsBtn) {
                    fsBtn.classList.remove('hidden');
                    fsBtn.style.display = 'flex';
                }
                const gyroToggle = document.getElementById('gyro-toggle-btn');
                if (gyroToggle) {
                    gyroToggle.classList.remove('hidden');
                    gyroToggle.style.display = 'flex';
                }
                const manualToggle = document.getElementById('manual-toggle-btn');
                if (manualToggle) {
                    manualToggle.classList.remove('hidden');
                    manualToggle.style.display = 'flex';
                }
                // Appliquer le mode initial (manuel par défaut)
                setControlMode(touchDragEnabled ? 'manual' : 'gyro');

                // Afficher instructions après un délai
                setTimeout(() => {
                    showMobileInstructions();
                }, 2000);

                // Réinitialiser la référence gyroscope
                resetGyroReference();
            }
        };

        // Hook dans la boucle d'animation pour le joystick
        const originalAnimate = typeof animate === 'function' ? animate : null;
        if (originalAnimate) {
            animate = function() {
                applyJoystickMovement();
                originalAnimate();
            };
        }

        // Initialiser au chargement
        document.addEventListener('DOMContentLoaded', initMobile);

        // Empêcher les comportements tactiles indésirables sur l'expérience
        document.addEventListener('touchmove', (e) => {
            // Permettre le scroll sur welcome-screen
            if (e.target.closest('#welcome-screen')) return;

            // Bloquer le scroll ailleurs si l'expérience est active
            if (fpsMode && !isPaused) {
                e.preventDefault();
            }
        }, { passive: false });

        // Empêcher le double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
    </script>
</body>
</html>
