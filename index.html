<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Dispersed Volume - Prototype 1.3.1</title>
    <link rel="icon" type="image/png" href="img/presences_rares_favicon.png">
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #000; color: #fff; overflow: hidden; }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; }
        #canvas canvas { display: block; }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: 100; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
              padding: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
              max-width: 420px; width: 90%; transition: all 0.4s ease;
              max-height: 85vh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 320px; width: auto; padding: 16px;
                     max-height: calc(100vh - 40px); overflow-y: auto; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: 100;
                      text-decoration: none; color: #fff; transition: opacity 0.2s; }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 18px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: 11px; font-weight: 400; opacity: 0.5;
                    margin-top: 4px; letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: 8px 0; padding: 14px;
                 background: rgba(255,255,255,0.1); color: #fff;
                 border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
                 cursor: pointer; font-size: 12px; font-weight: 600;
                 transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.98); }

        button.small { padding: 8px; font-size: 10px; opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: 6px; margin: 8px 0;
                   display: flex; align-items: center; justify-content: center;
                   background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: 10px; opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: 11px; font-weight: 600; margin-top: 16px; display: block;
                text-transform: uppercase; letter-spacing: 0.8px; opacity: 0.7; }

        .hidden { display: none !important; }

        #controls { margin-top: 16px; padding-top: 16px;
                    border-top: 1px solid rgba(255,255,255,0.15); }

        .slider { width: 100%; height: 4px; border-radius: 2px;
                  background: rgba(255,255,255,0.15); outline: none;
                  -webkit-appearance: none; margin: 10px 0; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none;
                                         width: 18px; height: 18px; border-radius: 50%;
                                         background: #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%;
                                     background: #fff; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .value { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                 cursor: pointer; padding: 2px 6px; border-radius: 3px;
                 transition: background 0.2s; }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                       background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
                       color: #fff; padding: 2px 6px; border-radius: 3px; width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: 14px; }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: 8px; }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: 4px; align-items: center; }

        .arrow-btn { width: 20px; height: 20px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
                     border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: all 0.15s; line-height: 1; }
        .arrow-btn:hover { background: rgba(255,255,255,0.2); }
        .arrow-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: 9px; opacity: 0.3; margin-top: 10px; text-align: center;
                font-style: italic; }

        /* Custom scrollbar for UI */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: 100;
                          display: flex; gap: 8px; background: rgba(0,0,0,0.75);
                          backdrop-filter: blur(10px); padding: 8px; border-radius: 8px;
                          border: 1px solid rgba(255,255,255,0.2); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.1);
                     border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
                     color: #fff; font-size: 20px; cursor: pointer; transition: all 0.2s;
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: rgba(255,255,255,0.2); transform: none; }
        .shape-btn.active { background: rgba(255,255,255,0.3);
                            border-color: rgba(255,255,255,0.5); }

        #mode-3d-btn { width: auto; padding: 0 12px; font-size: 10px; margin-left: 8px;
                       border-left: 1px solid rgba(255,255,255,0.3); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: 100;
                           background: rgba(0,0,0,0.75); backdrop-filter: blur(10px);
                           padding: 8px 12px; border-radius: 6px;
                           border: 1px solid rgba(255,255,255,0.2);
                           font-size: 10px; cursor: pointer; transition: all 0.2s; }
        #version-selector:hover { background: rgba(0,0,0,0.85); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: 99;
                       background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
                       padding: 8px; border-radius: 6px;
                       border: 1px solid rgba(255,255,255,0.2);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: 8px 12px; cursor: pointer; font-size: 10px;
                       border-radius: 4px; margin: 2px 0; transition: all 0.2s;
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.1); }
        .version-item.current { background: rgba(255,255,255,0.15); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: 12px; }
        .video-control-btn { padding: 8px 12px; font-size: 10px; margin: 0; width: 100%; }

        .video-timeline { margin-top: 8px; }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 3px;
            transition: background 0.2s;
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(255,255,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }

        /* Screen Management UI - Sobre et professionnel */
        #screen-manager-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 300px;
            width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        #screen-manager-panel.hidden { display: none; }
        #screen-manager-panel h2 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            opacity: 0.7;
            margin-bottom: 12px;
            font-weight: 600;
        }
        .screen-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 12px;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .screen-list::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        .screen-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .screen-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.2);
        }
        .screen-item.selected {
            border-color: rgba(100,150,255,0.5);
            background: rgba(100,150,255,0.08);
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-header .screen-num {
            font-weight: 600;
            font-size: 11px;
            color: rgba(255,255,255,0.9);
        }
        .screen-header .screen-delete {
            background: transparent;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            font-size: 20px;
            line-height: 20px;
            cursor: pointer;
            transition: all 0.2s;
            color: rgba(255,80,80,0.7);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .screen-header .screen-delete:hover {
            color: rgba(255,80,80,1);
            transform: scale(1.15);
        }
        .screen-type-selector {
            display: none; /* Retrait transformation forme‚Üí√©cran */
        }
        .screen-type-btn {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 6px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .screen-type-btn.active {
            background: rgba(100,150,255,0.2);
            border-color: rgba(100,150,255,0.5);
            color: rgba(255,255,255,1);
        }
        .screen-type-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .color-section {
            margin-top: 8px;
        }
        .color-section h4 {
            font-size: 9px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.05);
            border-color: rgba(255,255,255,0.3);
        }
        .color-option.active {
            border-color: rgba(100,150,255,0.9);
            box-shadow: 0 0 12px rgba(100,150,255,0.6);
            transform: scale(1.05);
        }
        .color-custom {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .color-custom input[type="color"] {
            width: 50px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
        }
        .color-custom input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .add-screen-btn {
            background: rgba(100,200,100,0.25);
            border: 1px solid rgba(100,200,100,0.4);
            margin-top: 8px;
            padding: 10px;
            width: 100%;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: all 0.2s;
        }
        .add-screen-btn:hover {
            background: rgba(100,200,100,0.35);
            border-color: rgba(100,200,100,0.6);
        }
        .screen-manager-hint {
            display: none; /* Retrait hints texte */
        }

        /* Cacher titre et version selector */
        #title-link, #version-selector, #version-menu {
            display: none !important;
        }

        /* R√©duire taille interface r√©glages */
        #ui.loaded {
            max-width: 280px;
            padding: 12px;
        }

        /* FPS Settings Panel - Bottom Center */
        #fps-settings-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 600px;
            max-width: 800px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: white;
            font-size: 11px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        #fps-settings-panel.hidden { display: none !important; }
        #fps-settings-panel h3 {
            grid-column: 1 / -1;
            margin: 0 0 8px 0;
            font-size: 13px;
            font-weight: 600;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }
        .fps-param {
            margin-bottom: 5px;
        }
        .fps-param label {
            display: block;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .fps-param input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        .fps-param input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        .fps-param input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
        }
        .fps-param-value {
            display: inline-block;
            float: right;
            color: #00ff88;
            font-weight: 600;
            font-size: 11px;
        }
        #fps-export-btn {
            margin-top: 10px;
            width: 100%;
            padding: 8px;
            background: rgba(0,255,136,0.15);
            border: 1px solid #00ff88;
            border-radius: 4px;
            color: #00ff88;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #fps-export-btn:hover {
            background: rgba(0,255,136,0.25);
        }

        /* Video Paused Indicator */
        #video-paused-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background: rgba(255, 100, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid rgba(255, 150, 0, 0.8);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #video-paused-indicator.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 ‚Äî Video projection volum√©trique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn" data-shape="circle" title="Circle">‚óè</button>
        <button class="shape-btn active" data-shape="square" title="Square">‚ñ†</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">‚óÜ</button>
        <button class="shape-btn" data-shape="star" title="Star">‚òÖ</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>

    <!-- Video Paused Indicator -->
    <div id="video-paused-indicator">‚è∏Ô∏è VIDEO PAUSED</div>

    <div id="canvas"></div>

    <!-- FPS Settings Panel (Bottom Center) -->
    <div id="fps-settings-panel" class="hidden">
        <h3>‚öôÔ∏è FPS & Verre Settings</h3>

        <div class="fps-param">
            <label>Vitesse touches <span class="fps-param-value" id="val-fps-speed">2.25</span></label>
            <input type="range" id="fps-speed" min="0.5" max="10" step="0.1" value="2.25">
        </div>

        <div class="fps-param">
            <label>Vitesse molette <span class="fps-param-value" id="val-fps-scroll">4.5</span></label>
            <input type="range" id="fps-scroll" min="0.5" max="15" step="0.5" value="4.5">
        </div>

        <div class="fps-param">
            <label>Acc√©l√©ration <span class="fps-param-value" id="val-fps-accel">0.10</span></label>
            <input type="range" id="fps-accel" min="0.05" max="1.0" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>D√©c√©l√©ration <span class="fps-param-value" id="val-fps-decel">0.30</span></label>
            <input type="range" id="fps-decel" min="0.05" max="1.0" step="0.05" value="0.3">
        </div>

        <div class="fps-param">
            <label>Hauteur cam√©ra <span class="fps-param-value" id="val-fps-height">-96</span></label>
            <input type="range" id="fps-height" min="-150" max="-10" step="1" value="-96">
        </div>

        <div class="fps-param">
            <label>Gravit√© <span class="fps-param-value" id="val-fps-gravity">-1.50</span></label>
            <input type="range" id="fps-gravity" min="-3.0" max="-0.1" step="0.1" value="-1.5">
        </div>

        <div class="fps-param">
            <label>Hauteur yeux <span class="fps-param-value" id="val-fps-eye">30</span></label>
            <input type="range" id="fps-eye" min="5" max="100" step="1" value="30">
        </div>

        <div class="fps-param">
            <label>Sensibilit√© souris <span class="fps-param-value" id="val-fps-mouse">0.0010</span></label>
            <input type="range" id="fps-mouse" min="0.0005" max="0.01" step="0.0005" value="0.001">
        </div>

        <div class="fps-param">
            <label>Largeur hitbox <span class="fps-param-value" id="val-fps-hitbox-width">1</span></label>
            <input type="range" id="fps-hitbox-width" min="0.1" max="20" step="0.1" value="1">
        </div>

        <div class="fps-param">
            <label>Hauteur hitbox <span class="fps-param-value" id="val-fps-hitbox-height">10</span></label>
            <input type="range" id="fps-hitbox-height" min="1" max="100" step="1" value="10">
        </div>

        <div class="fps-param">
            <label>Opacit√© verre <span class="fps-param-value" id="val-glass-opacity">0.00</span></label>
            <input type="range" id="glass-opacity" min="0" max="1" step="0.05" value="0.00">
        </div>

        <div class="fps-param">
            <label>Rugosit√© verre <span class="fps-param-value" id="val-glass-roughness">0.10</span></label>
            <input type="range" id="glass-roughness" min="0" max="1" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Metalness verre <span class="fps-param-value" id="val-glass-metalness">0.20</span></label>
            <input type="range" id="glass-metalness" min="0" max="1" step="0.05" value="0.2">
        </div>

        <button id="fps-export-btn" style="grid-column: 1 / -1;">üìã Export (Ctrl+S)</button>
    </div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 ‚Äî Image dispers√©e</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 ‚Äî Video dispers√©e</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 ‚Äî Luminance depth</div>
    </div>

    <!-- Screen Management Panel (Left side) -->
    <div id="screen-manager-panel">
        <h2>Gestion des √âcrans</h2>
        <div class="screen-list" id="screen-list"></div>
        <button class="add-screen-btn" onclick="addNewScreen()">+ Ajouter un √âcran</button>
        <p class="screen-manager-hint">
            <strong>Raccourcis clavier:</strong><br>
            Touche A: Ajouter un √©cran<br>
            Suppr/Backspace: Supprimer s√©lection<br>
            Ctrl+C: Copier √©cran | Ctrl+V: Coller<br>
            1-7: S√©lectionner √©cran<br>
            G/R/E/S: Translate/Rotate/Scale/Size
        </p>
    </div>

    <div id="ui">
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">‚è∏ Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">‚ñº</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">‚ñº</button>
                        <span class="value" id="val-density" data-param="density">13X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="15" step="1" value="13">
                    <div class="center-mark" style="left: 42.9%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">‚ñº</button>
                        <span class="value" id="val-depth" data-param="depth">0.2X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="0.2" step="0.01" value="0.1">
                    <div class="center-mark" style="left: 50%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SMOOTHING</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="smoothing" data-dir="down">‚ñº</button>
                        <span class="value" id="val-smoothing" data-param="smoothing">0.00</span>
                        <button class="arrow-btn" data-param="smoothing" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="smoothing" min="0.0" max="0.1" step="0.005" value="0.1">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">‚ñº</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">‚ñº</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.8</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>GLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="glow" data-dir="down">‚ñº</button>
                        <span class="value" id="val-glow" data-param="glow">0.30</span>
                        <button class="arrow-btn" data-param="glow" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="glow" min="0.0" max="1.0" step="0.05" value="0.3">
                    <div class="center-mark" style="left: 30%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">‚ñº</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">‚ñº</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">‚ñº</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">‚ñº</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.1</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.3">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">‚ñº</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.80</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.80">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">‚ñº</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">‚ñ≤</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Clic gauche + drag pour tourner ‚Ä¢ Molette pour avancer/reculer ‚Ä¢ Fl√®ches: d√©placement ‚Ä¢ P/M: monter/descendre ‚Ä¢ N: toggle UI</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üöÄ SCRIPT D√âMARR√â - D√©but du chargement');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.2;
        let depthSmoothing = 0.1; // Seuil pour att√©nuer micro-mouvements (0 = aucun, 0.1 = √©lev√©)
        let pointSize = 0.39;
        let particleDensity = 13;
        let brightness = 1.8;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'square'; // Mode carr√© par d√©faut
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.3;
        let saturation = 0.80;
        let hideBackground = false;
        let bgThreshold = 40;
        let glowIntensity = 0.3; // √âmissivit√©/glow des particules lumineuses

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Transform controls for manipulating screens
        let transformControls = null;
        let selectedScreen = null;
        let allScreens = {}; // Store all screens by number
        let clipboardScreen = null; // Store copied screen data for copy/paste

        // Free camera (no orbit controls, no pivot)
        let freeCameraEnabled = true;
        let fpsMode = false; // Mode Normal/Admin par d√©faut - Touche B pour activer mode FPS
        let showHitbox = false; // Affichage de la hitbox activ√© avec touche H
        let hitboxHelper = null; // Helper pour visualiser la hitbox
        let cameraYaw = 0; // Rotation horizontale (Y axis)
        let cameraPitch = 0; // Rotation verticale (X axis)
        let isMouseLocked = false;

        // FPS visual effects
        let headBobTimer = 0;
        const HEAD_BOB_SPEED = 0.15;
        const HEAD_BOB_AMOUNT = 0.8;
        const DEFAULT_FOV = 75;
        const SPRINT_FOV_INCREASE = 5;
        let currentFOV = DEFAULT_FOV;
        let targetFOV = DEFAULT_FOV;

        // FPS Physics (param√®tres configurables via interface)
        let playerVelocityY = 0;
        let isOnGround = false;
        let currentSpeed = 0;
        const MIN_SPEED = 0;

        // FPS Settings Object (accessible globalement)
        var fpsSettings = {
            fpsCameraHeight: -96,       // Hauteur de spawn de la cam√©ra
            fpsGravity: -1.5,           // Gravit√©
            fpsPlayerHeight: 30,        // Hauteur des yeux du joueur au-dessus du sol
            fpsMaxSpeed: 2.25,          // Vitesse maximale
            fpsAcceleration: 0.1,       // Vitesse d'acc√©l√©ration
            fpsDeceleration: 0.3,       // Vitesse de d√©c√©l√©ration
            fpsCollisionRadius: 0.5,    // Rayon de collision (r√©duit par 10)
            fpsHitboxWidth: 1,          // Largeur de la hitbox (r√©duit par 10)
            fpsHitboxHeight: 10,        // Hauteur de la hitbox (r√©duit par 10)
            fpsScrollSpeed: 4.5,        // Vitesse de d√©placement √† la molette
            fpsMouseSensitivity: 0.001, // Sensibilit√© souris
            // Glassmorphisme √©cran 10
            glassOpacity: 0.00,         // Opacit√© du verre
            glassRoughness: 0.1,        // Rugosit√© de surface
            glassMetalness: 0.2         // Aspect m√©tallique
        };

        // Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Magnetism settings
        const MAGNETISM_THRESHOLD = 0.05; // ~3 degrees in radians
        const MAGNETISM_ANGLES = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2];

        // Scale mode: 'uniform' (proportionnel) or 'free' (par axe)
        let scaleMode = 'free'; // Default to free mode (allows per-axis scaling)

        // FPS Camera controls (only when no screen selected)
        const cameraKeys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            sprint: false
        };
        const CAMERA_SPEED = 3; // Vitesse de d√©placement de la cam√©ra (r√©duite)
        const CAMERA_SPRINT_MULTIPLIER = 2.5; // Multiplicateur pour la vitesse de sprint

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 15, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 0.2, step: 0.01, decimals: 2, suffix: 'X' }, // Plage 0-0.2 pour pr√©cision sur petites valeurs
            smoothing: { min: 0.0, max: 0.1, step: 0.005, decimals: 3, suffix: '' }, // Seuil att√©nuation micro-mouvements
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            glow: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' }, // √âmissivit√©/glow
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);

                    // Flow is real-time, glow needs regeneration
                    if (param === 'flow') {
                        flowIntensity = parseFloat(slider.value);
                    } else if (param === 'glow') {
                        glowIntensity = parseFloat(slider.value);
                        scheduleRegenerate();
                    } else {
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = '‚è∏ Pause';
            } else {
                video.pause();
                btn.textContent = '‚ñ∂ Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            // Debug: log all Ctrl key combinations
            if (e.ctrlKey) {
                console.log('üéπ Touche Ctrl d√©tect√©e:', e.code, 'ctrlKey:', e.ctrlKey, 'shiftKey:', e.shiftKey);
            }

            // Ctrl+Z: Undo (PRIORITY - check first!)
            if (e.code === 'KeyZ' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üîÑ Ctrl+Z d√©tect√© - Ex√©cution undo()');
                undo();
                return; // Stop here
            }

            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.code === 'KeyZ' && e.ctrlKey && e.shiftKey) || (e.code === 'KeyY' && e.ctrlKey)) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üîÑ Ctrl+Shift+Z ou Ctrl+Y d√©tect√© - Ex√©cution redo()');
                redo();
                return; // Stop here
            }

            // Ctrl+S: Save positions to JSON file
            if (e.code === 'KeyS' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üíæ Ctrl+S d√©tect√© - Sauvegarde positions');
                savePositionsToFile();
                return; // Stop here
            }

            // Ctrl+C: Copy selected screen
            if (e.code === 'KeyC' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üìã Ctrl+C d√©tect√© - Copie √©cran');
                copyScreen();
                return; // Stop here
            }

            // Ctrl+V: Paste screen (create duplicate)
            if (e.code === 'KeyV' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üìÑ Ctrl+V d√©tect√© - Collage √©cran');
                pasteScreen();
                return; // Stop here
            }

            // FPS Camera controls (always active, even with screen selected)
            // Arrow keys always work; WASD only when no screen selected
            if (e.code === 'ArrowUp' || (e.code === 'KeyW' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.forward = true;
            }
            if (e.code === 'ArrowDown' || (e.code === 'KeyS' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.backward = true;
            }
            if (e.code === 'ArrowLeft' || (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.left = true;
            }
            if (e.code === 'ArrowRight' || (e.code === 'KeyD' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.right = true;
            }

            // O/L: Camera up/down (only in normal mode, not FPS mode)
            if (e.code === 'KeyO' && !fpsMode) {
                e.preventDefault();
                cameraKeys.up = true;
            }
            if (e.code === 'KeyL' && !fpsMode) {
                e.preventDefault();
                cameraKeys.down = true;
            }

            // Shift: Sprint (when no screen selected, works in both modes)
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !selectedScreen) {
                cameraKeys.sprint = true;
            }

            // Space: play/pause (only if video exists)
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }

            // Number keys 1-7: Select screen (keyboard + numpad)
            if ((e.code >= 'Digit1' && e.code <= 'Digit7') || (e.code >= 'Numpad1' && e.code <= 'Numpad7')) {
                e.preventDefault();
                const screenNum = parseInt(e.code.replace('Digit', '').replace('Numpad', ''));
                selectScreen(screenNum);
            }

            // G: Translate mode
            if (e.code === 'KeyG' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('translate');
                console.log('Mode: TRANSLATE (d√©placement XYZ)');
            }

            // R: Rotate mode
            if (e.code === 'KeyR' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('rotate');
                console.log('Mode: ROTATE (rotation XYZ)');
            }

            // E: Scale mode
            if (e.code === 'KeyE' && selectedScreen) {
                e.preventDefault();
                // Cycle between scale modes
                if (transformControls.mode !== 'scale') {
                    // First press: activate scale mode
                    transformControls.setMode('scale');
                    scaleMode = 'free';
                    console.log('Mode: SCALE LIBRE (axe individuel) - Re-appuyez sur E pour mode uniforme');
                } else {
                    // Subsequent presses: toggle between free and uniform
                    scaleMode = scaleMode === 'free' ? 'uniform' : 'free';
                    console.log(`Mode: SCALE ${scaleMode === 'uniform' ? 'UNIFORME (proportionnel)' : 'LIBRE (axe individuel)'}`);
                }
            }

            // S: Size/Resize mode (when screen selected) OR Save positions (when no screen)
            if (e.code === 'KeyS' && !e.ctrlKey) {
                e.preventDefault();
                if (selectedScreen) {
                    // Activate SIZE mode (geometry resize)
                    transformControls.setMode('scale');
                    scaleMode = 'resize'; // Special mode for geometry resizing
                    console.log('=== MODE: REDIMENSIONNEMENT (S) ===');
                    console.log('Modifie les positions des particules directement');
                    console.log('‚Üí Surface change SANS affecter depth spread');
                    console.log('‚Üí Id√©al pour harmoniser les √©crans volum√©triques');
                    console.log('Drag les handles pour redimensionner');
                } else {
                    saveAllPositions();
                }
            }

            // Escape: Deselect screen
            if (e.code === 'Escape' && selectedScreen) {
                e.preventDefault();
                deselectScreen();
            }

            // Delete or Backspace: Delete selected screen
            if ((e.code === 'Delete' || e.code === 'Backspace') && selectedScreen) {
                e.preventDefault();
                deleteScreen(selectedScreen);
            }

            // A: Add new screen
            if (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey) {
                e.preventDefault();
                addNewScreen();
            }

            // N: Toggle all interfaces
            if (e.code === 'KeyN') {
                e.preventDefault();
                toggleAllInterfaces();
            }

            // B: Toggle FPS mode
            if (e.code === 'KeyB') {
                e.preventDefault();
                fpsMode = !fpsMode;
                if (fpsMode) {
                    console.log('üéÆ MODE FPS ACTIV√â');
                    console.log('   - Cliquez sur le canvas pour activer PointerLock');
                    console.log('   - WASD pour se d√©placer');
                    console.log('   - Shift pour sprinter');
                    console.log('   - ESC pour sortir du PointerLock');
                    console.log('   - B pour d√©sactiver le mode FPS');
                    console.log('   - H pour afficher/masquer la hitbox');
                } else {
                    console.log('üñ±Ô∏è MODE NORMAL ACTIV√â (B pour mode FPS)');
                    // Release pointer lock if active
                    if (document.exitPointerLock) {
                        document.exitPointerLock();
                    }
                }
            }

            // H: Toggle hitbox visibility
            if (e.code === 'KeyH') {
                e.preventDefault();
                showHitbox = !showHitbox;
                if (showHitbox) {
                    console.log('üëÅÔ∏è HITBOX VISIBLE');
                } else {
                    console.log('üö´ HITBOX MASQU√âE');
                    // Remove hitbox helper if exists and dispose properly to prevent memory leak
                    if (hitboxHelper) {
                        scene.remove(hitboxHelper);
                        if (hitboxHelper.geometry) hitboxHelper.geometry.dispose();
                        if (hitboxHelper.material) hitboxHelper.material.dispose();
                        hitboxHelper = null;
                    }
                }
            }
        });

        // Keyboard controls - keyup for FPS camera
        document.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                cameraKeys.forward = false;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                cameraKeys.backward = false;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                cameraKeys.left = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                cameraKeys.right = false;
            }
            if (e.code === 'KeyO') {
                cameraKeys.up = false;
            }
            if (e.code === 'KeyL') {
                cameraKeys.down = false;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                cameraKeys.sprint = false;
            }
        });

        // Transform control functions
        function selectScreen(num) {
            if (!allScreens[num]) {
                console.log(`√âcran ${num} n'existe pas`);
                return;
            }

            selectedScreen = num;
            transformControls.attach(allScreens[num]);

            // Set snap settings based on Shift key
            document.addEventListener('keydown', onShiftChange);
            document.addEventListener('keyup', onShiftChange);

            console.log(`=== √âCRAN ${num} S√âLECTIONN√â ===`);
            console.log('Commandes:');
            console.log('  G = Mode Translation');
            console.log('  R = Mode Rotation');
            console.log('  E = Mode Scale (classique, affecte depth spread)');
            console.log('  S = Mode Redimensionnement (modifie positions, pr√©serve depth)');
            console.log('  Maj enfonc√© = rotation 15¬∞, translation 1000');
            console.log('  √âchap = D√©s√©lectionner');
            console.log('  Ctrl+C = Copier | Ctrl+V = Coller (dupliquer)');
            console.log('  Ctrl+Z = Annuler | Ctrl+Shift+Z = Refaire');
            console.log('  Magn√©tisme auto : 0/90/180/270¬∞');
        }

        function deselectScreen() {
            if (selectedScreen) {
                console.log(`√âcran ${selectedScreen} d√©s√©lectionn√©`);
                transformControls.detach();
                selectedScreen = null;

                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }
        }

        // Toggle all interfaces (touche N)
        function toggleAllInterfaces() {
            const ui = document.getElementById('ui');
            const screenManager = document.getElementById('screen-manager-panel');
            const shapeSelector = document.getElementById('shape-selector');
            const loadSection = document.getElementById('load-section');

            const isVisible = !ui.classList.contains('hidden');

            if (isVisible) {
                // Cacher les interfaces SAUF load-section si aucune vid√©o n'est charg√©e
                if (currentVideo) {
                    ui.classList.add('hidden');
                } else {
                    // Si pas de vid√©o, garder load-section visible mais cacher le reste
                    document.getElementById('controls')?.classList.add('hidden');
                }
                screenManager.classList.add('hidden');
                shapeSelector.classList.add('hidden');
                console.log('üôà Interfaces cach√©es (N pour afficher)');
            } else {
                ui.classList.remove('hidden');
                screenManager.classList.remove('hidden');
                shapeSelector.classList.remove('hidden');
                console.log('üëÅÔ∏è Interfaces affich√©es (N pour cacher)');
            }
        }

        function deleteScreen(num) {
            if (!allScreens[num]) {
                console.warn(`√âcran ${num} n'existe pas`);
                return;
            }

            // Save state for undo
            saveState();

            const screen = allScreens[num];

            // Detach transform controls if this screen is selected
            if (selectedScreen === num) {
                transformControls.detach();
                selectedScreen = null;
                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }

            // Remove from scene
            if (screen.parent) {
                screen.parent.remove(screen);
            }

            // Dispose geometry and material to free memory
            if (screen.geometry) screen.geometry.dispose();
            if (screen.material) {
                if (Array.isArray(screen.material)) {
                    screen.material.forEach(mat => mat.dispose());
                } else {
                    screen.material.dispose();
                }
            }

            // Remove from allScreens
            delete allScreens[num];

            console.log(`=== √âCRAN ${num} SUPPRIM√â ===`);

            // Update UI
            updateScreenList();
        }

        function addNewScreen() {
            console.log('üÜï addNewScreen() appel√© - allScreens actuels:', Object.keys(allScreens));
            console.trace('Stack trace:'); // Pour voir qui appelle cette fonction

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }
            console.log('üÜï Nouveau num√©ro trouv√©:', newNum);

            // Save state for undo
            saveState();

            // Default dimensions (same as standard screen)
            const width = 450;
            const height = 450;

            // Create new screen plane with color surface
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080, // Gray by default
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Position offset from origin
            const offset = (newNum - 1) * 500;
            screen.position.set(offset, 0, 0);

            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = true; // Mark as color surface by default
            screen.userData.color = 0x808080; // Store color

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`=== √âCRAN ${newNum} CR√â√â ===`);
            console.log(`Position: (${offset}, 0, 0)`);
            console.log(`Dimensions: ${width} x ${height}`);
            console.log(`Type: Surface couleur unie (gris)`);

            // Update UI
            updateScreenList();
        }

        // Copy selected screen to clipboard
        function copyScreen() {
            if (!selectedScreen) {
                console.log('‚ùå Aucun √©cran s√©lectionn√© pour copier');
                return;
            }

            const screen = allScreens[selectedScreen];
            if (!screen) {
                console.log('‚ùå √âcran non trouv√©');
                return;
            }

            // Deep copy all screen properties
            clipboardScreen = {
                position: {
                    x: screen.position.x,
                    y: screen.position.y,
                    z: screen.position.z
                },
                rotation: {
                    x: screen.rotation.x,
                    y: screen.rotation.y,
                    z: screen.rotation.z
                },
                scale: {
                    x: screen.scale.x,
                    y: screen.scale.y,
                    z: screen.scale.z
                },
                isColorSurface: screen.userData.isColorSurface || false,
                color: screen.userData.color || 0x808080,
                geometryType: screen.geometry ? screen.geometry.type : 'PlaneGeometry',
                dimensions: null
            };

            // Copy geometry dimensions if available
            if (screen.geometry && screen.geometry.parameters) {
                const params = screen.geometry.parameters;
                if (params.width !== undefined && params.height !== undefined) {
                    clipboardScreen.dimensions = {
                        width: params.width,
                        height: params.height
                    };
                }
            }

            console.log(`üìã √âcran ${selectedScreen} copi√© dans le presse-papiers`);
            console.log('   Dimensions:', clipboardScreen.dimensions);
            console.log('   Position:', clipboardScreen.position);
        }

        // Paste screen from clipboard (create duplicate)
        function pasteScreen() {
            if (!clipboardScreen) {
                console.log('‚ùå Presse-papiers vide - copiez d\'abord un √©cran (Ctrl+C)');
                return;
            }

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }

            // Save state for undo
            saveState();

            // Create geometry based on stored data
            let width = 450;
            let height = 450;
            if (clipboardScreen.dimensions) {
                width = clipboardScreen.dimensions.width;
                height = clipboardScreen.dimensions.height;
            }

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: clipboardScreen.color,
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Copy position, rotation, scale
            screen.position.set(
                clipboardScreen.position.x,
                clipboardScreen.position.y,
                clipboardScreen.position.z
            );
            screen.rotation.set(
                clipboardScreen.rotation.x,
                clipboardScreen.rotation.y,
                clipboardScreen.rotation.z
            );
            screen.scale.set(
                clipboardScreen.scale.x,
                clipboardScreen.scale.y,
                clipboardScreen.scale.z
            );

            // Copy metadata
            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = clipboardScreen.isColorSurface;
            screen.userData.color = clipboardScreen.color;

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`‚úÖ √âcran ${newNum} cr√©√© par collage (duplicata)`);
            console.log(`   Position: (${screen.position.x.toFixed(3)}, ${screen.position.y.toFixed(3)}, ${screen.position.z.toFixed(3)})`);
            console.log(`   Dimensions: ${width} x ${height}`);

            // Update UI and select new screen
            updateScreenList();
            selectScreen(newNum);
        }

        function updateScreenList() {
            const screenList = document.getElementById('screen-list');
            if (!screenList) return;

            screenList.innerHTML = '';

            Object.keys(allScreens).sort((a, b) => parseInt(a) - parseInt(b)).forEach(num => {
                const screen = allScreens[num];
                const isColorSurface = screen.userData.isColorSurface || false;
                const color = screen.userData.color || 0x808080;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'screen-item';
                if (selectedScreen == num) {
                    itemDiv.classList.add('selected');
                }

                // Click to select screen
                itemDiv.addEventListener('click', (e) => {
                    // Don't select if clicking delete button
                    if (!e.target.classList.contains('screen-delete')) {
                        selectScreen(num);
                        updateScreenList();
                    }
                });

                // Header with number and delete button
                const headerDiv = document.createElement('div');
                headerDiv.className = 'screen-header';
                headerDiv.innerHTML = `
                    <span class="screen-num">√âcran ${num}</span>
                    <button class="screen-delete" onclick="event.stopPropagation(); deleteScreen(${num}); updateScreenList();">√ó</button>
                `;
                itemDiv.appendChild(headerDiv);

                // Type selector
                const typeSelectorDiv = document.createElement('div');
                typeSelectorDiv.className = 'screen-type-selector';
                typeSelectorDiv.innerHTML = `
                    <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vid√©o</button>
                    <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                `;
                itemDiv.appendChild(typeSelectorDiv);

                // Color picker (only if color surface)
                if (isColorSurface) {
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x1a1a1a, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris fonc√©' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-fonc√©' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris tr√®s clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris p√¢le' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cass√©' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    // Reset to current color if invalid
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                }

                screenList.appendChild(itemDiv);
            });
        }

        function setScreenType(num, isColorSurface) {
            const screen = allScreens[num];
            if (!screen) return;

            saveState();

            screen.userData.isColorSurface = isColorSurface;

            // Detect if this is a volumetric screen (1-7) or a shape (>7)
            const isVolumetric = (num >= 1 && num <= 7);

            if (isColorSurface) {
                // Switch to color surface
                const color = screen.userData.color || 0x808080;

                if (isVolumetric) {
                    // For volumetric screens: create overlay plane to hide particles
                    if (!screen.userData.colorOverlay) {
                        // Get screen dimensions (approximate from bounding box)
                        const box = new THREE.Box3().setFromObject(screen);
                        const size = box.getSize(new THREE.Vector3());
                        const width = Math.max(size.x, size.y, size.z);
                        const height = Math.max(size.x, size.y, size.z);

                        // Create overlay mesh
                        const overlayGeometry = new THREE.PlaneGeometry(width * 1.2, height * 1.2);
                        const overlayMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);

                        // Position overlay at screen position (local space)
                        overlay.position.copy(screen.position);
                        overlay.rotation.copy(screen.rotation);
                        overlay.scale.copy(screen.scale);

                        screensGroup.add(overlay);
                        screen.userData.colorOverlay = overlay;
                    } else {
                        // Update existing overlay color
                        screen.userData.colorOverlay.material.color.setHex(color);
                        screen.userData.colorOverlay.visible = true;
                    }

                    // Hide volumetric particles
                    screen.visible = false;

                } else {
                    // For shapes: just change material color
                    screen.material.color.setHex(color);
                }
            } else {
                // Switch to video
                if (isVolumetric) {
                    // For volumetric screens: hide overlay, show particles
                    if (screen.userData.colorOverlay) {
                        screen.userData.colorOverlay.visible = false;
                    }
                    screen.visible = true;
                } else {
                    // For shapes: can't convert to video (not supported yet)
                    console.warn(`√âcran ${num}: Conversion forme ‚Üí vid√©o non support√©e`);
                }
            }

            updateScreenList();
            console.log(`√âcran ${num}: Type chang√© en ${isColorSurface ? 'Couleur' : 'Vid√©o'}`);
        }

        function setScreenColor(num, colorValue) {
            const screen = allScreens[num];
            if (!screen || !screen.userData.isColorSurface) return;

            saveState();

            screen.userData.color = colorValue;

            // Update color for volumetric overlay or direct material
            const isVolumetric = (num >= 1 && num <= 7);
            if (isVolumetric && screen.userData.colorOverlay) {
                screen.userData.colorOverlay.material.color.setHex(colorValue);
            } else if (screen.material) {
                screen.material.color.setHex(colorValue);
            }

            updateScreenList();
            console.log(`√âcran ${num}: Couleur chang√©e ‚Üí #${colorValue.toString(16).padStart(6, '0')}`);
        }

        function onShiftChange(e) {
            if (!transformControls || !selectedScreen) return;

            const isShiftPressed = e.shiftKey;

            if (transformControls.mode === 'rotate') {
                // Rotation par pas de 15¬∞ (en radians)
                transformControls.setRotationSnap(isShiftPressed ? THREE.MathUtils.degToRad(15) : null);
            } else if (transformControls.mode === 'translate') {
                // Translation snapping de 1000 unit√©s
                transformControls.setTranslationSnap(isShiftPressed ? 1000 : null);
            }
        }

        // Apply magnetism to rotation - snap to 0, 90, 180, 270 degrees when close
        function applyMagnetism(screen) {
            if (!screen) return;

            ['x', 'y', 'z'].forEach(axis => {
                const rotation = screen.rotation[axis];
                const normalized = ((rotation % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                for (let angle of MAGNETISM_ANGLES) {
                    if (Math.abs(normalized - angle) < MAGNETISM_THRESHOLD) {
                        screen.rotation[axis] = rotation - normalized + angle;
                        break;
                    }
                }
            });
        }

        // PROFESSIONAL UNDO/REDO SYSTEM - Complet et robuste
        function saveState() {
            const state = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            // Deep copy of ALL screen properties
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                state.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });

            undoHistory.push(state);
            console.log('üíæ saveState() - √âtat sauvegard√©, √©crans:', Object.keys(state.screens), 'historique:', undoHistory.length);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Clear redo history when new action is made
            redoHistory = [];
        }

        function undo() {
            console.log('üîÑ undo() appel√© - undoHistory.length:', undoHistory.length);

            if (undoHistory.length === 0) {
                console.log('‚ùå Rien √† annuler (historique vide)');
                return;
            }

            // Save current state to redo BEFORE undoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            console.log('üíæ √âtat actuel sauvegard√© dans redo, √©crans:', Object.keys(currentState.screens));
            redoHistory.push(currentState);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }

            // Restore previous state
            const previousState = undoHistory.pop();
            console.log('‚èÆÔ∏è Restauration √©tat pr√©c√©dent, √©crans:', Object.keys(previousState.screens));

            // Restore all screens from previous state
            Object.keys(previousState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = previousState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (previousState.selectedScreen && allScreens[previousState.selectedScreen]) {
                selectScreen(previousState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('‚úÖ Annul√© (Ctrl+Z)');
        }

        function redo() {
            if (redoHistory.length === 0) {
                console.log('‚ùå Rien √† refaire');
                return;
            }

            // Save current state to undo BEFORE redoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            undoHistory.push(currentState);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Restore next state
            const nextState = redoHistory.pop();

            // Restore all screens from next state
            Object.keys(nextState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = nextState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (nextState.selectedScreen && allScreens[nextState.selectedScreen]) {
                selectScreen(nextState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('‚úÖ Refait (Ctrl+Shift+Z)');
        }

        function saveAllPositions() {
            console.log('');
            console.log('='.repeat(60));
            console.log('SAUVEGARDE DES POSITIONS - COPIER-COLLER DANS LE CODE');
            console.log('='.repeat(60));
            console.log('');

            Object.keys(allScreens).sort().forEach(num => {
                const screen = allScreens[num];
                const pos = screen.position;
                const rot = screen.rotation;
                const scale = screen.scale;

                console.log(`// √âcran ${num}`);
                console.log(`screen${num}.position.set(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)});`);
                console.log(`screen${num}.rotation.set(${rot.x.toFixed(6)}, ${rot.y.toFixed(6)}, ${rot.z.toFixed(6)});`);
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    console.log(`screen${num}.scale.set(${scale.x.toFixed(3)}, ${scale.y.toFixed(3)}, ${scale.z.toFixed(3)});`);
                }
                console.log('');
            });

            console.log('='.repeat(60));
        }

        // Save positions to JSON file (Ctrl+S)
        function savePositionsToFile() {
            const data = {
                timestamp: new Date().toISOString(),
                screens: {}
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const screenData = {
                    position: {
                        x: parseFloat(screen.position.x.toFixed(3)),
                        y: parseFloat(screen.position.y.toFixed(3)),
                        z: parseFloat(screen.position.z.toFixed(3))
                    },
                    rotation: {
                        x: parseFloat(screen.rotation.x.toFixed(6)),
                        y: parseFloat(screen.rotation.y.toFixed(6)),
                        z: parseFloat(screen.rotation.z.toFixed(6))
                    },
                    scale: {
                        x: parseFloat(screen.scale.x.toFixed(3)),
                        y: parseFloat(screen.scale.y.toFixed(3)),
                        z: parseFloat(screen.scale.z.toFixed(3))
                    },
                    // Type and properties
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };

                // Save geometry dimensions if available
                if (screen.geometry && screen.geometry.parameters) {
                    const params = screen.geometry.parameters;
                    if (params.width !== undefined && params.height !== undefined) {
                        screenData.dimensions = {
                            width: parseFloat(params.width.toFixed(3)),
                            height: parseFloat(params.height.toFixed(3))
                        };
                    }
                    // Save geometry type
                    screenData.geometryType = screen.geometry.type || 'unknown';
                }

                data.screens[num] = screenData;
            });

            // Download as JSON file
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `screen-positions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('‚úÖ Positions compl√®tes (avec dimensions) sauvegard√©es dans le fichier JSON t√©l√©charg√©');
            console.log(`üì¶ ${Object.keys(allScreens).length} √©crans export√©s`);
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîß INIT() - D√©but de l\'initialisation');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            console.log('üì¶ V√©rification THREE.js...');
            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded!');
                alert('THREE.js failed to load.');
                return;
            }
            console.log('‚úÖ THREE.js charg√©:', THREE.REVISION);

            console.log('üåç Cr√©ation de la sc√®ne...');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            console.log('‚úÖ Sc√®ne cr√©√©e');

            console.log('üì¶ Cr√©ation du groupe d\'√©crans...');
            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);
            console.log('‚úÖ Groupe d\'√©crans cr√©√© et ajout√© √† la sc√®ne');

            // Utiliser la taille compl√®te de la fen√™tre (pas de ratio forc√©)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;
            console.log(`üìê Dimensions: ${canvasWidth}x${canvasHeight} (ratio: ${aspectRatio.toFixed(2)})`);

            console.log('üì∑ Cr√©ation de la cam√©ra...');
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            // Position de spawn au centre de la forme 11, √† quelques unit√©s au-dessus du sol
            // Sol de la forme 11: y = -111.773, on spawn √† fpsCameraHeight
            camera.position.set(-274.876, fpsSettings.fpsCameraHeight, 112.79);
            console.log(`üìç Position cam√©ra: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);

            // Orienter la cam√©ra vers l'√©cran 7 puis tourner d'un quart de tour suppl√©mentaire
            const lookAtTarget = new THREE.Vector3(599.938, fpsSettings.fpsCameraHeight, 112.546);
            camera.lookAt(lookAtTarget);
            console.log(`üëÄ Cam√©ra regarde vers: (${lookAtTarget.x.toFixed(1)}, ${lookAtTarget.y.toFixed(1)}, ${lookAtTarget.z.toFixed(1)})`);

            // Calculer yaw et pitch initiaux bas√©s sur l'orientation
            const direction = new THREE.Vector3();
            direction.subVectors(lookAtTarget, camera.position).normalize();
            cameraYaw = Math.atan2(direction.x, direction.z) + Math.PI; // +180¬∞ (quart de tour suppl√©mentaire)
            cameraPitch = 0; // Vision horizontale
            console.log(`üéØ Orientation: yaw=${cameraYaw.toFixed(2)}, pitch=${cameraPitch.toFixed(2)}`);
            console.log('‚úÖ Cam√©ra configur√©e');

            console.log('üñºÔ∏è Cr√©ation du renderer...');
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            console.log('‚úÖ Renderer cr√©√© et configur√©');

            console.log('üìé Ajout du canvas au DOM...');
            const canvasContainer = document.getElementById('canvas');
            if (!canvasContainer) {
                console.error('‚ùå Element #canvas introuvable dans le DOM!');
                return;
            }
            canvasContainer.appendChild(renderer.domElement);
            console.log('‚úÖ Canvas ajout√© au DOM');

            console.log('üí° Ajout des lumi√®res...');
            // Lumi√®re ambiante
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            console.log('‚úÖ Lumi√®re ambiante ajout√©e');

            // FREE CAMERA: Pas d'OrbitControls, cam√©ra compl√®tement libre
            // Rotation avec clic droit + drag, mouvement avec fl√®ches

            console.log('üéÆ Configuration des TransformControls...');
            // TransformControls for manipulating screens
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('world'); // Use world space to avoid X/Y inversion
            scene.add(transformControls);
            console.log('‚úÖ TransformControls configur√©s');

            // When transforming, disable free camera
            transformControls.addEventListener('dragging-changed', function(event) {
                freeCameraEnabled = !event.value;

                // Apply magnetism when releasing (end of drag)
                if (!event.value && selectedScreen && allScreens[selectedScreen]) {
                    applyMagnetism(allScreens[selectedScreen]);
                }
            });

            // Save state when starting to drag
            transformControls.addEventListener('mouseDown', function() {
                if (selectedScreen) {
                    saveState();
                }
            });

            // Handle scale modes: uniform, free, and resize
            let lastResizeScale = {x: 1, y: 1, z: 1};
            transformControls.addEventListener('objectChange', function() {
                if (transformControls.mode === 'scale' && selectedScreen && allScreens[selectedScreen]) {
                    const screen = allScreens[selectedScreen];

                    if (scaleMode === 'uniform') {
                        // UNIFORM mode: proportional scaling
                        const avgScale = (screen.scale.x + screen.scale.y + screen.scale.z) / 3;
                        screen.scale.set(avgScale, avgScale, avgScale);
                    } else if (scaleMode === 'resize') {
                        // RESIZE mode: change geometry dimensions, not scale
                        const currentScale = {x: screen.scale.x, y: screen.scale.y, z: screen.scale.z};

                        // Detect which axis changed
                        const deltaX = currentScale.x / lastResizeScale.x;
                        const deltaY = currentScale.y / lastResizeScale.y;
                        const deltaZ = currentScale.z / lastResizeScale.z;

                        if (deltaX !== 1 || deltaY !== 1 || deltaZ !== 1) {
                            // PlaneGeometry (color surfaces)
                            if (screen.geometry && screen.geometry.type === 'PlaneGeometry') {
                                // Get current geometry dimensions
                                const currentWidth = screen.geometry.parameters.width;
                                const currentHeight = screen.geometry.parameters.height;

                                // Calculate new dimensions based on scale change
                                const newWidth = currentWidth * deltaX;
                                const newHeight = currentHeight * deltaY;

                                // Recreate geometry with new dimensions
                                screen.geometry.dispose();
                                screen.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionn√©: ${Math.round(newWidth)} x ${Math.round(newHeight)}`);
                            }
                            // Volumetric screens (Points or InstancedMesh)
                            else if (screen.userData.positions || (screen.geometry && screen.geometry.attributes.position)) {
                                // Get positions array
                                let positions;
                                if (screen.userData.positions) {
                                    positions = screen.userData.positions;
                                } else {
                                    positions = screen.geometry.attributes.position.array;
                                }

                                // Multiply all positions by delta (resize without affecting depth spread)
                                for (let i = 0; i < positions.length; i += 3) {
                                    positions[i] *= deltaX;     // X
                                    positions[i + 1] *= deltaY; // Y
                                    positions[i + 2] *= deltaZ; // Z (depth)
                                }

                                // Update geometry based on type
                                if (screen.isPoints) {
                                    // Points: update position attribute
                                    screen.geometry.attributes.position.needsUpdate = true;
                                    screen.geometry.computeBoundingSphere();
                                } else if (screen.isInstancedMesh) {
                                    // InstancedMesh: update instance matrices
                                    const count = screen.count;
                                    for (let i = 0; i < count; i++) {
                                        reusableMatrix.setPosition(
                                            positions[i * 3],
                                            positions[i * 3 + 1],
                                            positions[i * 3 + 2]
                                        );
                                        screen.setMatrixAt(i, reusableMatrix);
                                    }
                                    screen.instanceMatrix.needsUpdate = true;
                                }

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionn√© (volum√©trique): x${deltaX.toFixed(2)}, y${deltaY.toFixed(2)}, z${deltaZ.toFixed(2)}`);
                            }
                        }
                    }
                    // FREE mode: do nothing, allow non-uniform scaling
                }
            });

            // Free camera mouse controls (LEFT CLICK + drag)
            let isLeftMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.button === 0) { // Left click
                    isLeftMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', function(e) {
                if (e.button === 0) {
                    isLeftMouseDown = false;
                }
            });

            renderer.domElement.addEventListener('mousemove', function(e) {
                // PointerLock mode (FPS-style)
                if (isMouseLocked && freeCameraEnabled) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                }
                // Legacy click+drag mode
                else if (isLeftMouseDown && freeCameraEnabled) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            // PointerLock API setup for FPS-style controls (only in FPS mode)
            renderer.domElement.addEventListener('click', function() {
                if (!selectedScreen && freeCameraEnabled && fpsMode) {
                    renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                             renderer.domElement.mozRequestPointerLock ||
                                                             renderer.domElement.webkitRequestPointerLock;
                    renderer.domElement.requestPointerLock();
                }
            });

            // PointerLock change event
            document.addEventListener('pointerlockchange', lockChangeCallback, false);
            document.addEventListener('mozpointerlockchange', lockChangeCallback, false);
            document.addEventListener('webkitpointerlockchange', lockChangeCallback, false);

            function lockChangeCallback() {
                if (document.pointerLockElement === renderer.domElement ||
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    isMouseLocked = true;
                    console.log('üîí PointerLock activ√© (ESC pour quitter)');
                } else {
                    isMouseLocked = false;
                    console.log('üîì PointerLock d√©sactiv√©');
                }
            }

            // Mouse wheel movement
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();

                const scrollSpeed = fpsSettings.fpsScrollSpeed; // Vitesse configurable
                const delta = e.deltaY > 0 ? 1 : -1;

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);

                if (fpsMode) {
                    // MODE FPS: Sauvegarder Y pour bloquer mouvement vertical
                    const savedY = camera.position.y;

                    // D√©placement horizontal uniquement (X et Z)
                    forward.y = 0;
                    forward.normalize();

                    const prevPosition = camera.position.clone();

                    // Appliquer mouvement horizontal
                    camera.position.addScaledVector(forward, -delta * scrollSpeed);

                    // CRITIQUE: Restaurer Y pour BLOQUER axe vertical
                    camera.position.y = savedY;

                    // V√©rifier collisions
                    if (checkCollision(camera.position, prevPosition)) {
                        camera.position.copy(prevPosition);
                    }
                } else {
                    // Mode normal: zoom libre (tous axes)
                    camera.position.addScaledVector(forward, -delta * scrollSpeed);
                }
            });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            // Display controls in console
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üèõÔ∏è  SIMULATION MUS√âE - CONTR√îLES');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('');
            console.log('üîÑ BASCULER ENTRE MODES:');
            console.log('   B            - Basculer MODE FPS ‚Üî MODE NORMAL');
            console.log('   N            - Afficher/Cacher interfaces (cach√©es par d√©faut)');
            console.log('   F            - Afficher/Cacher FPS Settings (bas gauche)');
            console.log('   Ctrl+S       - Exporter param√®tres FPS dans console');
            console.log('');
            console.log('üìç MODE NORMAL (par d√©faut - ADMIN):');
            console.log('   Fl√®ches/WASD - D√©placement horizontal');
            console.log('   O/L          - Monter/Descendre librement');
            console.log('   Clic gauche  - Rotation cam√©ra');
            console.log('   Molette      - Zoom');
            console.log('');
            console.log('üéÆ MODE FPS (touche B - SPECTATEUR):');
            console.log('   WASD/Fl√®ches - Se d√©placer');
            console.log('   Shift        - Sprint (x2.5)');
            console.log('   Clic canvas  - PointerLock (ESC pour quitter)');
            console.log('   Gravit√©      - Marche sur sols (√©crans 3, 10, 11)');
            console.log('   Collisions   - Activ√©es avec murs');
            console.log('   H            - Afficher/Masquer hitbox (debug)');
            console.log('');
            console.log('üìç Spawn: Centre forme 11, quelques unit√©s au-dessus');
            console.log('üôà Interfaces cach√©es - Appuyez sur N pour afficher');
            console.log('');
            console.log('üñ±Ô∏è MODE NORMAL ACTIV√â - Cam√©ra libre');
            console.log('   Appuyez sur B pour activer le mode FPS/Spectateur');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            console.log('');
            console.log('üöÄ D√©marrage de la boucle d\'animation...');
            animate();
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚úÖ INIT() TERMIN√â AVEC SUCC√àS');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Show preview
                document.getElementById('preview').innerHTML = '<video src="' + url + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                document.getElementById('preview').classList.add('loaded');
                document.getElementById('preview').querySelector('video').play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 13;
                    document.getElementById('depth').value = 0.1;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.8;
                    document.getElementById('glow').value = 0.3;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');
                    updateValueDisplay('glow');

                    document.getElementById('load-section').classList.add('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    // Interfaces cach√©es par d√©faut, appuyer sur N pour afficher
                    document.getElementById('screen-manager-panel').classList.add('hidden');
                    document.getElementById('ui').classList.add('hidden');
                    // document.getElementById('shape-selector').classList.add('hidden'); // Already hidden
                    // updateScreenList(); // Removed: called at end of generate() instead
                }

                // Auto-play
                videoElement.play();

                // Apply automatiquement (g√©n√©rer les particules)
                console.log('üé¨ Apply automatique apr√®s chargement vid√©o...');
                generate(videoElement); // updateScreenList() is called at the end of this function

                // Double-check: r√©appliquer apr√®s un court d√©lai pour √™tre s√ªr
                setTimeout(() => {
                    console.log('üé¨ Apply automatique (2√®me passe)...');
                    generate(videoElement);
                }, 100);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        function generate(video) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üé¨ GENERATE() APPEL√â');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üì¶ allScreens avant:', Object.keys(allScreens || {}));
            console.log('üé• Vid√©o:', video ? `${video.videoWidth}x${video.videoHeight}` : 'null');

            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded in generate()!');
                alert('THREE.js not loaded.');
                return;
            }
            console.log('‚úÖ THREE.js disponible');

            console.log('‚öôÔ∏è Lecture des param√®tres des sliders...');
            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value); // Plage ajust√©e 0-0.2 pour plus de pr√©cision
            depthSmoothing = parseFloat(document.getElementById('smoothing').value); // Seuil att√©nuation micro-mouvements
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            glowIntensity = parseFloat(document.getElementById('glow').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Optimized: reduced resolution for better performance without visual quality loss
            const TARGET_WIDTH = 800;
            const TARGET_HEIGHT = 450;
            const step = Math.max(1, Math.floor(10 / particleDensity));

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            const positions = [];
            const colors = [];
            const initialZ = [];

            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 ‚Äî Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            console.log('üîç Analyse de cr√©ation des particules:');
            console.log(`   üìè step: ${step}, TARGET: ${TARGET_WIDTH}x${TARGET_HEIGHT}`);
            console.log(`   üé® hideBlack: ${hideBlack}, blackThreshold: ${blackThreshold}`);
            console.log(`   üñºÔ∏è hideBackground: ${hideBackground}, bgThreshold: ${bgThreshold || 'N/A'}`);
            console.log(`   üí° minLuminance trouv√©e: ${minLuminance.toFixed(3)}`);

            let totalPixelsScanned = 0;
            let pixelsWithAlpha = 0;
            let pixelsFilteredByBlack = 0;
            let pixelsFilteredByBackground = 0;
            let pixelsAdded = 0;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    totalPixelsScanned++;
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        pixelsWithAlpha++;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            pixelsFilteredByBlack++;
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                pixelsFilteredByBackground++;
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 ‚Äî Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent √† z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        pixelsAdded++;

                        // v1.3.1 ‚Äî Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            console.log('üìä R√©sultats de la g√©n√©ration:');
            console.log(`   üìè Pixels scann√©s: ${totalPixelsScanned}`);
            console.log(`   ‚úÖ Pixels avec alpha > 30: ${pixelsWithAlpha}`);
            console.log(`   ‚ö´ Filtr√©s par hideBlack: ${pixelsFilteredByBlack}`);
            console.log(`   üñºÔ∏è Filtr√©s par hideBackground: ${pixelsFilteredByBackground}`);
            console.log(`   ‚ú® Particules AJOUT√âES: ${pixelsAdded}`);
            console.log(`   üì¶ positions.length: ${positions.length} (${positions.length / 3} particules)`);

            // v1.3.1 ‚Äî Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < initialZ.length; i++) {
                        const z = initialZ[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // CRITICAL: Preserve custom shapes (>21) before clearing
            const customShapesToPreserve = {};
            if (allScreens) {
                Object.keys(allScreens).forEach(key => {
                    const num = parseInt(key);
                    if (num > 21) {
                        customShapesToPreserve[num] = allScreens[num];
                        // Remove from screensGroup temporarily to avoid disposal
                        if (allScreens[num].parent === screensGroup) {
                            screensGroup.remove(allScreens[num]);
                        }
                    }
                });
            }
            console.log('üíæ Formes personnalis√©es pr√©serv√©es (>21):', Object.keys(customShapesToPreserve));

            // CRITICAL: Detach transform controls before clearing to avoid "object must be part of scene graph" error
            const wasScreenSelected = selectedScreen;
            if (transformControls && selectedScreen) {
                transformControls.detach();
            }

            console.log('üßπ Nettoyage du groupe d\'√©crans...');
            // Clear group before adding new screens (only default screens 1-7 now)
            screensGroup.clear();
            console.log('‚úÖ Groupe nettoy√©');

            console.log(`üé® Mode de rendu: ${is3DMode ? '3D (InstancedMesh)' : '2D (Points)'}`);
            console.log(`üìä Nombre de particules: ${positions.length / 3}`);

            if (is3DMode) {
                console.log('üî∑ Cr√©ation des particules en mode 3D...');
                // 3D Mode: Use InstancedMesh with real 3D geometries
                const count = positions.length / 3;
                console.log(`   Count: ${count}`);
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    flatShading: true,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0xffffff, // Couleur √©missive = blanc pour prendre la couleur des particules
                    emissiveIntensity: glowIntensity // Intensit√© contr√¥l√©e par le slider
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                console.log('‚úÖ InstancedMesh cr√©√©:', particles);

                const instanceColors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    instanceColors[i * 3] = colors[i * 3];
                    instanceColors[i * 3 + 1] = colors[i * 3 + 1];
                    instanceColors[i * 3 + 2] = colors[i * 3 + 2];
                }
                particles.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);

                // Optimization: reuse matrix and color objects
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    particles.setColorAt(i, reusableColor);
                }

                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Use Points with VIDEO texture
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));

                // Create video texture
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const shapeTexture = getShapeTexture(currentShape);

                console.log('üî∏ Cr√©ation des particules en mode 2D...');
                material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    map: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
                console.log('‚úÖ Points cr√©√©s:', particles);
            }

            // Volum√©trie unilat√©rale : les particules sombres restent √† z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des √©crans : z=0 invariant au DEPTH SPREAD

            // √âcran 1 - Position de base (align√©e avec les autres √©crans en Z)
            particles.position.set(0, 0, 112.5);
            particles.rotation.set(0, 0, 0);
            console.log(`üìç √âcran 1 positionn√© √†: (${particles.position.x}, ${particles.position.y}, ${particles.position.z})`);

            // Add first screen to group
            console.log('‚ûï Ajout des particules au screensGroup...');
            screensGroup.add(particles);
            console.log('‚úÖ Particules ajout√©es au groupe');

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // Clone and position second screen to the right
            const particlesRight = particles.clone();

            // Ensure both screens share the same geometry and material
            particlesRight.geometry = particles.geometry;
            particlesRight.material = particles.material;

            // √âcran 2 - Position de base (align√©e avec les autres √©crans en Z)
            particlesRight.position.set(400, 0, 112.5);
            particlesRight.rotation.set(0, 0, 0);
            console.log(`üìç √âcran 2 positionn√© √†: (${particlesRight.position.x}, ${particlesRight.position.y}, ${particlesRight.position.z})`);

            // Add second screen to group
            screensGroup.add(particlesRight);

            // === √âCRAN 3: SOL RECTANGLE (surface doubl√©e sans scale) ===
            // Cr√©er une g√©om√©trie rectangulaire : largeur compl√®te, hauteur r√©duite de moiti√©
            // Positions multipli√©es x2 : largeur finale = 800, hauteur = 225, surface doubl√©e
            const screen3Positions = [];
            const screen3Colors = [];
            const screen3InitialZ = [];

            // Dimensions du rectangle : Largeur compl√®te (toutes les particules), hauteur r√©duite de moiti√©
            const halfH = screenH / 2; // Demi-hauteur pour centrage (112.5)
            const halfH_screen3 = halfH / 2; // Hauteur r√©duite pour √©cran 3 (56.25)

            // Filtrer les particules : TOUTES en largeur (pas de filtre sur X), hauteur r√©duite de moiti√©
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];

                // Rectangle : TOUTE la largeur (pas de condition sur X), hauteur r√©duite de moiti√©
                if (y >= -halfH_screen3 && y <= halfH_screen3) {
                    // Multiplier X et Y par 2 pour surface doubl√©e SANS scale (√©vite distorsion depth)
                    screen3Positions.push(x * 2, y * 2, z);
                    screen3Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    screen3InitialZ.push(initialZ[i]);
                }
            }

            let screen3;
            if (is3DMode) {
                // Mode 3D : cr√©er InstancedMesh avec les particules du rectangle
                const count3 = screen3Positions.length / 3;
                let baseGeometry3;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry3 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry3 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry3 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen3 = new THREE.InstancedMesh(baseGeometry3, material, count3);
                screen3.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors3 = new Float32Array(count3 * 3);
                for (let i = 0; i < count3; i++) {
                    instanceColors3[i * 3] = screen3Colors[i * 3];
                    instanceColors3[i * 3 + 1] = screen3Colors[i * 3 + 1];
                    instanceColors3[i * 3 + 2] = screen3Colors[i * 3 + 2];
                }
                screen3.instanceColor = new THREE.InstancedBufferAttribute(instanceColors3, 3);

                for (let i = 0; i < count3; i++) {
                    reusableMatrix.setPosition(
                        screen3Positions[i * 3],
                        screen3Positions[i * 3 + 1],
                        screen3Positions[i * 3 + 2]
                    );
                    screen3.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen3Colors[i * 3], screen3Colors[i * 3 + 1], screen3Colors[i * 3 + 2]);
                    screen3.setColorAt(i, reusableColor);
                }

                screen3.instanceMatrix.needsUpdate = true;
                screen3.userData.initialZ = screen3InitialZ;
                screen3.userData.positions = screen3Positions;
                screen3.userData.is3D = true;

            } else {
                // Mode 2D : cr√©er Points avec les particules du rectangle
                const geometry3 = new THREE.BufferGeometry();
                geometry3.setAttribute('position', new THREE.Float32BufferAttribute(screen3Positions, 3));
                geometry3.setAttribute('color', new THREE.Float32BufferAttribute(screen3Colors, 3));
                geometry3.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen3InitialZ, 1));

                screen3 = new THREE.Points(geometry3, material);
            }

            // Position et orientation de base
            screen3.position.set(200.858, -112.500, 112.500);
            screen3.rotation.set(1.570796, 0.000000, 0.000000); // 90¬∞ sur X
            screen3.scale.set(1, 1, 1); // Pas de scale (positions d√©j√† multipli√©es x2)

            screensGroup.add(screen3);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // Clone left wall screen for opposite wall A
            const wallOppA = particles.clone();
            wallOppA.geometry = particles.geometry;
            wallOppA.material = particles.material;

            // √âcran 5 - Position de base
            wallOppA.position.set(0, 0, 225);
            wallOppA.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180¬∞ pour faire face vers -Z

            screensGroup.add(wallOppA);

            // Clone right wall screen for opposite wall B
            const wallOppB = particlesRight.clone();
            wallOppB.geometry = particles.geometry;
            wallOppB.material = particles.material;

            // √âcran 6 - Position de base
            wallOppB.position.set(400, 0, 225);
            wallOppB.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180¬∞ pour faire face vers -Z

            screensGroup.add(wallOppB);

            // === √âCRAN 7: panneau lat√©ral CARR√â (largeur = hauteur) ===
            // Cr√©er une g√©om√©trie carr√©e : largeur = hauteur = screenH
            // L'image garde sa taille normale et "d√©passe" de l'√©cran (comme les autres)
            const screen7Positions = [];
            const screen7Colors = [];
            const screen7InitialZ = [];

            // R√©utilise halfH d√©j√† d√©clar√© pour l'√©cran 3 (screenH / 2 = 112.5)
            // Filtrer les particules pour faire un carr√© : X et Y entre -halfH et +halfH
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];

                // Carr√© centr√© : -112.5 <= X <= 112.5 ET -112.5 <= Y <= 112.5
                if (x >= -halfH && x <= halfH && y >= -halfH && y <= halfH) {
                    screen7Positions.push(x, y, z);
                    screen7Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    screen7InitialZ.push(initialZ[i]);
                }
            }

            let screen7;
            if (is3DMode) {
                // Mode 3D : cr√©er InstancedMesh avec les particules du carr√©
                const count7 = screen7Positions.length / 3;
                let baseGeometry7;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry7 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry7 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry7 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen7 = new THREE.InstancedMesh(baseGeometry7, material, count7);
                screen7.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors7 = new Float32Array(count7 * 3);
                for (let i = 0; i < count7; i++) {
                    instanceColors7[i * 3] = screen7Colors[i * 3];
                    instanceColors7[i * 3 + 1] = screen7Colors[i * 3 + 1];
                    instanceColors7[i * 3 + 2] = screen7Colors[i * 3 + 2];
                }
                screen7.instanceColor = new THREE.InstancedBufferAttribute(instanceColors7, 3);

                for (let i = 0; i < count7; i++) {
                    reusableMatrix.setPosition(
                        screen7Positions[i * 3],
                        screen7Positions[i * 3 + 1],
                        screen7Positions[i * 3 + 2]
                    );
                    screen7.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen7Colors[i * 3], screen7Colors[i * 3 + 1], screen7Colors[i * 3 + 2]);
                    screen7.setColorAt(i, reusableColor);
                }

                screen7.instanceMatrix.needsUpdate = true;
                screen7.userData.initialZ = screen7InitialZ;
                screen7.userData.positions = screen7Positions;
                screen7.userData.is3D = true;

            } else {
                // Mode 2D : cr√©er Points avec les particules du carr√©
                const geometry7 = new THREE.BufferGeometry();
                geometry7.setAttribute('position', new THREE.Float32BufferAttribute(screen7Positions, 3));
                geometry7.setAttribute('color', new THREE.Float32BufferAttribute(screen7Colors, 3));
                geometry7.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen7InitialZ, 1));

                screen7 = new THREE.Points(geometry7, material);
            }

            // Position et orientation de base (coordonn√©es ajust√©es par l'utilisateur)
            screen7.position.set(599.938, -0.064, 112.546);
            screen7.rotation.set(0, -1.570796, 0); // -90¬∞ en Y
            screen7.scale.set(1, 1, 1); // IMPORTANT: pas de scale, l'image garde sa taille normale

            screensGroup.add(screen7);

            // ======================
            // SCREEN 4: Custom shape (color surface) - white panel
            // ======================
            const width4 = 964.573;
            const height4 = 228.534;
            const geometry4 = new THREE.PlaneGeometry(width4, height4);

            // CubeCamera pour capturer l'environnement en temps r√©el
            const cubeRenderTarget4 = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter
            });
            const cubeCamera4 = new THREE.CubeCamera(1, 10000, cubeRenderTarget4);

            const material4 = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,  // Noir profond pour mieux capter les reflets
                metalness: 0.3,   // L√©g√®rement m√©tallique
                roughness: 0.6,   // Surface mate (pas miroir)
                envMap: cubeRenderTarget4.texture,  // Texture de l'environnement captur√©
                envMapIntensity: 2.5,  // Intensit√© des r√©flexions
                side: THREE.DoubleSide
            });
            const screen4 = new THREE.Mesh(geometry4, material4);

            // Position et orientation (from user JSON)
            screen4.position.set(132.131, 109.022, 112.031);
            screen4.rotation.set(1.570796, 0, 0); // 90¬∞ on X
            screen4.scale.set(1, 1, 1);

            // Positionner la CubeCamera √† l'emplacement de l'√©cran
            cubeCamera4.position.copy(screen4.position);
            scene.add(cubeCamera4);

            // Mark as color surface
            screen4.userData.screenNumber = 4;
            screen4.userData.isColorSurface = true;
            screen4.userData.color = 0x000000;
            screen4.userData.cubeCamera = cubeCamera4;  // R√©f√©rence pour la mise √† jour

            screensGroup.add(screen4);

            // ======================
            // SCREEN 8: Custom shape (color surface) - beige/pink panel
            // ======================
            const width8 = 983.983;
            const height8 = 231.29;
            const geometry8 = new THREE.PlaneGeometry(width8, height8);
            const material8 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen8 = new THREE.Mesh(geometry8, material8);

            // Position et orientation (from user JSON)
            screen8.position.set(137.097, -6.589, -0.072);
            screen8.rotation.set(0, 0, 0);
            screen8.scale.set(1, 1, 1);

            // Mark as color surface
            screen8.userData.screenNumber = 8;
            screen8.userData.isColorSurface = true;
            screen8.userData.color = 0x000000;

            screensGroup.add(screen8);

            // ======================
            // SCREEN 9: Custom shape (color surface) - gray panel back
            // ======================
            const width9 = 983.983;
            const height9 = 231.29;
            const geometry9 = new THREE.PlaneGeometry(width9, height9);
            const material9 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen9 = new THREE.Mesh(geometry9, material9);
            screen9.position.set(137.097, -6.589, 226.306);
            screen9.rotation.set(0, 0, 0);
            screen9.scale.set(1, 1, 1);
            screen9.userData.screenNumber = 9;
            screen9.userData.isColorSurface = true;
            screen9.userData.color = 0x000000;
            screensGroup.add(screen9);

            // ======================
            // SCREEN 10: Custom shape (glassmorphisme) - transparent glass floor panel
            // ======================
            const width10 = 804.246;
            const height10 = 228.534;
            const geometry10 = new THREE.PlaneGeometry(width10, height10);
            const material10 = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: fpsSettings.glassMetalness,
                roughness: fpsSettings.glassRoughness,
                opacity: fpsSettings.glassOpacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 1.0
            });
            const screen10 = new THREE.Mesh(geometry10, material10);
            screen10.position.set(205.307, -111.773, 112.611);
            screen10.rotation.set(1.570796, 0, 0);
            screen10.scale.set(1, 1, 1);
            screen10.userData.screenNumber = 10;
            screen10.userData.isColorSurface = true;
            screen10.userData.isGlass = true; // Marquer comme verre
            screen10.userData.color = 0xaaaaaa;
            screen10.visible = true; // √âcran 10 visible
            screen10.renderOrder = 1000; // Rendre apr√®s les objets opaques
            screensGroup.add(screen10);

            // ======================
            // SCREEN 11: Custom shape (color surface) - dark green small panel
            // ======================
            const width11 = 155.945;
            const height11 = 228.534;
            const geometry11 = new THREE.PlaneGeometry(width11, height11);
            const material11 = new THREE.MeshBasicMaterial({
                color: 0x0A0A0A, // Dark green
                side: THREE.DoubleSide
            });
            const screen11 = new THREE.Mesh(geometry11, material11);
            screen11.position.set(-274.876, -111.773, 112.79);
            screen11.rotation.set(1.570796, 0, 0);
            screen11.scale.set(1, 1, 1);
            screen11.userData.screenNumber = 11;
            screen11.userData.isColorSurface = true;
            screen11.userData.color = 0x0A0A0A;
            screensGroup.add(screen11);

            // ======================
            // SCREEN 12: Custom shape (color surface) - dark green vertical panel
            // ======================
            const width12 = 235.076;
            const height12 = 231.29;
            const geometry12 = new THREE.PlaneGeometry(width12, height12);
            const material12 = new THREE.MeshBasicMaterial({
                color: 0x060606, // Assombri l√©g√®rement
                side: THREE.DoubleSide
            });
            const screen12 = new THREE.Mesh(geometry12, material12);
            screen12.position.set(-348.048, -6.589, 115.234);
            screen12.rotation.set(0, 1.570796, 0);
            screen12.scale.set(1, 1, 1);
            screen12.userData.screenNumber = 12;
            screen12.userData.isColorSurface = true;
            screen12.userData.color = 0x060606;
            screensGroup.add(screen12);

            // ======================
            // SCREEN 14: Custom shape (color surface) - dark green thin panel
            // ======================
            const width14 = 96.102;
            const height14 = 231.29;
            const geometry14 = new THREE.PlaneGeometry(width14, height14);
            const material14 = new THREE.MeshBasicMaterial({
                color: 0x0A0A0A, // Dark green
                side: THREE.DoubleSide
            });
            const screen14 = new THREE.Mesh(geometry14, material14);
            screen14.position.set(-197.183, 3.851, 178.672);
            screen14.rotation.set(0, 1.570796, 0);
            screen14.scale.set(1, 1, 1);
            screen14.userData.screenNumber = 14;
            screen14.userData.isColorSurface = true;
            screen14.userData.color = 0x0A0A0A;
            screensGroup.add(screen14);

            // ======================
            // SCREEN 15: Custom shape (color surface) - dark green thin panel
            // ======================
            const width15 = 96.102;
            const height15 = 231.29;
            const geometry15 = new THREE.PlaneGeometry(width15, height15);
            const material15 = new THREE.MeshBasicMaterial({
                color: 0x0A0A0A, // Dark green
                side: THREE.DoubleSide
            });
            const screen15 = new THREE.Mesh(geometry15, material15);
            screen15.position.set(-197.107, 3.769, 47.768);
            screen15.rotation.set(0, 1.570796, 0);
            screen15.scale.set(1, 1, 1);
            screen15.userData.screenNumber = 15;
            screen15.userData.isColorSurface = true;
            screen15.userData.color = 0x0A0A0A;
            screensGroup.add(screen15);

            // ======================
            // SCREEN 16: Custom shape (color surface) - dark green horizontal panel
            // ======================
            const width16 = 163.506;
            const height16 = 239.079;
            const geometry16 = new THREE.PlaneGeometry(width16, height16);
            const material16 = new THREE.MeshBasicMaterial({
                color: 0x0A0A0A, // Dark green
                side: THREE.DoubleSide
            });
            const screen16 = new THREE.Mesh(geometry16, material16);
            screen16.position.set(-197.04, 27.158, 110.291);
            screen16.rotation.set(1.570796, 1.570796, 0);
            screen16.scale.set(1, 1, 1);
            screen16.userData.screenNumber = 16;
            screen16.userData.isColorSurface = true;
            screen16.userData.color = 0x0A0A0A;
            screensGroup.add(screen16);

            // ======================
            // SCREEN 17: Custom shape (color surface) - gray thin panel
            // ======================
            const width17 = 96.102;
            const height17 = 231.29;
            const geometry17 = new THREE.PlaneGeometry(width17, height17);
            const material17 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen17 = new THREE.Mesh(geometry17, material17);
            screen17.position.set(-200.877, -6.116, 47.768);
            screen17.rotation.set(0, 1.570796, 0);
            screen17.scale.set(1, 1, 1);
            screen17.userData.screenNumber = 17;
            screen17.userData.isColorSurface = true;
            screen17.userData.color = 0x000000;
            screensGroup.add(screen17);

            // ======================
            // SCREEN 18: Custom shape (color surface) - gray thin panel
            // ======================
            const width18 = 96.102;
            const height18 = 231.29;
            const geometry18 = new THREE.PlaneGeometry(width18, height18);
            const material18 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen18 = new THREE.Mesh(geometry18, material18);
            screen18.position.set(-200.734, -0.471, 178.493);
            screen18.rotation.set(0, 1.570796, 0);
            screen18.scale.set(1, 1, 1);
            screen18.userData.screenNumber = 18;
            screen18.userData.isColorSurface = true;
            screen18.userData.color = 0x000000;
            screensGroup.add(screen18);

            // ======================
            // SCREEN 19: Custom shape (color surface) - gray thin panel
            // ======================
            const width19 = 96.102;
            const height19 = 231.29;
            const geometry19 = new THREE.PlaneGeometry(width19, height19);
            const material19 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen19 = new THREE.Mesh(geometry19, material19);
            screen19.position.set(-200.877, -6.116, 47.768);
            screen19.rotation.set(0, 1.570796, 0);
            screen19.scale.set(1, 1, 1);
            screen19.userData.screenNumber = 19;
            screen19.userData.isColorSurface = true;
            screen19.userData.color = 0x000000;
            screensGroup.add(screen19);

            // ======================
            // SCREEN 21: Custom shape (color surface) - gray horizontal panel
            // ======================
            const width21 = 163.506;
            const height21 = 239.079;
            const geometry21 = new THREE.PlaneGeometry(width21, height21);
            const material21 = new THREE.MeshBasicMaterial({
                color: 0x000000, // Black
                side: THREE.DoubleSide
            });
            const screen21 = new THREE.Mesh(geometry21, material21);
            screen21.position.set(-200.871, 27.391, 110.392);
            screen21.rotation.set(1.570796, 1.570796, 0);
            screen21.scale.set(1, 1, 1);
            screen21.userData.screenNumber = 21;
            screen21.userData.isColorSurface = true;
            screen21.userData.color = 0x000000;
            screensGroup.add(screen21);

            // Restore custom shapes (>21) - both in allScreens and screensGroup
            console.log('üîÑ Restauration des formes personnalis√©es (>21):', Object.keys(customShapesToPreserve));
            Object.keys(customShapesToPreserve).forEach(key => {
                const shape = customShapesToPreserve[key];
                screensGroup.add(shape); // Re-add to scene
                allScreens[key] = shape; // CRITICAL: Re-add to allScreens to prevent orphaning
                console.log(`  ‚úì Forme #${key} r√©ajout√©e √† la sc√®ne et √† allScreens`);
            });

            // Update volumetric screens 1-21 (1,2,3,5,6,7 volumetric + 4,8-21 custom color surfaces)
            allScreens = {
                1: particles,           // Wall back left (volumetric)
                2: particlesRight,      // Wall back right (volumetric)
                3: screen3,             // Floor rectangle (volumetric - double width)
                4: screen4,             // Ceiling gray panel (custom color surface)
                5: wallOppA,            // Wall front left (volumetric)
                6: wallOppB,            // Wall front right (volumetric)
                7: screen7,             // Side panel (volumetric)
                8: screen8,             // Center gray panel (custom color surface)
                9: screen9,             // Back gray panel (custom color surface)
                10: screen10,           // Floor lighter green panel (custom color surface)
                11: screen11,           // Small dark green panel (custom color surface)
                12: screen12,           // Dark green vertical panel (custom color surface)
                14: screen14,           // Dark green thin panel 1 (custom color surface)
                15: screen15,           // Dark green thin panel 2 (custom color surface)
                16: screen16,           // Dark green horizontal panel (custom color surface)
                17: screen17,           // Gray thin panel 1 (custom color surface)
                18: screen18,           // Gray thin panel 2 (custom color surface)
                19: screen19,           // Gray thin panel 3 (custom color surface)
                21: screen21,           // Gray horizontal panel (custom color surface)
                ...customShapesToPreserve // Restore custom shapes (>21)
            };
            console.log('‚úÖ Tous les √©crans restaur√©s (1-21 + custom):', Object.keys(allScreens));

            // CRITICAL: Update screen list UI immediately after allScreens is populated
            updateScreenList();
            console.log('üé® Interface de gestion des √©crans mise √† jour');

            // CRITICAL: Reattach transform controls to the same screen after regeneration
            if (transformControls && wasScreenSelected && allScreens[wasScreenSelected]) {
                selectedScreen = wasScreenSelected;
                transformControls.attach(allScreens[wasScreenSelected]);
            }

            console.log('');
            console.log('=== CONTR√îLES 3D DISPONIBLES ===');
            console.log('Touches 1-7 : S√©lectionner un √©cran');
            console.log('G : Mode Translation');
            console.log('R : Mode Rotation');
            console.log('E : Mode Scale');
            console.log('Maj enfonc√© : rotation 15¬∞, translation 1000');
            console.log('√âchap : D√©s√©lectionner');
            console.log('Ctrl+Z : Annuler | Ctrl+Shift+Z : Refaire');
            console.log('S : Sauvegarder positions');
            console.log('Magn√©tisme auto √† 0/90/180/270¬∞');
            console.log('================================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }

            console.log('üèÅ generate() termin√© - allScreens final:', Object.keys(allScreens));
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 13;
            document.getElementById('depth').value = 0.1;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('glow').value = 0.3;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.80;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.80;
            hideBackground = false;
            bgThreshold = 40;
            glowIntensity = 0.3;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('glow');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            // Show visual indicator to user
            const pausedIndicator = document.getElementById('video-paused-indicator');
            if (currentVideo.paused) {
                if (pausedIndicator && !pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.add('visible');
                }
                return;
            } else {
                if (pausedIndicator && pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.remove('visible');
                }
            }

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 ‚Äî Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 ‚Äî Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // v1.3.1 ‚Äî Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent √† z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Calculate colors with effects
                        {
                            // v1.3.1 ‚Äî Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply brightness boost
                            let finalR = rNorm * brightness;
                            let finalG = gNorm * brightness;
                            let finalB = bNorm * brightness;

                            // Professional emissive effect: brighter particles glow more (non-linear power curve)
                            if (glowIntensity > 0) {
                                // Calculate luminance of the pixel
                                const pixelLuminance = 0.299 * finalR + 0.587 * finalG + 0.114 * finalB;

                                // Power curve: bright pixels get boosted more (quadratic for smooth glow)
                                const emissiveBoost = Math.pow(pixelLuminance, 2.0) * glowIntensity;

                                // Add emissive glow to bright particles
                                finalR += emissiveBoost * finalR;
                                finalG += emissiveBoost * finalG;
                                finalB += emissiveBoost * finalB;
                            }

                            // Update color with brightness + emissive
                            newColors.push(
                                Math.min(1.0, finalR),
                                Math.min(1.0, finalG),
                                Math.min(1.0, finalB)
                            );
                        }
                    }
                }
            }

            // v1.3.1 ‚Äî Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < newDepths.length; i++) {
                        const z = newDepths[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            newColors[i * 3] = 0;
                            newColors[i * 3 + 1] = 0;
                            newColors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation with smoothing
                if (particles.userData.initialZ) {
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = particles.userData.initialZ[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            particles.userData.initialZ[i] = newDepth;
                        }
                        // else: keep old depth (reduces micro-movements/noise)
                    }
                }

                // CRITICAL: Also update screen 7 if it exists (3D mode)
                if (allScreens[7] && allScreens[7].instanceColor) {
                    const screen7 = allScreens[7];
                    const colors7 = screen7.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen7.userData.initialZ) {
                                        const oldDepth = screen7.userData.initialZ[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen7.userData.initialZ[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen7.instanceColor.needsUpdate = true;
                }

                // CRITICAL: Also update screen 3 if it exists (3D mode)
                if (allScreens[3] && allScreens[3].instanceColor) {
                    const screen3 = allScreens[3];
                    const colors3 = screen3.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur r√©duite pour √©cran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen3.userData.initialZ) {
                                        const oldDepth = screen3.userData.initialZ[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen3.userData.initialZ[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen3.instanceColor.needsUpdate = true;
                }

            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation with smoothing
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = initialZArray[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            initialZArray[i] = newDepth;
                        }
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (2D mode)
                if (allScreens[7] && allScreens[7].geometry && allScreens[7].geometry.attributes.color) {
                    const screen7 = allScreens[7];
                    const geom7 = screen7.geometry;
                    const colors7 = geom7.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom7.attributes.initialZ) {
                                        const oldDepth = geom7.attributes.initialZ.array[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom7.attributes.initialZ.array[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom7.attributes.color.needsUpdate = true;
                    if (geom7.attributes.initialZ) {
                        geom7.attributes.initialZ.needsUpdate = true;
                    }
                }

                // CRITICAL: Also update screen 3 if it exists (2D mode)
                if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.color) {
                    const screen3 = allScreens[3];
                    const geom3 = screen3.geometry;
                    const colors3 = geom3.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur r√©duite pour √©cran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom3.attributes.initialZ) {
                                        const oldDepth = geom3.attributes.initialZ.array[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom3.attributes.initialZ.array[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom3.attributes.color.needsUpdate = true;
                    if (geom3.attributes.initialZ) {
                        geom3.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Collision detection function (for FPS mode) - VERSION FINALE
        function checkCollision(newPosition, prevPosition) {
            if (!fpsMode) return false;

            const hitboxWidth = fpsSettings.fpsHitboxWidth / 2; // Demi-largeur
            const hitboxHeight = fpsSettings.fpsHitboxHeight / 2; // Demi-hauteur

            // Collecter tous les murs (pas les sols 3, 10 et 11)
            // Inclut √† la fois les √©crans volum√©triques (1,2,5,6,7) et les surfaces de couleur (4,8-21+)
            const walls = [];
            for (const key in allScreens) {
                if (key === '3' || key === '10' || key === '11') continue; // Skip floors

                const screen = allScreens[key];
                // Include both volumetric screens and color surfaces (all non-floor screens)
                if (screen && screen.visible !== false) {
                    walls.push(screen);
                }
            }

            if (walls.length === 0) return false;

            // Cr√©er une bounding box autour de la nouvelle position du joueur
            const playerBox = new THREE.Box3(
                new THREE.Vector3(
                    newPosition.x - hitboxWidth,
                    newPosition.y - hitboxHeight,
                    newPosition.z - hitboxWidth
                ),
                new THREE.Vector3(
                    newPosition.x + hitboxWidth,
                    newPosition.y + hitboxHeight,
                    newPosition.z + hitboxWidth
                )
            );

            // Tester collision avec chaque mur
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                const wallBox = new THREE.Box3().setFromObject(wall);

                if (playerBox.intersectsBox(wallBox)) {
                    return true; // Collision d√©tect√©e !
                }
            }

            return false; // Pas de collision
        }

        // Animation with subtle breathing movement and video texture updates
        let animateFrameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            animateFrameCount++;
            if (animateFrameCount === 1) {
                console.log('üé¨ ANIMATE() - Premi√®re frame');
            } else if (animateFrameCount % 60 === 0) {
                console.log(`üé¨ ANIMATE() - Frame ${animateFrameCount} (${(animateFrameCount/60).toFixed(0)}s)`);
            }

            time += 0.001 * breathSpeed;

            // Update particle colors from current video frame (both 2D and 3D modes)
            if (currentVideo) {
                updateColorsFromVideo();
            }

            // Update video texture
            if (videoTexture && currentVideo) {
                videoTexture.needsUpdate = true;
            }

            if (particles && flowOffsets) {
                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {
                        // Optimization: reuse matrix object instead of creating new one
                        const epsilon = 0.3 * breathSpeed;

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            const newZ = initialZs[i] + breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 7 if it has its own geometry (3D mode)
                    if (allScreens[7] && allScreens[7].userData && allScreens[7].userData.is3D) {
                        const screen7 = allScreens[7];
                        const initialZs7 = screen7.userData.initialZ;
                        const positions7 = screen7.userData.positions;

                        if (initialZs7 && positions7 && initialZs7.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs7.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs7[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions7[i * 3] + flowX,
                                    positions7[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen7.setMatrixAt(i, reusableMatrix);
                            }
                            screen7.instanceMatrix.needsUpdate = true;
                        }
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (3D mode)
                    if (allScreens[3] && allScreens[3].userData && allScreens[3].userData.is3D) {
                        const screen3 = allScreens[3];
                        const initialZs3 = screen3.userData.initialZ;
                        const positions3 = screen3.userData.positions;

                        if (initialZs3 && positions3 && initialZs3.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs3.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs3[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions3[i * 3] + flowX,
                                    positions3[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen3.setMatrixAt(i, reusableMatrix);
                            }
                            screen3.instanceMatrix.needsUpdate = true;
                        }
                    }

                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        positions[i * 3 + 2] = initialZs[i] + breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;

                    // CRITICAL: Also update screen 7 if it has its own geometry (2D mode)
                    if (allScreens[7] && allScreens[7].geometry && allScreens[7].geometry.attributes.position) {
                        const screen7 = allScreens[7];
                        const geom7 = screen7.geometry;
                        const positions7 = geom7.attributes.position.array;
                        const initialZs7 = geom7.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom7.userData.initialPositions) {
                            geom7.userData.initialPositions = new Float32Array(positions7.length);
                            for (let i = 0; i < positions7.length; i++) {
                                geom7.userData.initialPositions[i] = positions7[i];
                            }
                        }

                        const initialPositions7 = geom7.userData.initialPositions;

                        for (let i = 0; i < positions7.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions7[i * 3] = initialPositions7[i * 3] + flowX;
                            positions7[i * 3 + 1] = initialPositions7[i * 3 + 1] + flowY;
                            positions7[i * 3 + 2] = initialZs7[i] + breathOffset;
                        }

                        geom7.attributes.position.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (2D mode)
                    if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.position) {
                        const screen3 = allScreens[3];
                        const geom3 = screen3.geometry;
                        const positions3 = geom3.attributes.position.array;
                        const initialZs3 = geom3.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom3.userData.initialPositions) {
                            geom3.userData.initialPositions = new Float32Array(positions3.length);
                            for (let i = 0; i < positions3.length; i++) {
                                geom3.userData.initialPositions[i] = positions3[i];
                            }
                        }

                        const initialPositions3 = geom3.userData.initialPositions;

                        for (let i = 0; i < positions3.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions3[i * 3] = initialPositions3[i * 3] + flowX;
                            positions3[i * 3 + 1] = initialPositions3[i * 3 + 1] + flowY;
                            positions3[i * 3 + 2] = initialZs3[i] + breathOffset;
                        }

                        geom3.attributes.position.needsUpdate = true;
                    }
                }
            }

            // Free camera rotation (apply yaw and pitch)
            if (freeCameraEnabled && camera) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;
            }

            // Camera movement (only when no screen selected and free camera enabled)
            if (!selectedScreen && freeCameraEnabled && camera) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0; // Mouvement horizontal uniquement
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                right.normalize();

                // Check if any movement key is pressed
                const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;

                if (fpsMode) {
                    // ===== MODE FPS: Vitesse gradu√©e avec acc√©l√©ration =====

                    if (isMoving) {
                        // Acc√©l√©ration progressive
                        currentSpeed = Math.min(currentSpeed + fpsSettings.fpsAcceleration, fpsSettings.fpsMaxSpeed);
                        if (cameraKeys.sprint) {
                            currentSpeed = Math.min(currentSpeed, fpsSettings.fpsMaxSpeed * 1.5); // Sprint limit√©
                        }
                    } else {
                        // D√©c√©l√©ration
                        currentSpeed = Math.max(currentSpeed - fpsSettings.fpsDeceleration, MIN_SPEED);
                    }

                    // Store previous position for collision detection
                    const prevPosition = camera.position.clone();

                    // Apply movement
                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(forward, currentSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(forward, -currentSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(right, -currentSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(right, currentSpeed);
                    }

                    // Check collisions
                    if (checkCollision(camera.position, prevPosition)) {
                        camera.position.copy(prevPosition);
                    }
                } else {
                    // ===== MODE NORMAL: Vitesse fixe, pas de collision =====

                    const normalSpeed = cameraKeys.sprint ? CAMERA_SPEED * CAMERA_SPRINT_MULTIPLIER : CAMERA_SPEED;

                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(forward, normalSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(forward, -normalSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(right, -normalSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(right, normalSpeed);
                    }
                }

                if (fpsMode) {
                    // ===== MODE FPS: Gravit√© et marche sur le sol =====

                    // Raycasting vers le bas pour d√©tecter le sol (formes 3, 10 et 11)
                    const raycaster = new THREE.Raycaster();
                    raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));

                    const floorScreens = [];
                    if (allScreens[3]) floorScreens.push(allScreens[3]);
                    if (allScreens[10]) floorScreens.push(allScreens[10]);
                    if (allScreens[11]) floorScreens.push(allScreens[11]);

                    const intersects = raycaster.intersectObjects(floorScreens, false);

                    if (intersects.length > 0) {
                        const groundY = intersects[0].point.y + fpsSettings.fpsPlayerHeight;
                        const distanceToGround = camera.position.y - groundY;

                        if (distanceToGround <= 1) {
                            // On est au sol - fixer Y et annuler v√©locit√©
                            camera.position.y = groundY;
                            playerVelocityY = 0;
                            isOnGround = true;
                        } else {
                            // On est en l'air - appliquer gravit√©
                            isOnGround = false;
                            playerVelocityY += fpsSettings.fpsGravity;
                            camera.position.y += playerVelocityY;
                        }
                    } else {
                        // Pas de sol d√©tect√© - tomber
                        isOnGround = false;
                        playerVelocityY += fpsSettings.fpsGravity;
                        camera.position.y += playerVelocityY;
                    }

                    // Head bobbing effect when moving
                    const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;
                    if (isMoving && playerVelocityY === 0) { // Only bob when on ground
                        headBobTimer += HEAD_BOB_SPEED * (cameraKeys.sprint ? 1.5 : 1);
                        const bobOffset = Math.sin(headBobTimer) * HEAD_BOB_AMOUNT;
                        camera.position.y += bobOffset;
                    } else {
                        headBobTimer *= 0.9;
                    }

                    // FOV kick during sprint
                    targetFOV = cameraKeys.sprint ? DEFAULT_FOV + SPRINT_FOV_INCREASE : DEFAULT_FOV;

                    // Visualisation de la hitbox
                    if (showHitbox) {
                        // Cr√©er ou mettre √† jour le helper
                        if (!hitboxHelper) {
                            // Cr√©er un wireframe box pour visualiser la hitbox
                            const hitboxGeometry = new THREE.BoxGeometry(1, 1, 1); // Base size
                            const hitboxMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00ff00,
                                wireframe: true,
                                transparent: true,
                                opacity: 0.5
                            });
                            hitboxHelper = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                            scene.add(hitboxHelper);
                        }

                        // Mettre √† jour la position et la taille de la hitbox dynamiquement
                        hitboxHelper.position.copy(camera.position);
                        hitboxHelper.scale.set(
                            fpsSettings.fpsHitboxWidth,
                            fpsSettings.fpsHitboxHeight,
                            fpsSettings.fpsHitboxWidth
                        );
                        hitboxHelper.visible = true;
                    } else if (hitboxHelper) {
                        hitboxHelper.visible = false;
                    }

                } else {
                    // ===== MODE NORMAL: D√©placement libre avec O/L =====

                    if (cameraKeys.up) {
                        camera.position.y += currentSpeed;
                    }
                    if (cameraKeys.down) {
                        camera.position.y -= currentSpeed;
                    }

                    // Pas de collision en mode normal (mode √©dition)
                    targetFOV = DEFAULT_FOV;
                }
            }

            // Smooth FOV transition
            if (camera && Math.abs(currentFOV - targetFOV) > 0.1) {
                currentFOV += (targetFOV - currentFOV) * 0.1;
                camera.fov = currentFOV;
                camera.updateProjectionMatrix();
            }

            // Mettre √† jour la CubeCamera de l'√©cran 4
            if (allScreens && allScreens[4] && allScreens[4].userData.cubeCamera) {
                const screen4 = allScreens[4];
                const cubeCamera = screen4.userData.cubeCamera;
                screen4.visible = false;  // Cacher l'√©cran pour √©viter auto-r√©flexion
                cubeCamera.update(renderer, scene);  // Capturer l'environnement
                screen4.visible = true;  // R√©afficher l'√©cran
            }

            if (animateFrameCount === 1) {
                console.log('üñºÔ∏è RENDER() - Premier rendu de la sc√®ne');
            }
            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Utiliser la taille compl√®te de la fen√™tre (pas de ratio forc√©)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                scheduleRegenerate();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                if (currentVideo) generate(currentVideo);
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        // Update glass material for screen 10
        function updateGlassMaterial() {
            if (allScreens[10] && allScreens[10].userData.isGlass) {
                const mat = allScreens[10].material;
                mat.metalness = fpsSettings.glassMetalness;
                mat.roughness = fpsSettings.glassRoughness;
                mat.opacity = fpsSettings.glassOpacity;
                mat.needsUpdate = true;
                console.log('üîÑ Mat√©riau verre mis √† jour:', {
                    opacity: fpsSettings.glassOpacity,
                    metalness: fpsSettings.glassMetalness,
                    roughness: fpsSettings.glassRoughness
                });
            } else {
                console.warn('‚ö†Ô∏è √âcran 10 pas encore cr√©√© ou pas marqu√© comme verre');
            }
        }

        // FPS Settings Panel Management
        function setupFPSSettings() {
            const panel = document.getElementById('fps-settings-panel');
            const sliders = {
                'fps-speed': { var: 'fpsMaxSpeed', display: 'val-fps-speed', decimals: 2 },
                'fps-scroll': { var: 'fpsScrollSpeed', display: 'val-fps-scroll', decimals: 1 },
                'fps-accel': { var: 'fpsAcceleration', display: 'val-fps-accel', decimals: 2 },
                'fps-decel': { var: 'fpsDeceleration', display: 'val-fps-decel', decimals: 2 },
                'fps-height': { var: 'fpsCameraHeight', display: 'val-fps-height', decimals: 0 },
                'fps-gravity': { var: 'fpsGravity', display: 'val-fps-gravity', decimals: 2 },
                'fps-eye': { var: 'fpsPlayerHeight', display: 'val-fps-eye', decimals: 0 },
                'fps-mouse': { var: 'fpsMouseSensitivity', display: 'val-fps-mouse', decimals: 4 },
                'fps-hitbox-width': { var: 'fpsHitboxWidth', display: 'val-fps-hitbox-width', decimals: 1 },
                'fps-hitbox-height': { var: 'fpsHitboxHeight', display: 'val-fps-hitbox-height', decimals: 0 },
                'glass-opacity': { var: 'glassOpacity', display: 'val-glass-opacity', decimals: 2, callback: updateGlassMaterial },
                'glass-roughness': { var: 'glassRoughness', display: 'val-glass-roughness', decimals: 2, callback: updateGlassMaterial },
                'glass-metalness': { var: 'glassMetalness', display: 'val-glass-metalness', decimals: 2, callback: updateGlassMaterial }
            };

            // Setup sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const config = sliders[sliderId];

                // Skip if slider doesn't exist in DOM
                if (!slider) {
                    console.warn(`‚ö†Ô∏è Slider "${sliderId}" not found in HTML`);
                    return;
                }

                slider.addEventListener('input', function() {
                    const value = parseFloat(this.value);

                    // Update variable in fpsSettings
                    fpsSettings[config.var] = value;

                    // Update display
                    const displayValue = value.toFixed(config.decimals);
                    document.getElementById(config.display).textContent = displayValue;

                    console.log(`‚úÖ ${config.var} = ${displayValue}`);

                    // Call callback if provided
                    if (config.callback) {
                        config.callback();
                    }

                    // Log hitbox changes specifically
                    if (config.var === 'fpsHitboxWidth' || config.var === 'fpsHitboxHeight') {
                        console.log('üéØ Hitbox mise √† jour:', {
                            largeur: fpsSettings.fpsHitboxWidth,
                            hauteur: fpsSettings.fpsHitboxHeight
                        });
                    }
                });
            });

            // Export button
            document.getElementById('fps-export-btn').addEventListener('click', exportFPSSettings);

            // Ctrl+S to export
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.code === 'KeyS') {
                    e.preventDefault();
                    exportFPSSettings();
                }
            });
        }

        function exportFPSSettings() {
            console.clear();
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìã PARAM√àTRES FPS - EXPORT');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('');
            console.log('Copie ces valeurs pour int√©gration:');
            console.log('');
            console.log('fpsMaxSpeed = ' + fpsSettings.fpsMaxSpeed + ';');
            console.log('fpsScrollSpeed = ' + fpsSettings.fpsScrollSpeed + ';');
            console.log('fpsAcceleration = ' + fpsSettings.fpsAcceleration + ';');
            console.log('fpsDeceleration = ' + fpsSettings.fpsDeceleration + ';');
            console.log('fpsCameraHeight = ' + fpsSettings.fpsCameraHeight + ';');
            console.log('fpsCollisionRadius = ' + fpsSettings.fpsCollisionRadius + ';');
            console.log('fpsGravity = ' + fpsSettings.fpsGravity + ';');
            console.log('fpsPlayerHeight = ' + fpsSettings.fpsPlayerHeight + ';');
            console.log('fpsMouseSensitivity = ' + fpsSettings.fpsMouseSensitivity + ';');
            console.log('');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚úÖ Param√®tres export√©s dans la console!');
            console.log('   Appuie sur Ctrl+S pour r√©-exporter');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            // Also copy to clipboard
            const exportText = Object.entries(fpsSettings)
                .map(([key, value]) => `${key} = ${value};`)
                .join('\n');

            navigator.clipboard.writeText(exportText).then(() => {
                console.log('üìã Copi√© dans le presse-papier!');
            }).catch(err => {
                console.warn('Impossible de copier dans le presse-papier:', err);
            });
        }

        // Toggle FPS panel with F key
        document.addEventListener('keydown', function(e) {
            if (e.code === 'KeyF' && !e.ctrlKey && !e.shiftKey && !e.altKey) {
                const panel = document.getElementById('fps-settings-panel');
                panel.classList.toggle('hidden');
                console.log(panel.classList.contains('hidden') ? 'üîß FPS Settings cach√©s (F pour afficher)' : 'üîß FPS Settings affich√©s (F pour cacher)');
            }
        });

        window.onload = function() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üì¶ WINDOW.ONLOAD - Page charg√©e');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîß Appel de init()...');
            init();
            console.log('‚úÖ init() termin√©');
            console.log('üîß Appel de setupFPSSettings()...');
            setupFPSSettings();
            console.log('‚úÖ setupFPSSettings() termin√©');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        };
    </script>
</body>
</html>
