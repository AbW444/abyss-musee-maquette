<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Présences aquatiques rares — Maquette dispositif</title>

    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="img/presences_rares_favicon_v2.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/presences_rares_favicon_v2.png">
    <link rel="apple-touch-icon" sizes="180x180" href="img/presences_rares_favicon_v2.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet">
    <!-- Version 1.3.1 - Video projection with luminance-based depth -->
    <style>
        :root {
            --textLeft: 240px;
            --textColW: 580px;
            --textTop: 150px;

            --logoSize: 104px;

            --playRight: 240px;
            --playBottom: 150px;

            --hoverTextShift: 90px;

            --clickTextExitX: 320px;
            --clickFadeMs: 320ms;
            --logoMoveMs: 420ms;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #000; color: #fff; overflow: hidden; }

        #canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; }
        #canvas canvas { display: block; }

        #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
              z-index: 100; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
              padding: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
              max-width: 420px; width: 90%; transition: all 0.4s ease;
              max-height: 85vh; overflow-y: auto; }

        #ui.loaded { top: auto; bottom: 20px; left: auto; right: 20px;
                     transform: none; max-width: 320px; width: auto; padding: 16px;
                     max-height: calc(100vh - 40px); overflow-y: auto; cursor: move; user-select: none; }

        #title-link { position: fixed; top: 20px; left: 20px; z-index: 100;
                      text-decoration: none; color: #fff; transition: opacity 0.2s; }
        #title-link:hover { opacity: 1 !important; }

        #title { font-size: 22px; font-weight: 600; opacity: 0.7;
                 text-transform: uppercase; letter-spacing: 2px; }

        #subtitle { font-size: 11px; font-weight: 400; opacity: 0.5;
                    margin-top: 4px; letter-spacing: 0.5px;
                    text-transform: none; }

        button { display: block; width: 100%; margin: 8px 0; padding: 14px;
                 background: rgba(255,255,255,0.1); color: #fff;
                 border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
                 cursor: pointer; font-size: 12px; font-weight: 600;
                 transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.98); }

        button.small { padding: 8px; font-size: 10px; opacity: 0.7; }
        button.small:hover { opacity: 1; }

        .preview { width: 100%; aspect-ratio: 1; border-radius: 6px; margin: 8px 0;
                   display: flex; align-items: center; justify-content: center;
                   background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
                   overflow: hidden; font-size: 10px; opacity: 0.4; }
        .preview video { max-width: 100%; max-height: 100%; object-fit: contain; }

        .preview.loaded { opacity: 1; }

        input[type="file"] { display: none; }

        label { font-size: 11px; font-weight: 600; margin-top: 16px; display: block;
                text-transform: uppercase; letter-spacing: 0.8px; opacity: 0.7; }

        .hidden { display: none !important; }

        #controls { margin-top: 16px; padding-top: 16px;
                    border-top: 1px solid rgba(255,255,255,0.15); }

        .slider { width: 100%; height: 4px; border-radius: 2px;
                  background: rgba(255,255,255,0.15); outline: none;
                  -webkit-appearance: none; margin: 10px 0; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none;
                                         width: 18px; height: 18px; border-radius: 50%;
                                         background: #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%;
                                     background: #fff; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .value { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                 cursor: pointer; padding: 2px 6px; border-radius: 3px;
                 transition: background 0.2s; }
        .value:hover { background: rgba(255,255,255,0.1); }
        .value-input { font-family: 'Courier New', monospace; font-weight: 700; font-size: 11px;
                       background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
                       color: #fff; padding: 2px 6px; border-radius: 3px; width: 60px;
                       text-align: center; }

        .param-row { margin-bottom: 14px; }
        .param-header { display: flex; justify-content: space-between; align-items: center;
                        margin-bottom: 8px; }
        .param-header label { margin: 0; }
        .param-controls { display: flex; gap: 4px; align-items: center; }

        .arrow-btn { width: 20px; height: 20px; padding: 0; margin: 0;
                     background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
                     border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;
                     display: flex; align-items: center; justify-content: center;
                     transition: all 0.15s; line-height: 1; }
        .arrow-btn:hover { background: rgba(255,255,255,0.2); }
        .arrow-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        .slider-wrapper { position: relative; }
        .slider-wrapper .slider { margin: 0; }
        .center-mark { position: absolute; top: 50%; transform: translateY(-50%);
                       width: 2px; height: 12px; background: rgba(255,255,255,0.4);
                       pointer-events: none; border-radius: 1px; }

        .hint { font-size: 9px; opacity: 0.3; margin-top: 10px; text-align: center;
                font-style: italic; }

        /* Custom scrollbar for UI */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        #shape-selector { position: fixed; top: 20px; right: 20px; z-index: 100;
                          display: flex; gap: 8px; background: rgba(0,0,0,0.75);
                          backdrop-filter: blur(10px); padding: 8px; border-radius: 8px;
                          border: 1px solid rgba(255,255,255,0.2); }

        .shape-btn { width: 40px; height: 40px; background: rgba(255,255,255,0.1);
                     border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
                     color: #fff; font-size: 20px; cursor: pointer; transition: all 0.2s;
                     display: flex; align-items: center; justify-content: center;
                     padding: 0; margin: 0; }
        .shape-btn:hover { background: rgba(255,255,255,0.2); transform: none; }
        .shape-btn.active { background: rgba(255,255,255,0.3);
                            border-color: rgba(255,255,255,0.5); }

        #mode-3d-btn { width: auto; padding: 0 12px; font-size: 10px; margin-left: 8px;
                       border-left: 1px solid rgba(255,255,255,0.3); }

        /* Version selector */
        #version-selector { position: fixed; bottom: 20px; left: 20px; z-index: 100;
                           background: rgba(0,0,0,0.75); backdrop-filter: blur(10px);
                           padding: 8px 12px; border-radius: 6px;
                           border: 1px solid rgba(255,255,255,0.2);
                           font-size: 10px; cursor: pointer; transition: all 0.2s; }
        #version-selector:hover { background: rgba(0,0,0,0.85); }

        #version-menu { position: fixed; bottom: 60px; left: 20px; z-index: 99;
                       background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
                       padding: 8px; border-radius: 6px;
                       border: 1px solid rgba(255,255,255,0.2);
                       display: none; }
        #version-menu.show { display: block; }

        .version-item { padding: 8px 12px; cursor: pointer; font-size: 10px;
                       border-radius: 4px; margin: 2px 0; transition: all 0.2s;
                       white-space: nowrap; }
        .version-item:hover { background: rgba(255,255,255,0.1); }
        .version-item.current { background: rgba(255,255,255,0.15); font-weight: 600; }

        /* Video controls */
        .video-controls { margin-top: 12px; }
        .video-control-btn { padding: 8px 12px; font-size: 10px; margin: 0; width: 100%; }

        .video-timeline { margin-top: 8px; }
        .timeline-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 3px;
            transition: background 0.2s;
        }
        .timeline-container:hover .timeline-progress {
            background: rgba(255,255,255,0.7);
        }
        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .timeline-container:hover .timeline-thumb {
            opacity: 1;
        }
        .video-time {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* Hidden video element */
        .hidden-video { position: absolute; left: -9999px; }

        /* Screen Management UI - Sobre et professionnel */
        #screen-manager-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 300px;
            width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            cursor: move;
            user-select: none;
        }
        #screen-manager-panel.hidden { display: none; }
        #screen-manager-panel h2 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            opacity: 0.7;
            margin-bottom: 12px;
            font-weight: 600;
        }
        .screen-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 12px;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .screen-list::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        .screen-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .screen-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.2);
        }
        .screen-item.selected {
            border-color: rgba(100,150,255,0.5);
            background: rgba(100,150,255,0.08);
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-header .screen-num {
            font-weight: 600;
            font-size: 11px;
            color: rgba(255,255,255,0.9);
        }
        .screen-header .screen-delete {
            background: transparent;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            font-size: 20px;
            line-height: 20px;
            cursor: pointer;
            transition: all 0.2s;
            color: rgba(255,80,80,0.7);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .screen-header .screen-delete:hover {
            color: rgba(255,80,80,1);
            transform: scale(1.15);
        }
        .screen-type-selector {
            display: none; /* Retrait transformation forme→écran */
        }
        .screen-type-btn {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 6px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .screen-type-btn.active {
            background: rgba(100,150,255,0.2);
            border-color: rgba(100,150,255,0.5);
            color: rgba(255,255,255,1);
        }
        .screen-type-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .color-section {
            margin-top: 8px;
        }
        .color-section h4 {
            font-size: 9px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.05);
            border-color: rgba(255,255,255,0.3);
        }
        .color-option.active {
            border-color: rgba(100,150,255,0.9);
            box-shadow: 0 0 12px rgba(100,150,255,0.6);
            transform: scale(1.05);
        }
        .color-custom {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .color-custom input[type="color"] {
            width: 50px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
        }
        .color-custom input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .add-screen-btn {
            background: rgba(100,200,100,0.25);
            border: 1px solid rgba(100,200,100,0.4);
            margin-top: 8px;
            padding: 10px;
            width: 100%;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: all 0.2s;
        }
        .add-screen-btn:hover {
            background: rgba(100,200,100,0.35);
            border-color: rgba(100,200,100,0.6);
        }
        .screen-manager-hint {
            display: none; /* Retrait hints texte */
        }

        /* Cacher titre et version selector */
        #title-link, #version-selector, #version-menu {
            display: none !important;
        }

        /* Réduire taille interface réglages */
        #ui.loaded {
            max-width: 280px;
            padding: 12px;
        }

        /* FPS Settings Panel - Bottom Right (avoid overlap) */
        #fps-settings-panel {
            position: fixed;
            bottom: 20px;
            right: 360px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 350px;
            width: 350px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: white;
            font-size: 11px;
            cursor: move;
        }
        #fps-settings-panel.hidden { display: none !important; }
        #fps-settings-panel h3 {
            margin: 0 0 12px 0;
            font-size: 11px;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding-right: 25px;
        }
        .fps-param {
            margin-bottom: 5px;
        }
        .fps-param label {
            display: block;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .fps-param input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        .fps-param input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        .fps-param input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
        }
        .fps-param-value {
            display: inline-block;
            float: right;
            color: #00ff88;
            font-weight: 600;
            font-size: 11px;
        }
        #fps-export-btn {
            margin-top: 10px;
            width: 100%;
            padding: 8px;
            background: rgba(0,255,136,0.15);
            border: 1px solid #00ff88;
            border-radius: 4px;
            color: #00ff88;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #fps-export-btn:hover {
            background: rgba(0,255,136,0.25);
        }

        /* Video Paused Indicator */
        #video-paused-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background: rgba(255, 100, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid rgba(255, 150, 0, 0.8);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #video-paused-indicator.visible {
            opacity: 1;
        }

        /* Welcome Screen - Page d'accueil */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10001;
            transition: opacity 0.6s ease;
            overflow: hidden;
        }
        #welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #welcome-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 40%, rgba(0,0,0,0) 60%, transparent 100%);
            z-index: 1;
            pointer-events: none;
        }
        #welcome-video-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #welcome-video-bg.loaded {
            opacity: 1;
        }
        .welcome-content {
            position: absolute;
            left: var(--textLeft);
            top: 50%;
            transform: translateY(-50%);
            width: var(--textColW);
            z-index: 2;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity var(--clickFadeMs) ease;
        }
        body.hoverPlay .welcome-content {
            transform: translateY(-50%) translateX(var(--hoverTextShift));
        }
        body.clickedPlay .welcome-content {
            opacity: 0;
            transform: translateY(-50%) translateX(var(--clickTextExitX));
        }
        .welcome-project-name {
            font-family: 'Inter', sans-serif;
            font-size: 64px;
            font-weight: 700;
            letter-spacing: 8px;
            margin-bottom: 12px;
            color: rgba(255,255,255,0.98);
            line-height: 1.1;
            text-transform: uppercase;
            display: block;
        }
        .welcome-title {
            font-family: 'Inter', sans-serif;
            font-size: 22px;
            font-weight: 500;
            letter-spacing: 1.5px;
            margin-bottom: 40px;
            color: rgba(255,255,255,0.95);
            line-height: 1.8;
            text-transform: uppercase;
        }
        .welcome-subtitle-inline {
            font-size: 13px;
            font-weight: 300;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.60);
            text-transform: none;
        }
        .welcome-text {
            font-family: 'Inter', sans-serif;
            font-size: 15px;
            font-weight: 300;
            color: rgba(255,255,255,0.70);
            line-height: 1.9;
            margin-bottom: 20px;
            letter-spacing: 0.3px;
            text-align: justify;
        }
        .welcome-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        .welcome-context {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255,255,255,0.35);
            line-height: 1.7;
            margin-top: 50px;
            padding-top: 25px;
            border-top: 1px solid rgba(255,255,255,0.08);
            letter-spacing: 0.3px;
        }
        .play-button-container {
            position: absolute;
            bottom: var(--playBottom);
            right: var(--playRight);
            cursor: pointer;
            z-index: 3;
            width: 208px;
            height: 209px;
            transition: opacity var(--clickFadeMs) ease;
        }
        body.clickedPlay .play-button-container {
            opacity: 0;
        }
        .play-button-container .play-rond,
        .play-button-container .play-fleche {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .play-button-container .play-rond {
            width: 208px;
            height: 209px;
            animation: playRondRotate 6s linear infinite;
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-rond {
            transform: scale(1.05);
        }
        @keyframes playRondRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        body.hoverPlay .play-button-container .play-rond {
            animation: playRondRotateHover 6s linear infinite;
        }
        @keyframes playRondRotateHover {
            from { transform: rotate(0deg) scale(1.05); }
            to { transform: rotate(360deg) scale(1.05); }
        }
        .play-button-container .play-fleche {
            width: 80px;
            height: 105px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) translateX(4px);
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.hoverPlay .play-button-container .play-fleche {
            transform: translate(-50%, -50%) translateX(4px) scale(1.08);
        }

        /* Logo container - PNG et WEBM */
        .welcome-logo-container {
            position: absolute;
            left: calc(var(--textLeft) / 2);
            top: 50%;
            transform: translate(-50%, -50%);
            width: var(--logoSize);
            height: var(--logoSize);
            z-index: 2;
            transition: all var(--logoMoveMs) cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Recentrage du logo lors du hover */
        body.hoverPlay .welcome-logo-container {
            left: calc((var(--textLeft) + var(--hoverTextShift)) / 2);
        }

        /* Centrage final lors du click */
        body.clickedPlay .welcome-logo-container {
            left: 50vw;
            top: 50vh;
        }

        .welcome-logo,
        .welcome-logo-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .welcome-logo-video {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .welcome-logo-video.active {
            opacity: 1;
        }

        /* Pause Screen - Ultra Modern */
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.75);
            backdrop-filter: blur(30px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            cursor: pointer;
            transition: opacity 0.4s ease;
        }
        #pause-screen.active {
            display: flex;
        }
        .pause-content {
            max-width: 850px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(40px);
            border: none;
            border-radius: 0;
            padding: 60px 70px;
            text-align: left;
            box-shadow: 0 10px 60px rgba(0,0,0,0.6);
            pointer-events: all;
            cursor: default;
        }
        .pause-title {
            font-family: 'Inter', sans-serif;
            font-size: 26px;
            font-weight: 500;
            color: rgba(255,255,255,0.95);
            margin-bottom: 35px;
            letter-spacing: 1.2px;
            text-transform: uppercase;
        }
        .pause-text {
            font-family: 'Inter', sans-serif;
            font-size: 17px;
            font-weight: 300;
            color: rgba(255,255,255,0.70);
            line-height: 1.9;
            margin-bottom: 22px;
            letter-spacing: 0.3px;
        }
        .pause-text strong {
            font-weight: 400;
            color: rgba(255,255,255,0.85);
        }
        .pause-meta {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255,255,255,0.35);
            line-height: 1.7;
            margin-top: 35px;
            padding-top: 25px;
            border-top: 1px solid rgba(255,255,255,0.08);
            letter-spacing: 0.3px;
        }
        .pause-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10000;
        }
        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            height: 150px;
            justify-content: center;
        }
        .volume-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .volume-slider {
            width: 120px;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            transform: rotate(-90deg);
            transform-origin: center;
        }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: none;
        }
        .mute-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #ffffff;
            padding: 12px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .mute-button:hover {
            background: rgba(255,255,255,0.15);
        }
        .mute-button.muted {
            background: rgba(255,100,100,0.2);
            border-color: rgba(255,100,100,0.4);
        }
        .pause-credits {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255,255,255,0.3);
            font-style: italic;
        }

        /* Game Instructions (top-left) */
        .game-instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 18px 22px;
            font-size: 16px;
            color: rgba(255,255,255,0.95);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.6s ease;
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.4px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .game-instructions.hidden {
            opacity: 0;
        }
        .instruction-row {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 16px;
            line-height: 1.35;
        }
        .keys-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .game-instructions .key {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            padding: 10px 14px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.6);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: rgba(255,255,255,1);
            font-weight: 600;
            white-space: nowrap;
        }
        .arrows-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, auto);
            grid-template-rows: repeat(2, auto);
            gap: 2px;
        }
        .arrows-grid .key {
            padding: 6px 10px;
            font-size: 12px;
            line-height: 1;
        }
        .arrows-grid .key:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }
        .arrows-grid .key:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }
        .arrows-grid .key:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }
        .arrows-grid .key:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }
        .or-text {
            font-size: 13px;
            opacity: 0.7;
            font-style: italic;
        }

        /* Instructions in pause screen - positioned like game-instructions */
        .pause-instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 18px 22px;
            font-size: 16px;
            color: rgba(255,255,255,0.95);
            z-index: 10001;
            opacity: 1;
            pointer-events: none;
            font-weight: 400;
            letter-spacing: 0.4px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .pause-instructions .instruction-row {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 16px;
            line-height: 1.35;
        }
        .pause-instructions .keys-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pause-instructions .key {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            padding: 10px 14px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.6);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: rgba(255,255,255,1);
            font-weight: 600;
            white-space: nowrap;
        }
        .pause-instructions .arrows-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, auto);
            grid-template-rows: repeat(2, auto);
            gap: 2px;
        }
        .pause-instructions .arrows-grid .key {
            padding: 6px 10px;
            font-size: 12px;
            line-height: 1;
        }
        .pause-instructions .arrows-grid .key:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }
        .pause-instructions .arrows-grid .key:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }
        .pause-instructions .arrows-grid .key:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }
        .pause-instructions .arrows-grid .key:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }
        .pause-instructions .or-text {
            font-size: 13px;
            opacity: 0.7;
            font-style: italic;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #loading-screen.active {
            display: flex;
            opacity: 1;
        }

        #loading-screen.hidden {
            opacity: 0;
        }

        .loading-video {
            width: 104px;
            height: 104px;
            opacity: 0.9;
            object-fit: contain;
        }

        /* Panel Close Button (X) */
        .panel-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        .panel-close-btn:hover {
            color: rgba(255,255,255,0.9);
            transform: scale(1.1);
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #00ff88;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #fps-counter .fps-value {
            font-size: 28px;
            font-weight: 700;
            display: block;
            line-height: 1;
            margin-bottom: 4px;
        }
        #fps-counter .fps-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        #fps-counter.low-fps {
            border-color: rgba(255, 100, 0, 0.5);
            color: #ff6400;
        }
        #fps-counter.critical-fps {
            border-color: rgba(255, 0, 0, 0.5);
            color: #ff0000;
        }
    </style>
</head>
<body>
    <!-- Game Instructions (top-left, visible when on floor Y=11) -->
    <div class="game-instructions hidden" id="game-instructions">
        <div class="instruction-row">
            <span class="key">Souris</span>
            <span>Regarder autour</span>
        </div>
        <div class="instruction-row">
            <div class="keys-group">
                <span class="key">ZQSD</span>
                <span class="or-text">ou</span>
                <div class="arrows-grid">
                    <span class="key">↑</span>
                    <span class="key">←</span>
                    <span class="key">↓</span>
                    <span class="key">→</span>
                </div>
            </div>
            <span>Se déplacer</span>
        </div>
        <div class="instruction-row">
            <span class="key">Molette</span>
            <span>Avancer / Reculer</span>
        </div>
        <div class="instruction-row">
            <span class="key">ESC</span>
            <span>Pause</span>
        </div>
    </div>

    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <video id="welcome-video-bg" autoplay loop muted playsinline>
            <source src="videos/background.mp4" type="video/mp4">
            <source src="videos/background.webm" type="video/webm">
        </video>

        <div class="welcome-logo-container" id="welcome-logo-container">
            <img src="img/presences_rares_logo.png" alt="Logo" class="welcome-logo" id="welcome-logo">
            <video class="welcome-logo-video" id="welcome-logo-video" loop muted playsinline preload="auto">
                <source src="videos/poulpe_icone_chargement.webm" type="video/webm">
            </video>
        </div>

        <div class="welcome-content" id="welcome-content">
            <span class="welcome-project-name">DUMBO</span>
            <h1 class="welcome-title">
                Présences aquatiques rares<br>
                <span class="welcome-subtitle-inline">Maquette de dispositif d'exposition</span>
            </h1>

            <p class="welcome-text">
                Présences aquatiques rares est une maquette de dispositif d'exposition développée dans le cadre d'une étude prospective de médiation scientifique.
            </p>

            <p class="welcome-text">
                Le projet explore comment des images réelles issues de captations sous-marines rares, souvent fragmentaires, instables ou difficilement lisibles, peuvent être traduites visuellement afin de rendre perceptible une présence vivante autrement inaccessible au public.
            </p>

            <p class="welcome-text">
                À partir de ces images, un protocole de transformation volumétrique est appliqué. Celui-ci ne vise ni la reconstitution fidèle du milieu aquatique, ni la production d'images spectaculaires, mais la conception de formes traduites, plus stables, plus proches et regardables dans le temps de l'exposition, tout en conservant leur ancrage documentaire.
            </p>

            <p class="welcome-text">
                L'espace que vous traversez n'est pas une exposition finale, mais une maquette spatiale et perceptive. Elle permet de tester l'échelle, la proximité, la temporalité et la relation du regard à ces formes, dans la perspective d'un futur dispositif d'exposition physique.
            </p>

            <p class="welcome-text">
                Cette maquette s'inscrit dans une réflexion sur la médiation scientifique : comment exposer des formes de vie rarement observables sans les simplifier, sans les fictionnaliser, et sans prétendre les rendre totalement accessibles.
            </p>

            <div class="welcome-context">
                Projet de recherche par le design — maquette non définitive<br>
                Images issues de sources scientifiques réelles<br>
                Traductions visuelles réalisées dans un cadre expérimental
            </div>
        </div>

        <div class="play-button-container" id="play-button" onclick="handlePlayClick()">
            <img src="img/icone_play_rond.png" alt="Play" class="play-rond">
            <img src="img/icone_play_fleche.png" alt="Play" class="play-fleche">
        </div>
    </div>

    <!-- Pause Screen (ESC) -->
    <div id="pause-screen">
        <div class="pause-instructions">
            <div class="instruction-row">
                <span class="key">Souris</span>
                <span>Regarder autour</span>
            </div>
            <div class="instruction-row">
                <div class="keys-group">
                    <span class="key">ZQSD</span>
                    <span class="or-text">ou</span>
                    <div class="arrows-grid">
                        <span class="key">↑</span>
                        <span class="key">←</span>
                        <span class="key">↓</span>
                        <span class="key">→</span>
                    </div>
                </div>
                <span>Se déplacer</span>
            </div>
            <div class="instruction-row">
                <span class="key">Molette</span>
                <span>Avancer / Reculer</span>
            </div>
            <div class="instruction-row">
                <span class="key">ESC</span>
                <span>Pause</span>
            </div>
        </div>

        <div class="pause-content" onclick="event.stopPropagation()">
            <h2 class="pause-title">À propos de cette maquette</h2>

            <p class="pause-text">
                Vous explorez une maquette de dispositif d'exposition, et non une exposition aboutie.
            </p>

            <p class="pause-text">
                Cet espace numérique a été conçu comme un outil de simulation perceptive, permettant de tester comment des formes issues d'images scientifiques réelles peuvent être perçues lorsqu'elles sont traduites volumétriquement et mises en situation d'exposition.
            </p>

            <p class="pause-text">
                Les formes présentées ne sont ni des reconstitutions fidèles, ni des créations fictionnelles. Elles résultent d'un processus de traduction visuelle, appliqué à des captations existantes, afin de rendre perceptible une présence vivante tout en assumant les limites du réel et de l'image.
            </p>

            <p class="pause-text">
                Le choix d'une maquette web répond à des contraintes de temps et de moyens. Il permet néanmoins d'explorer des questions essentielles :<br>
                — distance et proximité du regard<br>
                — échelle et corporalité<br>
                — temporalité de l'observation<br>
                — relation entre image documentaire et forme exposée
            </p>

            <p class="pause-text">
                Cette interface ne remplace pas une exposition physique. Elle en constitue une prévisualisation critique, destinée à nourrir la réflexion sur de futurs dispositifs de médiation.
            </p>

            <div class="pause-meta">
                Navigation libre — déplacement lent recommandé<br>
                Les contenus projetés peuvent évoluer au cours du projet
            </div>
        </div>

        <div class="pause-controls" onclick="event.stopPropagation()">
            <div class="volume-control">
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="70" oninput="updateVolume(this.value)">
            </div>
            <button class="mute-button" id="mute-button" onclick="toggleMute()">
                <svg id="mute-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    <line id="mute-slash" x1="2" y1="2" x2="22" y2="22" style="display:none;"></line>
                </svg>
            </button>
        </div>

        <div class="pause-credits">Musique : Teimo (schluss) par Thomas Köner</div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <video class="loading-video" autoplay loop muted playsinline preload="auto">
            <source src="videos/poulpe_icone_chargement.webm" type="video/webm">
        </video>
    </div>

    <a href="index.html" id="title-link">
        <div id="title">Volumetric Particles</div>
        <div id="subtitle">v1.3.1 — Video projection volumétrique (luminance depth)</div>
    </a>

    <div id="shape-selector" class="hidden">
        <button class="shape-btn" data-shape="circle" title="Circle">○</button>
        <button class="shape-btn active" data-shape="square" title="Square">□</button>
        <button class="shape-btn" data-shape="diamond" title="Diamond">◇</button>
        <button class="shape-btn" data-shape="star" title="Star">☆</button>
        <button class="shape-btn" id="mode-3d-btn" title="Toggle 3D Mode">3D</button>
    </div>

    <!-- Video Paused Indicator -->
    <div id="video-paused-indicator">VIDEO PAUSED</div>

    <!-- FPS Counter -->
    <div id="fps-counter">
        <span class="fps-value">60</span>
        <span class="fps-label">FPS</span>
    </div>

    <div id="canvas"></div>

    <!-- FPS Settings Panel (Bottom Left) -->
    <div id="fps-settings-panel" class="hidden">
        <button class="panel-close-btn" onclick="document.getElementById('fps-settings-panel').classList.add('hidden')" title="Fermer (F pour réafficher)">×</button>
        <h3>FPS & Verre Settings</h3>

        <div class="fps-param">
            <label>Vitesse touches <span class="fps-param-value" id="val-fps-speed">2.25</span></label>
            <input type="range" id="fps-speed" min="0.5" max="10" step="0.1" value="2.25">
        </div>

        <div class="fps-param">
            <label>Vitesse molette <span class="fps-param-value" id="val-fps-scroll">4.5</span></label>
            <input type="range" id="fps-scroll" min="0.5" max="15" step="0.5" value="4.5">
        </div>

        <div class="fps-param">
            <label>Accélération <span class="fps-param-value" id="val-fps-accel">0.10</span></label>
            <input type="range" id="fps-accel" min="0.05" max="1.0" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Décélération <span class="fps-param-value" id="val-fps-decel">0.30</span></label>
            <input type="range" id="fps-decel" min="0.05" max="1.0" step="0.05" value="0.3">
        </div>

        <div class="fps-param">
            <label>Hauteur caméra <span class="fps-param-value" id="val-fps-height">-96</span></label>
            <input type="range" id="fps-height" min="-150" max="-10" step="1" value="-96">
        </div>

        <div class="fps-param">
            <label>Gravité <span class="fps-param-value" id="val-fps-gravity">-1.50</span></label>
            <input type="range" id="fps-gravity" min="-3.0" max="-0.1" step="0.1" value="-1.5">
        </div>

        <div class="fps-param">
            <label>Hauteur yeux <span class="fps-param-value" id="val-fps-eye">30</span></label>
            <input type="range" id="fps-eye" min="5" max="100" step="1" value="30">
        </div>

        <div class="fps-param">
            <label>Sensibilité souris <span class="fps-param-value" id="val-fps-mouse">0.0010</span></label>
            <input type="range" id="fps-mouse" min="0.0005" max="0.01" step="0.0005" value="0.001">
        </div>

        <div class="fps-param">
            <label>Largeur hitbox <span class="fps-param-value" id="val-fps-hitbox-width">1</span></label>
            <input type="range" id="fps-hitbox-width" min="0.1" max="20" step="0.1" value="1">
        </div>

        <div class="fps-param">
            <label>Hauteur hitbox <span class="fps-param-value" id="val-fps-hitbox-height">10</span></label>
            <input type="range" id="fps-hitbox-height" min="1" max="100" step="1" value="10">
        </div>

        <div class="fps-param">
            <label>Opacité verre <span class="fps-param-value" id="val-glass-opacity">0.00</span></label>
            <input type="range" id="glass-opacity" min="0" max="1" step="0.05" value="0.00">
        </div>

        <div class="fps-param">
            <label>Rugosité verre <span class="fps-param-value" id="val-glass-roughness">0.10</span></label>
            <input type="range" id="glass-roughness" min="0" max="1" step="0.05" value="0.1">
        </div>

        <div class="fps-param">
            <label>Metalness verre <span class="fps-param-value" id="val-glass-metalness">0.20</span></label>
            <input type="range" id="glass-metalness" min="0" max="1" step="0.05" value="0.2">
        </div>

        <button id="fps-export-btn" style="grid-column: 1 / -1;">📋 Export (Ctrl+S)</button>
    </div>

    <!-- Hidden video element for texture source -->
    <div class="hidden-video">
        <video id="video-source" loop muted playsinline></video>
    </div>

    <!-- Version Selector -->
    <div id="version-selector">
        <span>v<span id="current-version">1.3.1</span></span>
    </div>
    <div id="version-menu">
        <div class="version-item" data-version="1.0" data-file="dispersed-volume.html">v1.0 — Image dispersée</div>
        <div class="version-item" data-version="1.3" data-file="dispersed-volume_v1.3.html">v1.3 — Video dispersée</div>
        <div class="version-item" data-version="1.3.1" data-file="dispersed-volume_v1.3.1.html">v1.3.1 — Luminance depth</div>
    </div>

    <!-- Screen Management Panel (Left side) -->
    <div id="screen-manager-panel">
        <button class="panel-close-btn" onclick="document.getElementById('screen-manager-panel').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <h2>Gestion des Écrans</h2>
        <div class="screen-list" id="screen-list"></div>
        <button class="add-screen-btn" onclick="addNewScreen()">+ Ajouter un Écran</button>
        <p class="screen-manager-hint">
            <strong>Raccourcis clavier:</strong><br>
            Touche A: Ajouter un écran<br>
            Suppr/Backspace: Supprimer sélection<br>
            Ctrl+C: Copier écran | Ctrl+V: Coller<br>
            1-7: Sélectionner écran<br>
            G/R/E/S: Translate/Rotate/Scale/Size
        </p>
    </div>

    <div id="ui">
        <button class="panel-close-btn" onclick="document.getElementById('ui').classList.add('hidden')" title="Fermer (N pour réafficher)">×</button>
        <div id="load-section">
            <div class="preview" id="preview">Empty</div>
            <button onclick="document.getElementById('file-input').click()">Load Video</button>
            <input type="file" id="file-input" accept="video/*">
            <div class="video-controls hidden" id="video-controls">
                <button class="video-control-btn" id="play-pause-btn" onclick="toggleVideo()">Pause</button>
                <div class="video-timeline">
                    <div class="timeline-container" id="timeline">
                        <div class="timeline-progress" id="timeline-progress"></div>
                        <div class="timeline-thumb" id="timeline-thumb"></div>
                    </div>
                    <div class="video-time">
                        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls" class="hidden">
            <div class="param-row">
                <div class="param-header">
                    <label>POINT SIZE</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="size" data-dir="down">▼</button>
                        <span class="value" id="val-size" data-param="size">0.39</span>
                        <button class="arrow-btn" data-param="size" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="size" min="0.1" max="2.0" step="0.01" value="0.39">
                    <div class="center-mark" id="size-mark-2d" style="left: 47.4%;"></div>
                    <div class="center-mark" id="size-mark-3d" style="left: 13.2%; display: none;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>PARTICLE DENSITY</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="density" data-dir="down">▼</button>
                        <span class="value" id="val-density" data-param="density">15X</span>
                        <button class="arrow-btn" data-param="density" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="density" min="1" max="30" step="1" value="15">
                    <div class="center-mark" style="left: 20.7%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SPREAD</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depth" data-dir="down">▼</button>
                        <span class="value" id="val-depth" data-param="depth">0.2X</span>
                        <button class="arrow-btn" data-param="depth" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depth" min="0.0" max="0.2" step="0.01" value="0.08">
                    <div class="center-mark" style="left: 50%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>DEPTH SMOOTHING</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="smoothing" data-dir="down">▼</button>
                        <span class="value" id="val-smoothing" data-param="smoothing">0.00</span>
                        <button class="arrow-btn" data-param="smoothing" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="smoothing" min="0.0" max="0.1" step="0.005" value="0.1">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BREATH SPEED</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="breath" data-dir="down">▼</button>
                        <span class="value" id="val-breath" data-param="breath">0.0</span>
                        <button class="arrow-btn" data-param="breath" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="breath" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 33.3%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>BRIGHTNESS</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="brightness" data-dir="down">▼</button>
                        <span class="value" id="val-brightness" data-param="brightness">1.1</span>
                        <button class="arrow-btn" data-param="brightness" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="brightness" min="0.5" max="3.0" step="0.1" value="1.1">
                    <div class="center-mark" style="left: 52%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>GLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="glow" data-dir="down">▼</button>
                        <span class="value" id="val-glow" data-param="glow">0.00</span>
                        <button class="arrow-btn" data-param="glow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="glow" min="0.0" max="1.0" step="0.05" value="0.0">
                    <div class="center-mark" style="left: 30%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>FLOW</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="flow" data-dir="down">▼</button>
                        <span class="value" id="val-flow" data-param="flow">0.0</span>
                        <button class="arrow-btn" data-param="flow" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="flow" min="0" max="3.0" step="0.1" value="0.0">
                    <div class="center-mark" style="left: 0%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-black" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BLACK</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-blackThreshold" data-param="blackThreshold">30</span>
                        <button class="arrow-btn" data-param="blackThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="blackThreshold" min="0" max="128" step="1" value="30">
                    <div class="center-mark" style="left: 23.4%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="enable-depth-cull" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>DEPTH CULLING</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="down">▼</button>
                        <span class="value" id="val-depthCullPower" data-param="depthCullPower">0.40</span>
                        <button class="arrow-btn" data-param="depthCullPower" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="depthCullPower" min="0.0" max="1.0" step="0.05" value="0.40">
                    <div class="center-mark" style="left: 40%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>CONTRAST</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="contrast" data-dir="down">▼</button>
                        <span class="value" id="val-contrast" data-param="contrast">1.8</span>
                        <button class="arrow-btn" data-param="contrast" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="contrast" min="0.0" max="3.0" step="0.1" value="1.8">
                    <div class="center-mark" style="left: 60%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label>SATURATION</label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="saturation" data-dir="down">▼</button>
                        <span class="value" id="val-saturation" data-param="saturation">0.70</span>
                        <button class="arrow-btn" data-param="saturation" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="saturation" min="0.0" max="2.0" step="0.05" value="0.70">
                    <div class="center-mark" style="left: 55%;"></div>
                </div>
            </div>

            <div class="param-row">
                <div class="param-header">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="hide-background" style="width: 14px; height: 14px; cursor: pointer;">
                        <span>HIDE BACKGROUND</span>
                    </label>
                    <div class="param-controls">
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="down">▼</button>
                        <span class="value" id="val-bgThreshold" data-param="bgThreshold">40</span>
                        <button class="arrow-btn" data-param="bgThreshold" data-dir="up">▲</button>
                    </div>
                </div>
                <div class="slider-wrapper">
                    <input type="range" class="slider" id="bgThreshold" min="0" max="128" step="2" value="40">
                    <div class="center-mark" style="left: 31.25%;"></div>
                </div>
            </div>

            <button onclick="applySettings()">Apply</button>
            <button onclick="resetToDefaults()">Reset to Defaults</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button class="small" onclick="changeVideo()">Change Video</button>
        </div>

        <p class="hint">Clic gauche + drag pour tourner • Molette pour avancer/reculer • Flèches: déplacement • P/M: monter/descendre • N: toggle UI</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        console.log('═══════════════════════════════════════════════════════');
        console.log('🚀 SCRIPT DÉMARRÉ - Début du chargement');
        console.log('═══════════════════════════════════════════════════════');

        let scene, camera, renderer, particles;
        let geometry, material;
        let screensGroup; // Group to contain all screens for common rotation
        let breathSpeed = 0.0;
        let depthMultiplier = 0.2;
        let depthSmoothing = 0.1; // Seuil pour atténuer micro-mouvements (0 = aucun, 0.1 = élevé)
        let pointSize = 0.39;
        let particleDensity = 15;
        let brightness = 1.1;
        let hideBlack = false;
        let blackThreshold = 30;
        let time = 0;
        let flowIntensity = 0.0;
        let currentVideo = null;
        let currentShape = 'square'; // Mode carré par défaut
        let is3DMode = false;
        let regenerateTimeout;
        let videoTexture = null;

        // Multi-video system: each volumetric screen has its own video
        let screenVideos = {}; // {1: video_element, 2: video_element, 5: video_element, ...}
        let videoTextures = {}; // {1: texture, 2: texture, 5: texture, ...}

        // New v1.3.1 parameters
        let enableDepthCull = false;
        let depthCullPower = 0.4;
        let contrast = 1.8;
        let saturation = 0.70;
        let hideBackground = false;
        let bgThreshold = 40;
        let glowIntensity = 0.0; // Émissivité/glow des particules lumineuses

        // Video sampling data for continuous updates
        let videoSamplingCanvas = null;
        let videoSamplingCtx = null;
        let videoSamplingData = null;

        // Particle density system - Safety cap to prevent performance issues
        const MAX_PARTICLES = 500000; // Cap maximum de particules par écran

        // FPS Counter variables
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let fpsCurrentFPS = 60;
        let fpsUpdateInterval = 500; // Update FPS display every 500ms

        // Cache DOM elements for FPS counter to avoid repeated queries
        let fpsDOMCache = {
            counter: null,
            value: null
        };

        // CubeCamera optimization: throttle updates
        let cubeCameraUpdateCounter = 0;
        const CUBE_CAMERA_UPDATE_INTERVAL = 3; // Update every 3 frames

        // Flow movement data - stores random offsets for each particle
        let flowOffsets = null;

        // Performance optimization: Reusable objects to avoid GC pressure
        const reusableMatrix = new THREE.Matrix4();
        const reusableColor = new THREE.Color();

        // CRITICAL PERFORMANCE: Reusable objects for collision detection & camera movement
        const reusablePlayerBox = new THREE.Box3();
        const reusableWallBox = new THREE.Box3();
        const reusableRaycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const reusableForward = new THREE.Vector3();
        const reusableRight = new THREE.Vector3();
        const reusableUp = new THREE.Vector3(0, 1, 0);
        const reusablePrevPosition = new THREE.Vector3();

        // Performance optimization: Throttle video updates to reduce CPU load
        let lastVideoUpdateTime = 0;
        const VIDEO_UPDATE_INTERVAL = 16; // ~60fps, adjust if needed (33ms = ~30fps)

        // Transform controls for manipulating screens
        let transformControls = null;
        let selectedScreen = null;
        let allScreens = {}; // Store all screens by number
        let clipboardScreen = null; // Store copied screen data for copy/paste
        let screenLabels = {}; // Store screen number labels (sprites) for volumetric screens
        let screenOutlines = {}; // Store neon outlines for admin mode debug
        const VOLUMETRIC_SCREENS = [1, 2, 3, 4, 5, 6]; // Écrans volumétriques (renumérotés sans trous)

        // Free camera (no orbit controls, no pivot)
        let freeCameraEnabled = true;
        let fpsMode = false; // Mode Normal/Admin par défaut - Touche B pour activer mode FPS
        let bPressCount = 0; // Compteur d'appuis consécutifs sur B
        let bPressTimeout = null; // Timeout pour réinitialiser le compteur
        let showHitbox = false; // Affichage de la hitbox activé avec touche H
        let hitboxHelper = null; // Helper pour visualiser la hitbox
        let cameraYaw = 0; // Rotation horizontale (Y axis)
        let cameraPitch = 0; // Rotation verticale (X axis)
        let isMouseLocked = false;

        // FPS visual effects
        let headBobTimer = 0;
        const HEAD_BOB_SPEED = 0.15;
        const HEAD_BOB_AMOUNT = 0.8;
        const DEFAULT_FOV = 75;
        const SPRINT_FOV_INCREASE = 5;
        let currentFOV = DEFAULT_FOV;
        let targetFOV = DEFAULT_FOV;

        // FPS Physics (paramètres configurables via interface)
        let playerVelocityY = 0;
        let isOnGround = false;
        let currentSpeed = 0;
        const MIN_SPEED = 0;

        // FPS Settings Object (accessible globalement)
        var fpsSettings = {
            fpsCameraHeight: -96,       // Hauteur de spawn de la caméra
            fpsGravity: -1.5,           // Gravité
            fpsPlayerHeight: 25,        // Hauteur des yeux du joueur au-dessus du sol
            fpsMaxSpeed: 2.25,          // Vitesse maximale
            fpsAcceleration: 0.1,       // Vitesse d'accélération
            fpsDeceleration: 0.3,       // Vitesse de décélération
            fpsCollisionRadius: 0.5,    // Rayon de collision (réduit par 10)
            fpsHitboxWidth: 1,          // Largeur de la hitbox (réduit par 10)
            fpsHitboxHeight: 10,        // Hauteur de la hitbox (réduit par 10)
            fpsScrollSpeed: 4.5,        // Vitesse de déplacement à la molette
            fpsMouseSensitivity: 0.001, // Sensibilité souris
            // Glassmorphisme écran 10
            glassOpacity: 0.00,         // Opacité du verre
            glassRoughness: 0.1,        // Rugosité de surface
            glassMetalness: 0.2         // Aspect métallique
        };

        // Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Magnetism settings
        const MAGNETISM_THRESHOLD = 0.05; // ~3 degrees in radians
        const MAGNETISM_ANGLES = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2];

        // Scale mode: 'uniform' (proportionnel) or 'free' (par axe)
        let scaleMode = 'free'; // Default to free mode (allows per-axis scaling)

        // FPS Camera controls (only when no screen selected)
        const cameraKeys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            sprint: false
        };
        const CAMERA_SPEED = 3; // Vitesse de déplacement de la caméra (réduite)
        const CAMERA_SPRINT_MULTIPLIER = 2.5; // Multiplicateur pour la vitesse de sprint

        // Real-time regeneration with debounce
        function scheduleRegenerate() {
            clearTimeout(regenerateTimeout);
            regenerateTimeout = setTimeout(() => {
                if (currentVideo) generate(currentVideo);
            }, 150);
        }

        // Parameter control system
        const paramConfigs = {
            size: { min: 0.1, max: 2.0, step: 0.01, decimals: 2, suffix: '' },
            density: { min: 1, max: 30, step: 1, decimals: 0, suffix: 'X' },
            depth: { min: 0.0, max: 0.2, step: 0.01, decimals: 2, suffix: 'X' }, // Plage 0-0.2 pour précision sur petites valeurs
            smoothing: { min: 0.0, max: 0.1, step: 0.005, decimals: 3, suffix: '' }, // Seuil atténuation micro-mouvements
            breath: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            brightness: { min: 0.5, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            glow: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' }, // Émissivité/glow
            flow: { min: 0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            blackThreshold: { min: 0, max: 128, step: 1, decimals: 0, suffix: '' },
            depthCullPower: { min: 0.0, max: 1.0, step: 0.05, decimals: 2, suffix: '' },
            contrast: { min: 0.0, max: 3.0, step: 0.1, decimals: 1, suffix: '' },
            saturation: { min: 0.0, max: 2.0, step: 0.05, decimals: 2, suffix: '' },
            bgThreshold: { min: 0, max: 128, step: 2, decimals: 0, suffix: '' }
        };

        function updateValueDisplay(param) {
            const slider = document.getElementById(param);
            const valueSpan = document.getElementById('val-' + param);
            const config = paramConfigs[param];
            const value = parseFloat(slider.value);
            const formatted = value.toFixed(config.decimals);
            valueSpan.textContent = formatted + config.suffix;
        }

        function setupSliderListeners() {
            Object.keys(paramConfigs).forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', function() {
                    updateValueDisplay(param);

                    // Flow is real-time, glow needs regeneration
                    if (param === 'flow') {
                        flowIntensity = parseFloat(slider.value);
                    } else if (param === 'glow') {
                        glowIntensity = parseFloat(slider.value);
                        scheduleRegenerate();
                    } else {
                        scheduleRegenerate();
                    }
                });
                updateValueDisplay(param);
            });
        }

        // Double-click to edit values
        function setupValueEditing() {
            document.querySelectorAll('.value[data-param]').forEach(valueSpan => {
                valueSpan.addEventListener('dblclick', function() {
                    const param = this.dataset.param;
                    const config = paramConfigs[param];
                    const slider = document.getElementById(param);
                    const currentValue = parseFloat(slider.value);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'value-input';
                    input.min = config.min;
                    input.max = config.max;
                    input.step = config.step;
                    input.value = currentValue.toFixed(config.decimals);

                    this.replaceWith(input);
                    input.focus();
                    input.select();

                    function finishEdit() {
                        let newValue = parseFloat(input.value);
                        newValue = Math.max(config.min, Math.min(config.max, newValue));
                        slider.value = newValue;
                        updateValueDisplay(param);

                        // Flow is real-time, doesn't need regeneration
                        if (param === 'flow') {
                            flowIntensity = newValue;
                        } else {
                            scheduleRegenerate();
                        }
                        input.replaceWith(valueSpan);
                    }

                    input.addEventListener('blur', finishEdit);
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') finishEdit();
                        if (e.key === 'Escape') {
                            input.replaceWith(valueSpan);
                        }
                    });
                });
            });
        }

        // Arrow buttons with acceleration
        let arrowInterval;
        let arrowAcceleration = 1;
        let arrowStartTime;

        function setupArrowButtons() {
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const param = btn.dataset.param;
                const direction = btn.dataset.dir === 'up' ? 1 : -1;
                const config = paramConfigs[param];

                function incrementValue() {
                    const slider = document.getElementById(param);
                    let value = parseFloat(slider.value);

                    const holdTime = Date.now() - arrowStartTime;
                    let speed = 1;
                    if (holdTime > 2000) speed = 10;
                    else if (holdTime > 1000) speed = 5;
                    else if (holdTime > 500) speed = 2;

                    value += direction * config.step * speed;
                    value = Math.max(config.min, Math.min(config.max, value));

                    slider.value = value;
                    updateValueDisplay(param);

                    // Flow is real-time, doesn't need regeneration
                    if (param === 'flow') {
                        flowIntensity = value;
                    } else {
                        scheduleRegenerate();
                    }
                }

                btn.addEventListener('mousedown', function() {
                    arrowStartTime = Date.now();
                    incrementValue();
                    arrowInterval = setInterval(incrementValue, 100);
                });

                btn.addEventListener('mouseup', stopArrow);
                btn.addEventListener('mouseleave', stopArrow);

                function stopArrow() {
                    clearInterval(arrowInterval);
                }
            });
        }

        // Video control
        function toggleVideo() {
            const video = document.getElementById('video-source');
            const btn = document.getElementById('play-pause-btn');

            if (video.paused) {
                video.play();
                btn.textContent = 'Pause';
            } else {
                video.pause();
                btn.textContent = 'Play';
            }
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update video timeline
        function updateTimeline() {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('timeline-progress');
            const thumb = document.getElementById('timeline-thumb');
            const currentTimeSpan = document.getElementById('current-time');
            const durationSpan = document.getElementById('duration');

            if (progressBar) progressBar.style.width = progress + '%';
            if (thumb) thumb.style.left = progress + '%';
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(video.currentTime);
            if (durationSpan) durationSpan.textContent = formatTime(video.duration);
        }

        // Seek video to specific position
        function seekVideo(event) {
            const video = document.getElementById('video-source');
            if (!video || !video.duration) return;

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            // SPECTATOR MODE: Only allow movement keys and mode toggle
            if (fpsMode) {
                const allowedKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',  // WASD movement
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',  // Arrow keys
                    'ShiftLeft', 'ShiftRight',  // Sprint
                    'KeyB',  // Toggle to Admin mode
                    'Escape'  // Exit pointer lock
                ];

                if (!allowedKeys.includes(e.code)) {
                    // Block all other keys in Spectator mode
                    return;
                }

                // Track movement keys for instructions hiding
                const movementKeys = [
                    'KeyW', 'KeyA', 'KeyS', 'KeyD',
                    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
                ];
                if (movementKeys.includes(e.code) && !instructionsHidden) {
                    uniqueKeysPressed.add(e.code);

                    // Démarrer le timer de maintien si c'est la première fois
                    if (!keyHoldStartTime) {
                        keyHoldStartTime = Date.now();
                        keyHoldTimer = setTimeout(() => {
                            // Touche maintenue pendant 1 seconde
                            const instructionsElement = document.getElementById('game-instructions');
                            if (instructionsElement && !instructionsHidden) {
                                instructionsElement.classList.add('hidden');
                                instructionsHidden = true;
                            }
                        }, KEY_HOLD_DURATION);
                    }

                    // Cacher les instructions si au moins 2 touches distinctes
                    if (uniqueKeysPressed.size >= REQUIRED_UNIQUE_KEYS) {
                        const instructionsElement = document.getElementById('game-instructions');
                        if (instructionsElement) {
                            instructionsElement.classList.add('hidden');
                            instructionsHidden = true;
                        }
                    }
                }
            }

            // Debug: log all Ctrl key combinations
            if (e.ctrlKey) {
                console.log('🎹 Touche Ctrl détectée:', e.code, 'ctrlKey:', e.ctrlKey, 'shiftKey:', e.shiftKey);
            }

            // Ctrl+Z: Undo (PRIORITY - check first!)
            if (e.code === 'KeyZ' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('🔄 Ctrl+Z détecté - Exécution undo()');
                undo();
                return; // Stop here
            }

            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.code === 'KeyZ' && e.ctrlKey && e.shiftKey) || (e.code === 'KeyY' && e.ctrlKey)) {
                e.preventDefault();
                e.stopPropagation();
                console.log('🔄 Ctrl+Shift+Z ou Ctrl+Y détecté - Exécution redo()');
                redo();
                return; // Stop here
            }

            // Ctrl+S: Save positions to JSON file
            if (e.code === 'KeyS' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('💾 Ctrl+S détecté - Sauvegarde positions');
                savePositionsToFile();
                return; // Stop here
            }

            // Ctrl+C: Copy selected screen
            if (e.code === 'KeyC' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('📋 Ctrl+C détecté - Copie écran');
                copyScreen();
                return; // Stop here
            }

            // Ctrl+V: Paste screen (create duplicate)
            if (e.code === 'KeyV' && e.ctrlKey) {
                e.preventDefault();
                e.stopPropagation();
                console.log('📄 Ctrl+V détecté - Collage écran');
                pasteScreen();
                return; // Stop here
            }

            // FPS Camera controls (always active, even with screen selected)
            // Arrow keys always work; WASD only when no screen selected
            if (e.code === 'ArrowUp' || (e.code === 'KeyW' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.forward = true;
            }
            if (e.code === 'ArrowDown' || (e.code === 'KeyS' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.backward = true;
            }
            if (e.code === 'ArrowLeft' || (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey)) {
                e.preventDefault();
                cameraKeys.left = true;
            }
            if (e.code === 'ArrowRight' || (e.code === 'KeyD' && !selectedScreen)) {
                e.preventDefault();
                cameraKeys.right = true;
            }

            // O/L: Camera up/down (only in normal mode, not FPS mode)
            if (e.code === 'KeyO' && !fpsMode) {
                e.preventDefault();
                cameraKeys.up = true;
            }
            if (e.code === 'KeyL' && !fpsMode) {
                e.preventDefault();
                cameraKeys.down = true;
            }

            // Shift: Sprint (when no screen selected, works in both modes)
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !selectedScreen) {
                cameraKeys.sprint = true;
            }

            // Space: play/pause (only if video exists)
            if (e.code === 'Space' && currentVideo) {
                e.preventDefault();
                toggleVideo();
            }

            // Number keys 1-9: Select screen/shape (keyboard + numpad)
            if ((e.code >= 'Digit1' && e.code <= 'Digit9') || (e.code >= 'Numpad1' && e.code <= 'Numpad9')) {
                e.preventDefault();
                const screenNum = parseInt(e.code.replace('Digit', '').replace('Numpad', ''));
                selectScreen(screenNum);
            }

            // G: Translate mode
            if (e.code === 'KeyG' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('translate');
                console.log('Mode: TRANSLATE (déplacement XYZ)');
            }

            // R: Rotate mode
            if (e.code === 'KeyR' && selectedScreen) {
                e.preventDefault();
                transformControls.setMode('rotate');
                console.log('Mode: ROTATE (rotation XYZ)');
            }

            // E: Scale mode
            if (e.code === 'KeyE' && selectedScreen) {
                e.preventDefault();
                // Cycle between scale modes
                if (transformControls.mode !== 'scale') {
                    // First press: activate scale mode
                    transformControls.setMode('scale');
                    scaleMode = 'free';
                    console.log('Mode: SCALE LIBRE (axe individuel) - Re-appuyez sur E pour mode uniforme');
                } else {
                    // Subsequent presses: toggle between free and uniform
                    scaleMode = scaleMode === 'free' ? 'uniform' : 'free';
                    console.log(`Mode: SCALE ${scaleMode === 'uniform' ? 'UNIFORME (proportionnel)' : 'LIBRE (axe individuel)'}`);
                }
            }

            // S: Size/Resize mode (when screen selected) OR Save positions (when no screen)
            if (e.code === 'KeyS' && !e.ctrlKey) {
                e.preventDefault();
                if (selectedScreen) {
                    // Activate SIZE mode (geometry resize)
                    transformControls.setMode('scale');
                    scaleMode = 'resize'; // Special mode for geometry resizing
                    console.log('=== MODE: REDIMENSIONNEMENT (S) ===');
                    console.log('Modifie les positions des particules directement');
                    console.log('→ Surface change SANS affecter depth spread');
                    console.log('→ Idéal pour harmoniser les écrans volumétriques');
                    console.log('Drag les handles pour redimensionner');
                } else {
                    saveAllPositions();
                }
            }

            // Escape: Toggle pause screen in Spectator mode OR deselect in Admin mode
            if (e.code === 'Escape') {
                e.preventDefault();
                if (fpsMode && isPaused) {
                    // Already paused: close pause screen
                    resumeExperience();
                } else if (fpsMode && !isPaused) {
                    // Spectator mode: show pause screen
                    showPauseScreen();
                } else if (selectedScreen) {
                    // Admin mode: deselect screen
                    deselectScreen();
                }
            }

            // Delete or Backspace: Delete selected screen
            if ((e.code === 'Delete' || e.code === 'Backspace') && selectedScreen) {
                e.preventDefault();
                deleteScreen(selectedScreen);
            }

            // A: Add new screen
            if (e.code === 'KeyA' && !selectedScreen && !e.ctrlKey) {
                e.preventDefault();
                addNewScreen();
            }

            // N: Toggle all interfaces
            if (e.code === 'KeyN') {
                e.preventDefault();
                toggleAllInterfaces();
            }

            // B: Toggle FPS mode (requires 5 consecutive presses)
            if (e.code === 'KeyB') {
                e.preventDefault();

                // Clear existing timeout
                if (bPressTimeout) {
                    clearTimeout(bPressTimeout);
                }

                // Increment counter
                bPressCount++;
                console.log(`🅱️ B appuyé ${bPressCount}/5 fois`);

                // Reset counter after 2 seconds of inactivity
                bPressTimeout = setTimeout(() => {
                    bPressCount = 0;
                    console.log('⏱️ Compteur B réinitialisé (timeout)');
                }, 2000);

                // Only toggle mode after 5 presses
                if (bPressCount < 5) {
                    return; // Not enough presses yet
                }

                // Reset counter and toggle mode
                bPressCount = 0;
                clearTimeout(bPressTimeout);
                fpsMode = !fpsMode;
                if (fpsMode) {
                    // ENTERING SPECTATOR MODE: Hide all interfaces
                    console.log('🎮 MODE SPECTATEUR (FPS) ACTIVÉ');
                    console.log('   - Cliquez sur le canvas pour activer PointerLock');
                    console.log('   - WASD pour se déplacer');
                    console.log('   - Shift pour sprinter');
                    console.log('   - ESC pour sortir du PointerLock');
                    console.log('   - B pour passer en mode ADMIN');
                    console.log('   - Interfaces désactivées en mode Spectateur');

                    // Hide all UI elements in Spectator mode
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('fps-counter')?.classList.add('hidden');

                    // Hide screen labels in Spectator mode
                    hideScreenLabels();

                    // Hide cursor in Spectator/FPS mode
                    document.body.style.cursor = 'none';

                    // Play background music in Spectator mode
                    playAudio();
                } else {
                    // ENTERING ADMIN MODE: Show all interfaces
                    console.log('🖱️ MODE ADMIN ACTIVÉ');

                    // Show screen labels in Admin mode
                    updateScreenLabels();

                    // Pause music in Admin mode
                    pauseAudio();
                    console.log('   - N pour afficher/cacher les interfaces');
                    console.log('   - B pour passer en mode SPECTATEUR');
                    console.log('   - F pour FPS Settings');
                    console.log('   - Toutes les touches actives');

                    // Release pointer lock if active
                    if (document.exitPointerLock) {
                        document.exitPointerLock();
                    }

                    // CRITICAL: Show cursor in Admin mode
                    document.body.style.cursor = 'default';
                    isMouseLocked = false;

                    // CRITICAL: In Admin mode, show ONLY FPS counter + screen numbers by default
                    // Other interfaces appear only when pressing N or their individual keys
                    document.getElementById('fps-counter')?.classList.remove('hidden');

                    // Hide all other interfaces by default
                    document.getElementById('ui')?.classList.add('hidden');
                    document.getElementById('screen-manager-panel')?.classList.add('hidden');
                    document.getElementById('shape-selector')?.classList.add('hidden');
                    document.getElementById('fps-settings-panel')?.classList.add('hidden');
                    document.getElementById('controls')?.classList.add('hidden');
                }
            }

            // H: Toggle hitbox visibility
            if (e.code === 'KeyH') {
                e.preventDefault();
                showHitbox = !showHitbox;
                if (showHitbox) {
                    console.log('👁️ HITBOX VISIBLE');
                } else {
                    console.log('🚫 HITBOX MASQUÉE');
                    // Remove hitbox helper if exists and dispose properly to prevent memory leak
                    if (hitboxHelper) {
                        scene.remove(hitboxHelper);
                        if (hitboxHelper.geometry) hitboxHelper.geometry.dispose();
                        if (hitboxHelper.material) hitboxHelper.material.dispose();
                        hitboxHelper = null;
                    }
                }
            }

            // Individual interface toggles (Admin mode only)
            if (!fpsMode) {
                // & (Digit1): Toggle UI (video + controls)
                if (e.key === '&' || e.code === 'Digit1') {
                    e.preventDefault();
                    const ui = document.getElementById('ui');
                    ui?.classList.toggle('hidden');
                    console.log(`🎥 Interface vidéo: ${ui?.classList.contains('hidden') ? 'cachée' : 'visible'}`);
                }

                // é (Digit2): Toggle screen manager
                if (e.key === 'é' || e.code === 'Digit2') {
                    e.preventDefault();
                    const screenManager = document.getElementById('screen-manager-panel');
                    screenManager?.classList.toggle('hidden');
                    console.log(`📺 Gestionnaire écrans: ${screenManager?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // " (Digit3): Toggle shape selector
                if (e.key === '"' || e.code === 'Digit3') {
                    e.preventDefault();
                    const shapeSelector = document.getElementById('shape-selector');
                    shapeSelector?.classList.toggle('hidden');
                    console.log(`🔷 Sélecteur formes: ${shapeSelector?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // ' (Digit4): Toggle FPS settings (replaces F key)
                if (e.key === "'" || e.code === 'Digit4') {
                    e.preventDefault();
                    const fpsSettings = document.getElementById('fps-settings-panel');
                    fpsSettings?.classList.toggle('hidden');
                    console.log(`⚙️ Paramètres FPS: ${fpsSettings?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }

                // ( (Digit5): Toggle FPS counter
                if (e.key === '(' || e.code === 'Digit5') {
                    e.preventDefault();
                    const fpsCounter = document.getElementById('fps-counter');
                    fpsCounter?.classList.toggle('hidden');
                    console.log(`📊 Compteur FPS: ${fpsCounter?.classList.contains('hidden') ? 'caché' : 'visible'}`);
                }

                // - (Digit6 or Minus): Toggle controls (protocol settings)
                if (e.key === '-' || e.code === 'Digit6' || e.code === 'Minus') {
                    e.preventDefault();
                    const controls = document.getElementById('controls');
                    controls?.classList.toggle('hidden');
                    console.log(`🎛️ Réglages protocole: ${controls?.classList.contains('hidden') ? 'cachés' : 'visibles'}`);
                }
            }
        });

        // Keyboard controls - keyup for FPS camera
        document.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                cameraKeys.forward = false;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                cameraKeys.backward = false;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                cameraKeys.left = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                cameraKeys.right = false;
            }
            if (e.code === 'KeyO') {
                cameraKeys.up = false;
            }
            if (e.code === 'KeyL') {
                cameraKeys.down = false;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                cameraKeys.sprint = false;
            }

            // Réinitialiser le timer de maintien si touche relâchée
            const movementKeys = [
                'KeyW', 'KeyA', 'KeyS', 'KeyD',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
            ];
            if (movementKeys.includes(e.code)) {
                if (keyHoldTimer) {
                    clearTimeout(keyHoldTimer);
                    keyHoldTimer = null;
                }
                keyHoldStartTime = null;
            }
        });

        // Transform control functions
        function selectScreen(num) {
            if (!allScreens[num]) {
                console.log(`Écran ${num} n'existe pas`);
                return;
            }

            selectedScreen = num;
            transformControls.attach(allScreens[num]);

            // Set snap settings based on Shift key
            document.addEventListener('keydown', onShiftChange);
            document.addEventListener('keyup', onShiftChange);

            console.log(`=== ÉCRAN ${num} SÉLECTIONNÉ ===`);
            console.log('Commandes:');
            console.log('  G = Mode Translation');
            console.log('  R = Mode Rotation');
            console.log('  E = Mode Scale (classique, affecte depth spread)');
            console.log('  S = Mode Redimensionnement (modifie positions, préserve depth)');
            console.log('  Maj enfoncé = rotation 15°, translation 1000');
            console.log('  Échap = Désélectionner');
            console.log('  Ctrl+C = Copier | Ctrl+V = Coller (dupliquer)');
            console.log('  Ctrl+Z = Annuler | Ctrl+Shift+Z = Refaire');
            console.log('  Magnétisme auto : 0/90/180/270°');
        }

        function deselectScreen() {
            if (selectedScreen) {
                console.log(`Écran ${selectedScreen} désélectionné`);
                transformControls.detach();
                selectedScreen = null;

                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }
        }

        // Toggle all interfaces (touche N) - ONLY accessible in Admin mode
        function toggleAllInterfaces() {
            // CRITICAL: Only allow in Admin mode (not FPS/Spectator mode)
            if (fpsMode) {
                console.log('⚠️ Interfaces disponibles uniquement en mode Admin (appuyez sur B)');
                return;
            }

            const ui = document.getElementById('ui');
            const screenManager = document.getElementById('screen-manager-panel');
            const shapeSelector = document.getElementById('shape-selector');
            const fpsSettings = document.getElementById('fps-settings-panel');
            const fpsCounter = document.getElementById('fps-counter');
            const loadSection = document.getElementById('load-section');

            const isVisible = !ui.classList.contains('hidden');

            if (isVisible) {
                // Cacher les interfaces SAUF load-section si aucune vidéo n'est chargée
                if (currentVideo) {
                    ui.classList.add('hidden');
                } else {
                    // Si pas de vidéo, garder load-section visible mais cacher le reste
                    document.getElementById('controls')?.classList.add('hidden');
                }
                screenManager.classList.add('hidden');
                shapeSelector.classList.add('hidden');
                fpsSettings.classList.add('hidden');
                fpsCounter.classList.add('hidden');
                console.log('🙈 Interfaces cachées (N pour afficher)');
            } else {
                ui.classList.remove('hidden');
                screenManager.classList.remove('hidden');
                shapeSelector.classList.remove('hidden');
                fpsSettings.classList.remove('hidden');
                fpsCounter.classList.remove('hidden');
                // CRITICAL: Show controls if video is loaded
                if (currentVideo) {
                    document.getElementById('controls')?.classList.remove('hidden');
                }
                console.log('👁️ Interfaces affichées (N pour cacher)');
            }
        }

        function deleteScreen(num) {
            if (!allScreens[num]) {
                console.warn(`Écran ${num} n'existe pas`);
                return;
            }

            // Save state for undo
            saveState();

            const screen = allScreens[num];

            // Detach transform controls if this screen is selected
            if (selectedScreen === num) {
                transformControls.detach();
                selectedScreen = null;
                document.removeEventListener('keydown', onShiftChange);
                document.removeEventListener('keyup', onShiftChange);
            }

            // Remove from scene
            if (screen.parent) {
                screen.parent.remove(screen);
            }

            // Dispose geometry and material to free memory
            if (screen.geometry) screen.geometry.dispose();
            if (screen.material) {
                if (Array.isArray(screen.material)) {
                    screen.material.forEach(mat => mat.dispose());
                } else {
                    screen.material.dispose();
                }
            }

            // Remove from allScreens
            delete allScreens[num];

            console.log(`=== ÉCRAN ${num} SUPPRIMÉ ===`);

            // Update UI
            updateScreenList();
        }

        // Screen numbering system for volumetric screens and shapes
        // color parameter: 'green' for volumetric screens, 'red' for forms/shapes
        function createScreenLabel(screenNumber, color = 'red') {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Choose color based on type
            const labelColor = color === 'green' ? '#00ff4c' : '#ff004c';

            // Draw number
            ctx.fillStyle = labelColor;
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Add glow effect
            ctx.shadowColor = labelColor;
            ctx.shadowBlur = 20;
            ctx.fillText(screenNumber.toString(), 128, 128);

            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(50, 50, 1);

            return sprite;
        }

        // Create neon outline for screen/shape (admin debug mode)
        function createScreenOutline(screen) {
            // Get geometry - handle both regular meshes and instanced meshes
            let geometry = screen.geometry;
            if (!geometry) return null;

            // Create edge geometry for outline
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff004c, // Neon red
                linewidth: 1,
                transparent: true,
                opacity: 0.8
            });
            const outline = new THREE.LineSegments(edges, lineMaterial);

            // Copy transform from original screen
            outline.position.copy(screen.position);
            outline.rotation.copy(screen.rotation);
            outline.scale.copy(screen.scale);

            return outline;
        }

        function updateScreenLabels() {
            // Remove existing labels
            Object.values(screenLabels).forEach(label => {
                if (label.parent) label.parent.remove(label);
            });
            screenLabels = {};

            // Remove existing outlines
            Object.values(screenOutlines).forEach(outline => {
                if (outline && outline.parent) outline.parent.remove(outline);
            });
            screenOutlines = {};

            // Only show in Admin mode
            if (fpsMode) return;

            // Create labels and outlines for ALL screens and shapes
            Object.keys(allScreens).forEach(screenNum => {
                const screen = allScreens[screenNum];
                if (!screen) return;

                const num = parseInt(screenNum);
                const isVolumetric = VOLUMETRIC_SCREENS.includes(num);

                // Create label: green for volumetric screens, red for forms/shapes
                const labelColor = isVolumetric ? 'green' : 'red';
                const label = createScreenLabel(screenNum, labelColor);
                label.position.copy(screen.position);
                scene.add(label);
                screenLabels[screenNum] = label;

                // Create outline ONLY for forms/shapes (not volumetric screens)
                if (!isVolumetric) {
                    const outline = createScreenOutline(screen);
                    if (outline) {
                        scene.add(outline);
                        screenOutlines[screenNum] = outline;
                    }
                }
            });
        }

        function hideScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = false;
            });
            Object.values(screenOutlines).forEach(outline => {
                if (outline) outline.visible = false;
            });
        }

        function showScreenLabels() {
            Object.values(screenLabels).forEach(label => {
                label.visible = true;
            });
        }

        function addNewScreen() {
            console.log('🆕 addNewScreen() appelé - allScreens actuels:', Object.keys(allScreens));
            console.trace('Stack trace:'); // Pour voir qui appelle cette fonction

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }
            console.log('🆕 Nouveau numéro trouvé:', newNum);

            // Save state for undo
            saveState();

            // Default dimensions (same as standard screen)
            const width = 450;
            const height = 450;

            // Create new screen plane with color surface
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080, // Gray by default
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Position offset from origin
            const offset = (newNum - 1) * 500;
            screen.position.set(offset, 0, 0);

            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = true; // Mark as color surface by default
            screen.userData.color = 0x808080; // Store color

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`=== ÉCRAN ${newNum} CRÉÉ ===`);
            console.log(`Position: (${offset}, 0, 0)`);
            console.log(`Dimensions: ${width} x ${height}`);
            console.log(`Type: Surface couleur unie (gris)`);

            // Update UI
            updateScreenList();
        }

        // Copy selected screen to clipboard
        function copyScreen() {
            if (!selectedScreen) {
                console.log('❌ Aucun écran sélectionné pour copier');
                return;
            }

            const screen = allScreens[selectedScreen];
            if (!screen) {
                console.log('❌ Écran non trouvé');
                return;
            }

            // Deep copy all screen properties
            clipboardScreen = {
                position: {
                    x: screen.position.x,
                    y: screen.position.y,
                    z: screen.position.z
                },
                rotation: {
                    x: screen.rotation.x,
                    y: screen.rotation.y,
                    z: screen.rotation.z
                },
                scale: {
                    x: screen.scale.x,
                    y: screen.scale.y,
                    z: screen.scale.z
                },
                isColorSurface: screen.userData.isColorSurface || false,
                color: screen.userData.color || 0x808080,
                geometryType: screen.geometry ? screen.geometry.type : 'PlaneGeometry',
                dimensions: null
            };

            // Copy geometry dimensions if available
            if (screen.geometry && screen.geometry.parameters) {
                const params = screen.geometry.parameters;
                if (params.width !== undefined && params.height !== undefined) {
                    clipboardScreen.dimensions = {
                        width: params.width,
                        height: params.height
                    };
                }
            }

            console.log(`📋 Écran ${selectedScreen} copié dans le presse-papiers`);
            console.log('   Dimensions:', clipboardScreen.dimensions);
            console.log('   Position:', clipboardScreen.position);
        }

        // Paste screen from clipboard (create duplicate)
        function pasteScreen() {
            if (!clipboardScreen) {
                console.log('❌ Presse-papiers vide - copiez d\'abord un écran (Ctrl+C)');
                return;
            }

            // Find next available screen number
            let newNum = 1;
            while (allScreens[newNum]) {
                newNum++;
            }

            // Save state for undo
            saveState();

            // Create geometry based on stored data
            let width = 450;
            let height = 450;
            if (clipboardScreen.dimensions) {
                width = clipboardScreen.dimensions.width;
                height = clipboardScreen.dimensions.height;
            }

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({
                color: clipboardScreen.color,
                side: THREE.DoubleSide
            });
            const screen = new THREE.Mesh(geometry, material);

            // Copy position, rotation, scale
            screen.position.set(
                clipboardScreen.position.x,
                clipboardScreen.position.y,
                clipboardScreen.position.z
            );
            screen.rotation.set(
                clipboardScreen.rotation.x,
                clipboardScreen.rotation.y,
                clipboardScreen.rotation.z
            );
            screen.scale.set(
                clipboardScreen.scale.x,
                clipboardScreen.scale.y,
                clipboardScreen.scale.z
            );

            // Copy metadata
            screen.userData.screenNumber = newNum;
            screen.userData.isColorSurface = clipboardScreen.isColorSurface;
            screen.userData.color = clipboardScreen.color;

            screensGroup.add(screen);
            allScreens[newNum] = screen;

            console.log(`✅ Écran ${newNum} créé par collage (duplicata)`);
            console.log(`   Position: (${screen.position.x.toFixed(3)}, ${screen.position.y.toFixed(3)}, ${screen.position.z.toFixed(3)})`);
            console.log(`   Dimensions: ${width} x ${height}`);

            // Update UI and select new screen
            updateScreenList();
            selectScreen(newNum);
        }

        function updateScreenList() {
            const screenList = document.getElementById('screen-list');
            if (!screenList) return;

            screenList.innerHTML = '';

            // Separate screens into two categories
            const videoScreens = [];
            const colorScreens = [];

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const isColorSurface = screen.userData.isColorSurface || false;

                if (isColorSurface) {
                    colorScreens.push(num);
                } else {
                    videoScreens.push(num);
                }
            });

            // Sort each category by number
            videoScreens.sort((a, b) => parseInt(a) - parseInt(b));
            colorScreens.sort((a, b) => parseInt(a) - parseInt(b));

            // Helper function to add section header
            const addSectionHeader = (title) => {
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    padding: 8px 0 4px 0;
                    font-size: 9px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    color: rgba(255,255,255,0.5);
                    margin-top: 8px;
                    border-top: 1px solid rgba(255,255,255,0.1);
                `;
                headerDiv.textContent = title;
                screenList.appendChild(headerDiv);
            };

            // Display video screens first
            if (videoScreens.length > 0) {
                addSectionHeader('Écrans vidéo');
                videoScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = false;
                const color = screen.userData.color || 0x808080;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'screen-item';
                if (selectedScreen == num) {
                    itemDiv.classList.add('selected');
                }

                // Click to select screen
                itemDiv.addEventListener('click', (e) => {
                    // Don't select if clicking delete button
                    if (!e.target.classList.contains('screen-delete')) {
                        selectScreen(num);
                        updateScreenList();
                    }
                });

                // Header with number and delete button
                const headerDiv = document.createElement('div');
                headerDiv.className = 'screen-header';
                headerDiv.innerHTML = `
                    <span class="screen-num">Écran ${num}</span>
                    <button class="screen-delete" onclick="event.stopPropagation(); deleteScreen(${num}); updateScreenList();">×</button>
                `;
                itemDiv.appendChild(headerDiv);

                // Type selector
                const typeSelectorDiv = document.createElement('div');
                typeSelectorDiv.className = 'screen-type-selector';
                typeSelectorDiv.innerHTML = `
                    <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vidéo</button>
                    <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                `;
                itemDiv.appendChild(typeSelectorDiv);

                // Color picker (only if color surface)
                if (isColorSurface) {
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x1a1a1a, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    // Reset to current color if invalid
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                }

                    screenList.appendChild(itemDiv);
                });
            }

            // Display color screens
            if (colorScreens.length > 0) {
                addSectionHeader('Formes colorées');
                colorScreens.forEach(num => {
                    const screen = allScreens[num];
                    const isColorSurface = true;
                    const color = screen.userData.color || 0x808080;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'screen-item';
                    if (selectedScreen == num) {
                        itemDiv.classList.add('selected');
                    }

                    // Click to select screen
                    itemDiv.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('screen-delete')) {
                            selectScreen(num);
                            updateScreenList();
                        }
                    });

                    // Header with number and delete button
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'screen-header';
                    headerDiv.innerHTML = `
                        <span class="screen-num">Forme ${num}</span>
                        <button class="screen-delete" onclick="event.stopPropagation(); deleteScreen(${num}); updateScreenList();">×</button>
                    `;
                    itemDiv.appendChild(headerDiv);

                    // Type selector
                    const typeSelectorDiv = document.createElement('div');
                    typeSelectorDiv.className = 'screen-type-selector';
                    typeSelectorDiv.innerHTML = `
                        <button class="screen-type-btn ${!isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, false)">Vidéo</button>
                        <button class="screen-type-btn ${isColorSurface ? 'active' : ''}" onclick="setScreenType(${num}, true)">Couleur</button>
                    `;
                    itemDiv.appendChild(typeSelectorDiv);

                    // Color picker
                    const colorSection = document.createElement('div');
                    colorSection.className = 'color-section';

                    const colorTitle = document.createElement('h4');
                    colorTitle.textContent = 'Couleur:';
                    colorSection.appendChild(colorTitle);

                    // Preset colors grid
                    const colorGrid = document.createElement('div');
                    colorGrid.className = 'color-grid';

                    const colors = [
                        { hex: '#000000', value: 0x000000, name: 'Noir' },
                        { hex: '#1a1a1a', value: 0x1a1a1a, name: 'Noir+' },
                        { hex: '#333333', value: 0x333333, name: 'Gris foncé' },
                        { hex: '#4d4d4d', value: 0x4d4d4d, name: 'Gris moyen-foncé' },
                        { hex: '#666666', value: 0x666666, name: 'Gris' },
                        { hex: '#808080', value: 0x808080, name: 'Gris moyen' },
                        { hex: '#999999', value: 0x999999, name: 'Gris clair' },
                        { hex: '#b3b3b3', value: 0xb3b3b3, name: 'Gris très clair' },
                        { hex: '#cccccc', value: 0xcccccc, name: 'Gris pâle' },
                        { hex: '#e6e6e6', value: 0xe6e6e6, name: 'Blanc cassé' },
                        { hex: '#f5f5f5', value: 0xf5f5f5, name: 'Blanc neige' },
                        { hex: '#ffffff', value: 0xffffff, name: 'Blanc' }
                    ];

                    colors.forEach(c => {
                        const colorBtn = document.createElement('div');
                        colorBtn.className = 'color-option';
                        if (color === c.value) {
                            colorBtn.classList.add('active');
                        }
                        colorBtn.style.background = c.hex;
                        colorBtn.title = c.name;
                        colorBtn.onclick = () => setScreenColor(num, c.value);
                        colorGrid.appendChild(colorBtn);
                    });

                    colorSection.appendChild(colorGrid);

                    // Custom color picker
                    const customDiv = document.createElement('div');
                    customDiv.className = 'color-custom';
                    customDiv.innerHTML = `
                        <input type="color" id="color-picker-${num}" value="${'#' + color.toString(16).padStart(6, '0')}" />
                        <input type="text" id="color-hex-${num}" value="${'#' + color.toString(16).padStart(6, '0').toUpperCase()}" placeholder="#RRGGBB" maxlength="7" />
                    `;
                    colorSection.appendChild(customDiv);

                    // Add event listeners for custom color
                    setTimeout(() => {
                        const picker = document.getElementById(`color-picker-${num}`);
                        const hexInput = document.getElementById(`color-hex-${num}`);

                        if (picker) {
                            picker.addEventListener('input', (e) => {
                                const hex = e.target.value;
                                hexInput.value = hex.toUpperCase();
                                setScreenColor(num, parseInt(hex.substring(1), 16));
                            });
                        }

                        if (hexInput) {
                            hexInput.addEventListener('change', (e) => {
                                let hex = e.target.value.trim();
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                                    picker.value = hex;
                                    setScreenColor(num, parseInt(hex.substring(1), 16));
                                } else {
                                    hexInput.value = '#' + color.toString(16).padStart(6, '0').toUpperCase();
                                }
                            });
                        }
                    }, 0);

                    itemDiv.appendChild(colorSection);
                    screenList.appendChild(itemDiv);
                });
            }
        }

        function setScreenType(num, isColorSurface) {
            const screen = allScreens[num];
            if (!screen) return;

            saveState();

            screen.userData.isColorSurface = isColorSurface;

            // Detect if this is a volumetric screen (1-7) or a shape (>7)
            const isVolumetric = (num >= 1 && num <= 7);

            if (isColorSurface) {
                // Switch to color surface
                const color = screen.userData.color || 0x808080;

                if (isVolumetric) {
                    // For volumetric screens: create overlay plane to hide particles
                    if (!screen.userData.colorOverlay) {
                        // Get screen dimensions (approximate from bounding box)
                        const box = new THREE.Box3().setFromObject(screen);
                        const size = box.getSize(new THREE.Vector3());
                        const width = Math.max(size.x, size.y, size.z);
                        const height = Math.max(size.x, size.y, size.z);

                        // Create overlay mesh
                        const overlayGeometry = new THREE.PlaneGeometry(width * 1.2, height * 1.2);
                        const overlayMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);

                        // Position overlay at screen position (local space)
                        overlay.position.copy(screen.position);
                        overlay.rotation.copy(screen.rotation);
                        overlay.scale.copy(screen.scale);

                        screensGroup.add(overlay);
                        screen.userData.colorOverlay = overlay;
                    } else {
                        // Update existing overlay color
                        screen.userData.colorOverlay.material.color.setHex(color);
                        screen.userData.colorOverlay.visible = true;
                    }

                    // Hide volumetric particles
                    screen.visible = false;

                } else {
                    // For shapes: just change material color
                    screen.material.color.setHex(color);
                }
            } else {
                // Switch to video
                if (isVolumetric) {
                    // For volumetric screens: hide overlay, show particles
                    if (screen.userData.colorOverlay) {
                        screen.userData.colorOverlay.visible = false;
                    }
                    screen.visible = true;
                } else {
                    // For shapes: can't convert to video (not supported yet)
                    console.warn(`Écran ${num}: Conversion forme → vidéo non supportée`);
                }
            }

            updateScreenList();
            console.log(`Écran ${num}: Type changé en ${isColorSurface ? 'Couleur' : 'Vidéo'}`);
        }

        function setScreenColor(num, colorValue) {
            const screen = allScreens[num];
            if (!screen || !screen.userData.isColorSurface) return;

            saveState();

            screen.userData.color = colorValue;

            // Update color for volumetric overlay or direct material
            const isVolumetric = (num >= 1 && num <= 7);
            if (isVolumetric && screen.userData.colorOverlay) {
                screen.userData.colorOverlay.material.color.setHex(colorValue);
            } else if (screen.material) {
                screen.material.color.setHex(colorValue);
            }

            updateScreenList();
            console.log(`Écran ${num}: Couleur changée → #${colorValue.toString(16).padStart(6, '0')}`);
        }

        function onShiftChange(e) {
            if (!transformControls || !selectedScreen) return;

            const isShiftPressed = e.shiftKey;

            if (transformControls.mode === 'rotate') {
                // Rotation par pas de 15° (en radians)
                transformControls.setRotationSnap(isShiftPressed ? THREE.MathUtils.degToRad(15) : null);
            } else if (transformControls.mode === 'translate') {
                // Translation snapping de 1000 unités
                transformControls.setTranslationSnap(isShiftPressed ? 1000 : null);
            }
        }

        // Apply magnetism to rotation - snap to 0, 90, 180, 270 degrees when close
        function applyMagnetism(screen) {
            if (!screen) return;

            ['x', 'y', 'z'].forEach(axis => {
                const rotation = screen.rotation[axis];
                const normalized = ((rotation % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                for (let angle of MAGNETISM_ANGLES) {
                    if (Math.abs(normalized - angle) < MAGNETISM_THRESHOLD) {
                        screen.rotation[axis] = rotation - normalized + angle;
                        break;
                    }
                }
            });
        }

        // PROFESSIONAL UNDO/REDO SYSTEM - Complet et robuste
        function saveState() {
            const state = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            // Deep copy of ALL screen properties
            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                state.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });

            undoHistory.push(state);
            console.log('💾 saveState() - État sauvegardé, écrans:', Object.keys(state.screens), 'historique:', undoHistory.length);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Clear redo history when new action is made
            redoHistory = [];
        }

        function undo() {
            console.log('🔄 undo() appelé - undoHistory.length:', undoHistory.length);

            if (undoHistory.length === 0) {
                console.log('❌ Rien à annuler (historique vide)');
                return;
            }

            // Save current state to redo BEFORE undoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            console.log('💾 État actuel sauvegardé dans redo, écrans:', Object.keys(currentState.screens));
            redoHistory.push(currentState);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }

            // Restore previous state
            const previousState = undoHistory.pop();
            console.log('⏮️ Restauration état précédent, écrans:', Object.keys(previousState.screens));

            // Restore all screens from previous state
            Object.keys(previousState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = previousState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (previousState.selectedScreen && allScreens[previousState.selectedScreen]) {
                selectScreen(previousState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('✅ Annulé (Ctrl+Z)');
        }

        function redo() {
            if (redoHistory.length === 0) {
                console.log('❌ Rien à refaire');
                return;
            }

            // Save current state to undo BEFORE redoing
            const currentState = {
                screens: {},
                selectedScreen: selectedScreen,
                timestamp: Date.now()
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                currentState.screens[num] = {
                    position: { x: screen.position.x, y: screen.position.y, z: screen.position.z },
                    rotation: { x: screen.rotation.x, y: screen.rotation.y, z: screen.rotation.z },
                    scale: { x: screen.scale.x, y: screen.scale.y, z: screen.scale.z },
                    visible: screen.visible,
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };
            });
            undoHistory.push(currentState);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }

            // Restore next state
            const nextState = redoHistory.pop();

            // Restore all screens from next state
            Object.keys(nextState.screens).forEach(num => {
                if (allScreens[num]) {
                    const screen = allScreens[num];
                    const state = nextState.screens[num];
                    screen.position.set(state.position.x, state.position.y, state.position.z);
                    screen.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                    screen.scale.set(state.scale.x, state.scale.y, state.scale.z);
                    screen.visible = state.visible;
                    if (state.isColorSurface !== undefined) {
                        screen.userData.isColorSurface = state.isColorSurface;
                    }
                    if (state.color !== undefined) {
                        screen.userData.color = state.color;
                    }
                }
            });

            // Restore selection
            if (nextState.selectedScreen && allScreens[nextState.selectedScreen]) {
                selectScreen(nextState.selectedScreen);
            } else if (selectedScreen) {
                deselectScreen();
            }

            updateScreenList();
            console.log('✅ Refait (Ctrl+Shift+Z)');
        }

        function saveAllPositions() {
            console.log('');
            console.log('='.repeat(60));
            console.log('SAUVEGARDE DES POSITIONS - COPIER-COLLER DANS LE CODE');
            console.log('='.repeat(60));
            console.log('');

            Object.keys(allScreens).sort().forEach(num => {
                const screen = allScreens[num];
                const pos = screen.position;
                const rot = screen.rotation;
                const scale = screen.scale;

                console.log(`// Écran ${num}`);
                console.log(`screen${num}.position.set(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)});`);
                console.log(`screen${num}.rotation.set(${rot.x.toFixed(6)}, ${rot.y.toFixed(6)}, ${rot.z.toFixed(6)});`);
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    console.log(`screen${num}.scale.set(${scale.x.toFixed(3)}, ${scale.y.toFixed(3)}, ${scale.z.toFixed(3)});`);
                }
                console.log('');
            });

            console.log('='.repeat(60));
        }

        // Save positions to JSON file (Ctrl+S)
        function savePositionsToFile() {
            const data = {
                timestamp: new Date().toISOString(),
                screens: {}
            };

            Object.keys(allScreens).forEach(num => {
                const screen = allScreens[num];
                const screenData = {
                    position: {
                        x: parseFloat(screen.position.x.toFixed(3)),
                        y: parseFloat(screen.position.y.toFixed(3)),
                        z: parseFloat(screen.position.z.toFixed(3))
                    },
                    rotation: {
                        x: parseFloat(screen.rotation.x.toFixed(6)),
                        y: parseFloat(screen.rotation.y.toFixed(6)),
                        z: parseFloat(screen.rotation.z.toFixed(6))
                    },
                    scale: {
                        x: parseFloat(screen.scale.x.toFixed(3)),
                        y: parseFloat(screen.scale.y.toFixed(3)),
                        z: parseFloat(screen.scale.z.toFixed(3))
                    },
                    // Type and properties
                    isColorSurface: screen.userData.isColorSurface || false,
                    color: screen.userData.color || 0x808080
                };

                // Save geometry dimensions if available
                if (screen.geometry && screen.geometry.parameters) {
                    const params = screen.geometry.parameters;
                    if (params.width !== undefined && params.height !== undefined) {
                        screenData.dimensions = {
                            width: parseFloat(params.width.toFixed(3)),
                            height: parseFloat(params.height.toFixed(3))
                        };
                    }
                    // Save geometry type
                    screenData.geometryType = screen.geometry.type || 'unknown';
                }

                data.screens[num] = screenData;
            });

            // Download as JSON file
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `screen-positions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('✅ Positions complètes (avec dimensions) sauvegardées dans le fichier JSON téléchargé');
            console.log(`📦 ${Object.keys(allScreens).length} écrans exportés`);
        }

        // Shape texture generators
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(64, 32);
            ctx.lineTo(32, 64);
            ctx.lineTo(0, 32);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear to transparent
            ctx.clearRect(0, 0, 64, 64);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 32 + Math.cos(angle) * 30;
                const y = 32 + Math.sin(angle) * 30;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getShapeTexture(shape) {
            switch(shape) {
                case 'circle': return createCircleTexture();
                case 'square': return createSquareTexture();
                case 'diamond': return createDiamondTexture();
                case 'star': return createStarTexture();
                default: return createCircleTexture();
            }
        }

        // Init Three.js
        function init() {
            console.log('═══════════════════════════════════════════════════════');
            console.log('🔧 INIT() - Début de l\'initialisation');
            console.log('═══════════════════════════════════════════════════════');

            console.log('📦 Vérification THREE.js...');
            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded!');
                alert('THREE.js failed to load.');
                return;
            }
            console.log('✅ THREE.js chargé:', THREE.REVISION);

            console.log('🌍 Création de la scène...');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            console.log('✅ Scène créée');

            console.log('📦 Création du groupe d\'écrans...');
            // Create group to contain screens for common rotation
            screensGroup = new THREE.Group();
            scene.add(screensGroup);
            console.log('✅ Groupe d\'écrans créé et ajouté à la scène');

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;
            console.log(`📐 Dimensions: ${canvasWidth}x${canvasHeight} (ratio: ${aspectRatio.toFixed(2)})`);

            console.log('📷 Création de la caméra...');
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
            // Position de spawn au centre de la forme 11, à quelques unités au-dessus du sol
            // Sol de la forme 11: y = -111.773, on spawn à fpsCameraHeight
            camera.position.set(-274.876, fpsSettings.fpsCameraHeight, 112.79);
            console.log(`📍 Position caméra: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);

            // Orienter la caméra vers l'écran 7 puis tourner d'un quart de tour supplémentaire
            const lookAtTarget = new THREE.Vector3(599.938, fpsSettings.fpsCameraHeight, 112.546);
            camera.lookAt(lookAtTarget);
            console.log(`👀 Caméra regarde vers: (${lookAtTarget.x.toFixed(1)}, ${lookAtTarget.y.toFixed(1)}, ${lookAtTarget.z.toFixed(1)})`);

            // Calculer yaw et pitch initiaux basés sur l'orientation
            const direction = new THREE.Vector3();
            direction.subVectors(lookAtTarget, camera.position).normalize();
            cameraYaw = Math.atan2(direction.x, direction.z) + Math.PI; // +180° (quart de tour supplémentaire)
            cameraPitch = 0; // Vision horizontale
            console.log(`🎯 Orientation: yaw=${cameraYaw.toFixed(2)}, pitch=${cameraPitch.toFixed(2)}`);
            console.log('✅ Caméra configurée');

            console.log('🖼️ Création du renderer...');
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            console.log('✅ Renderer créé et configuré');

            console.log('📎 Ajout du canvas au DOM...');
            const canvasContainer = document.getElementById('canvas');
            if (!canvasContainer) {
                console.error('❌ Element #canvas introuvable dans le DOM!');
                return;
            }
            canvasContainer.appendChild(renderer.domElement);
            console.log('✅ Canvas ajouté au DOM');

            console.log('💡 Ajout des lumières...');
            // Lumière ambiante
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            console.log('✅ Lumière ambiante ajoutée');

            // FREE CAMERA: Pas d'OrbitControls, caméra complètement libre
            // Rotation avec clic droit + drag, mouvement avec flèches

            console.log('🎮 Configuration des TransformControls...');
            // TransformControls for manipulating screens
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('world'); // Use world space to avoid X/Y inversion
            scene.add(transformControls);
            console.log('✅ TransformControls configurés');

            // When transforming, disable free camera
            transformControls.addEventListener('dragging-changed', function(event) {
                freeCameraEnabled = !event.value;

                // Apply magnetism when releasing (end of drag)
                if (!event.value && selectedScreen && allScreens[selectedScreen]) {
                    applyMagnetism(allScreens[selectedScreen]);
                }
            });

            // Save state when starting to drag
            transformControls.addEventListener('mouseDown', function() {
                if (selectedScreen) {
                    saveState();
                }
            });

            // Handle scale modes: uniform, free, and resize
            let lastResizeScale = {x: 1, y: 1, z: 1};
            transformControls.addEventListener('objectChange', function() {
                if (transformControls.mode === 'scale' && selectedScreen && allScreens[selectedScreen]) {
                    const screen = allScreens[selectedScreen];

                    if (scaleMode === 'uniform') {
                        // UNIFORM mode: proportional scaling
                        const avgScale = (screen.scale.x + screen.scale.y + screen.scale.z) / 3;
                        screen.scale.set(avgScale, avgScale, avgScale);
                    } else if (scaleMode === 'resize') {
                        // RESIZE mode: change geometry dimensions, not scale
                        const currentScale = {x: screen.scale.x, y: screen.scale.y, z: screen.scale.z};

                        // Detect which axis changed
                        const deltaX = currentScale.x / lastResizeScale.x;
                        const deltaY = currentScale.y / lastResizeScale.y;
                        const deltaZ = currentScale.z / lastResizeScale.z;

                        if (deltaX !== 1 || deltaY !== 1 || deltaZ !== 1) {
                            // PlaneGeometry (color surfaces)
                            if (screen.geometry && screen.geometry.type === 'PlaneGeometry') {
                                // Get current geometry dimensions
                                const currentWidth = screen.geometry.parameters.width;
                                const currentHeight = screen.geometry.parameters.height;

                                // Calculate new dimensions based on scale change
                                const newWidth = currentWidth * deltaX;
                                const newHeight = currentHeight * deltaY;

                                // Recreate geometry with new dimensions
                                screen.geometry.dispose();
                                screen.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionné: ${Math.round(newWidth)} x ${Math.round(newHeight)}`);
                            }
                            // Volumetric screens (Points or InstancedMesh)
                            else if (screen.userData.positions || (screen.geometry && screen.geometry.attributes.position)) {
                                // Get positions array
                                let positions;
                                if (screen.userData.positions) {
                                    positions = screen.userData.positions;
                                } else {
                                    positions = screen.geometry.attributes.position.array;
                                }

                                // Multiply all positions by delta (resize without affecting depth spread)
                                for (let i = 0; i < positions.length; i += 3) {
                                    positions[i] *= deltaX;     // X
                                    positions[i + 1] *= deltaY; // Y
                                    positions[i + 2] *= deltaZ; // Z (depth)
                                }

                                // Update geometry based on type
                                if (screen.isPoints) {
                                    // Points: update position attribute
                                    screen.geometry.attributes.position.needsUpdate = true;
                                    screen.geometry.computeBoundingSphere();
                                } else if (screen.isInstancedMesh) {
                                    // InstancedMesh: update instance matrices
                                    const count = screen.count;
                                    for (let i = 0; i < count; i++) {
                                        reusableMatrix.setPosition(
                                            positions[i * 3],
                                            positions[i * 3 + 1],
                                            positions[i * 3 + 2]
                                        );
                                        screen.setMatrixAt(i, reusableMatrix);
                                    }
                                    screen.instanceMatrix.needsUpdate = true;
                                }

                                // Reset scale to 1 (geometry changed, not scale)
                                screen.scale.set(1, 1, 1);
                                lastResizeScale = {x: 1, y: 1, z: 1};

                                console.log(`Redimensionné (volumétrique): x${deltaX.toFixed(2)}, y${deltaY.toFixed(2)}, z${deltaZ.toFixed(2)}`);
                            }
                        }
                    }
                    // FREE mode: do nothing, allow non-uniform scaling
                }
            });

            // Free camera mouse controls (LEFT CLICK + drag)
            let isLeftMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.button === 0) { // Left click
                    isLeftMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', function(e) {
                if (e.button === 0) {
                    isLeftMouseDown = false;
                }
            });

            renderer.domElement.addEventListener('mousemove', function(e) {
                // PointerLock mode (FPS-style) - ONLY in Spectator mode
                if (isMouseLocked && freeCameraEnabled && fpsMode) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                }
                // Click+drag mode (Admin mode or fallback)
                else if (isLeftMouseDown && freeCameraEnabled && !selectedScreen) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    cameraYaw -= deltaX * fpsSettings.fpsMouseSensitivity;
                    cameraPitch -= deltaY * fpsSettings.fpsMouseSensitivity;

                    // Clamp pitch to avoid flipping
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            // PointerLock API setup for FPS-style controls (only in FPS mode)
            renderer.domElement.addEventListener('click', function() {
                if (!selectedScreen && freeCameraEnabled && fpsMode) {
                    renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                             renderer.domElement.mozRequestPointerLock ||
                                                             renderer.domElement.webkitRequestPointerLock;
                    renderer.domElement.requestPointerLock();
                }
            });

            // PointerLock change event
            document.addEventListener('pointerlockchange', lockChangeCallback, false);
            document.addEventListener('mozpointerlockchange', lockChangeCallback, false);
            document.addEventListener('webkitpointerlockchange', lockChangeCallback, false);

            function lockChangeCallback() {
                if (document.pointerLockElement === renderer.domElement ||
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    isMouseLocked = true;
                    console.log('🔒 PointerLock activé (ESC pour quitter)');
                } else {
                    isMouseLocked = false;
                    console.log('🔓 PointerLock désactivé');

                    // CRITICAL FIX: When pointer lock is released in Spectator mode, show pause screen
                    // This ensures ESC directly shows pause screen instead of requiring two presses
                    if (fpsMode && !isPaused) {
                        console.log('▶️ ESC détecté: Affichage du mode pause');
                        showPauseScreen();
                    }
                }
            }

            // Mouse wheel movement
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();

                const scrollSpeed = fpsSettings.fpsScrollSpeed; // Vitesse configurable
                const delta = e.deltaY > 0 ? 1 : -1;

                // OPTIMIZED: Reuse global Vector3
                camera.getWorldDirection(reusableForward);

                if (fpsMode) {
                    // MODE FPS: Sauvegarder Y pour bloquer mouvement vertical
                    const savedY = camera.position.y;

                    // Déplacement horizontal uniquement (X et Z)
                    reusableForward.y = 0;
                    reusableForward.normalize();

                    reusablePrevPosition.copy(camera.position);

                    // Appliquer mouvement horizontal
                    camera.position.addScaledVector(reusableForward, -delta * scrollSpeed);

                    // CRITIQUE: Restaurer Y pour BLOQUER axe vertical
                    camera.position.y = savedY;

                    // Vérifier collisions
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                    }
                } else {
                    // Mode normal: zoom libre (tous axes)
                    camera.position.addScaledVector(reusableForward, -delta * scrollSpeed);
                }
            });

            // Setup parameter controls
            setupSliderListeners();
            setupValueEditing();
            setupArrowButtons();

            // Display controls in console
            console.log('═══════════════════════════════════════════════════════');
            console.log('🏛️  SIMULATION MUSÉE - CONTRÔLES');
            console.log('═══════════════════════════════════════════════════════');
            console.log('');
            console.log('🔄 BASCULER ENTRE MODES:');
            console.log('   B            - Basculer MODE FPS ↔ MODE NORMAL');
            console.log('   N            - Afficher/Cacher interfaces (cachées par défaut)');
            console.log('   F            - Afficher/Cacher FPS Settings (bas gauche)');
            console.log('   Ctrl+S       - Exporter paramètres FPS dans console');
            console.log('');
            console.log('📍 MODE NORMAL (par défaut - ADMIN):');
            console.log('   Flèches/WASD - Déplacement horizontal');
            console.log('   O/L          - Monter/Descendre librement');
            console.log('   Clic gauche  - Rotation caméra');
            console.log('   Molette      - Zoom');
            console.log('');
            console.log('🎮 MODE FPS (touche B - SPECTATEUR):');
            console.log('   WASD/Flèches - Se déplacer');
            console.log('   Shift        - Sprint (x2.5)');
            console.log('   Clic canvas  - PointerLock (ESC pour quitter)');
            console.log('   Gravité      - Marche sur sols (écrans 3, 10, 11)');
            console.log('   Collisions   - Activées avec murs');
            console.log('   H            - Afficher/Masquer hitbox (debug)');
            console.log('');
            console.log('📍 Spawn: Centre forme 11, quelques unités au-dessus');
            console.log('🙈 Interfaces cachées - Appuyez sur N pour afficher');
            console.log('');
            console.log('🖱️ MODE NORMAL ACTIVÉ - Caméra libre');
            console.log('   Appuyez sur B pour activer le mode FPS/Spectateur');
            console.log('═══════════════════════════════════════════════════════');

            console.log('');
            console.log('🚀 Démarrage de la boucle d\'animation...');
            animate();

            // Initialize FPS counter DOM cache
            fpsDOMCache.counter = document.getElementById('fps-counter');
            fpsDOMCache.value = fpsDOMCache.counter.querySelector('.fps-value');

            console.log('═══════════════════════════════════════════════════════');
            console.log('✅ INIT() TERMINÉ AVEC SUCCÈS');
            console.log('═══════════════════════════════════════════════════════');
        }

        // Load video function
        function loadVideoFile(file) {
            if (!file || !file.type.startsWith('video/')) return;

            const videoElement = document.getElementById('video-source');
            const url = URL.createObjectURL(file);

            videoElement.src = url;
            videoElement.load();

            videoElement.onloadeddata = function() {
                const isFirstLoad = (currentVideo === null);
                currentVideo = videoElement;

                // Show preview
                document.getElementById('preview').innerHTML = '<video src="' + url + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                document.getElementById('preview').classList.add('loaded');
                document.getElementById('preview').querySelector('video').play();

                // Show controls
                document.getElementById('video-controls').classList.remove('hidden');

                // Reset sliders to default ONLY on first load
                if (isFirstLoad) {
                    document.getElementById('size').value = 0.39;
                    document.getElementById('density').value = 13;
                    document.getElementById('depth').value = 0.1;
                    document.getElementById('breath').value = 0.0;
                    document.getElementById('brightness').value = 1.1;
                    document.getElementById('glow').value = 0.0;
                    document.getElementById('contrast').value = 1.8;
                    document.getElementById('saturation').value = 0.70;

                    updateValueDisplay('size');
                    updateValueDisplay('density');
                    updateValueDisplay('depth');
                    updateValueDisplay('breath');
                    updateValueDisplay('brightness');
                    updateValueDisplay('glow');
                    updateValueDisplay('contrast');
                    updateValueDisplay('saturation');

                    // Keep both load-section and controls visible
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('ui').classList.add('loaded');
                    // Interfaces visibility managed by mode system (Spectator/Admin)
                }

                // Auto-play
                videoElement.play();

                // Apply automatiquement (générer les particules)
                console.log('🎬 Apply automatique après chargement vidéo...');
                generate(videoElement); // updateScreenList() is called at the end of this function

                // Double-check: réappliquer après un court délai pour être sûr
                setTimeout(() => {
                    console.log('🎬 Apply automatique (2ème passe)...');
                    generate(videoElement);
                }, 100);

                // Update timeline duration when metadata is loaded
                videoElement.addEventListener('loadedmetadata', function() {
                    updateTimeline();
                });

                // Update timeline as video plays
                videoElement.addEventListener('timeupdate', updateTimeline);
            };
        }

        // File input change
        document.getElementById('file-input').onchange = function(e) {
            loadVideoFile(e.target.files[0]);
        };

        // Drag & drop on preview area
        const preview = document.getElementById('preview');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.5)';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            preview.addEventListener(eventName, function() {
                preview.style.borderColor = 'rgba(255,255,255,0.1)';
            });
        });

        preview.addEventListener('drop', function(e) {
            const file = e.dataTransfer.files[0];
            loadVideoFile(file);
        });

        // Global drag & drop on entire page
        ['dragenter', 'dragover'].forEach(eventName => {
            document.body.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.body.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideoFile(file);
            }
        });

        /**
         * Calcule les paramètres de densité adaptatifs (step + résolution dynamique)
         * Density 1-15 : Comportement classique (step variable, résolution fixe 800x450)
         * Density 16-30 : Résolution progressive + step=1 pour plus de détails
         */
        function calculateDensityParams(density) {
            let step, TARGET_WIDTH, TARGET_HEIGHT;

            if (density <= 15) {
                // Mode classique (backward compatible)
                step = Math.max(1, Math.floor(10 / density));
                TARGET_WIDTH = 800;
                TARGET_HEIGHT = 450;
            } else {
                // Mode haute densité : augmentation progressive de la résolution
                step = 1; // Step fixé à 1
                const resolutionMultiplier = 1 + ((density - 15) / 30); // 1.0 à 1.5x
                TARGET_WIDTH = Math.floor(800 * resolutionMultiplier);
                TARGET_HEIGHT = Math.floor(450 * resolutionMultiplier);
            }

            return { step, TARGET_WIDTH, TARGET_HEIGHT };
        }

        // Helper function: Extract particle data from video for multi-video system
        function createParticleDataFromVideo(video) {
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create or reuse sampling canvas
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // Cover behavior: scale video to fill canvas
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9;

            let sourceWidth, sourceHeight, offsetX, offsetY;
            if (videoAspect > targetAspect) {
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw frame and get pixel data
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            const positions = [];
            const colors = [];
            const initialZ = [];
            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;
            const rgbToLumFactor = 1 / (3 * 255);

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Create particles with safety cap
            let particleCount = 0;
            outerLoopMulti: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];
                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);
                        if (hideBlack && maxColor < blackThreshold) continue;
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) continue;
                        }

                        // Safety cap: prevent performance issues
                        if (particleCount >= MAX_PARTICLES) {
                            console.warn(`⚠️ Multi-video: Cap MAX_PARTICLES atteint (${MAX_PARTICLES.toLocaleString()})`);
                            break outerLoopMulti;
                        }

                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        particleCount++;

                        let rNorm = r * 0.00392156862745098;
                        let gNorm = g * 0.00392156862745098;
                        let bNorm = b * 0.00392156862745098;

                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            // Apply depth culling if enabled
            if (enableDepthCull && depthCullPower > 0) {
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }
                const zRange = maxZ - minZ;
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;
                    for (let i = 0; i < initialZ.length; i++) {
                        if (initialZ[i] < cullThreshold) {
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            return { positions, colors, initialZ, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor };
        }

        function generate(video) {
            console.log('═══════════════════════════════════════════════════════');
            console.log('🎬 GENERATE() APPELÉ');
            console.log('═══════════════════════════════════════════════════════');
            console.log('📦 allScreens avant:', Object.keys(allScreens || {}));
            console.log('🎥 Vidéo:', video ? `${video.videoWidth}x${video.videoHeight}` : 'null');

            // Multi-video system: prefer screen-specific video if available
            if (screenVideos[1]) {
                console.log('🎬 Multi-video mode: Utilisation de video_01.mp4 pour génération');
                video = screenVideos[1];
            }

            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded in generate()!');
                alert('THREE.js not loaded.');
                return;
            }
            console.log('✅ THREE.js disponible');

            console.log('⚙️ Lecture des paramètres des sliders...');
            // Read parameters from sliders
            pointSize = parseFloat(document.getElementById('size').value);
            particleDensity = parseInt(document.getElementById('density').value);
            depthMultiplier = parseFloat(document.getElementById('depth').value); // Plage ajustée 0-0.2 pour plus de précision
            depthSmoothing = parseFloat(document.getElementById('smoothing').value); // Seuil atténuation micro-mouvements
            breathSpeed = parseFloat(document.getElementById('breath').value);
            brightness = parseFloat(document.getElementById('brightness').value);
            glowIntensity = parseFloat(document.getElementById('glow').value);
            flowIntensity = parseFloat(document.getElementById('flow').value);

            // New v1.3.1 parameters
            depthCullPower = parseFloat(document.getElementById('depthCullPower').value);
            contrast = parseFloat(document.getElementById('contrast').value);
            saturation = parseFloat(document.getElementById('saturation').value);

            // Normalize video to fixed size for consistent volume (16:9 aspect ratio)
            // Adaptive density system: resolution increases with density > 15
            const { step, TARGET_WIDTH, TARGET_HEIGHT } = calculateDensityParams(particleDensity);

            // Create or reuse sampling canvas for continuous video updates
            if (!videoSamplingCanvas) {
                videoSamplingCanvas = document.createElement('canvas');
                videoSamplingCanvas.width = TARGET_WIDTH;
                videoSamplingCanvas.height = TARGET_HEIGHT;
                // Optimization: willReadFrequently flag for better getImageData() performance
                videoSamplingCtx = videoSamplingCanvas.getContext('2d', { willReadFrequently: true });
            } else {
                // Update canvas size if density changed (for density > 15)
                if (videoSamplingCanvas.width !== TARGET_WIDTH || videoSamplingCanvas.height !== TARGET_HEIGHT) {
                    videoSamplingCanvas.width = TARGET_WIDTH;
                    videoSamplingCanvas.height = TARGET_HEIGHT;
                }
            }

            const canvas = videoSamplingCanvas;
            const ctx = videoSamplingCtx;

            // Store sampling data for continuous updates
            videoSamplingData = {
                step: step,
                TARGET_WIDTH: TARGET_WIDTH,
                TARGET_HEIGHT: TARGET_HEIGHT,
                scaleFactor: 0.5,
                halfWidth: TARGET_WIDTH / 2,
                halfHeight: TARGET_HEIGHT / 2,
                depthMultiplier: depthMultiplier
            };

            // Cover behavior: scale video to fill canvas without stretching (16:9)
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            // Draw current frame to sample pixels
            ctx.drawImage(video, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            const imageData = ctx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Create particle for each pixel (1 pixel = 1 particle)
            const positions = [];
            const colors = [];
            const initialZ = [];

            const scaleFactor = 0.5;
            const halfWidth = TARGET_WIDTH / 2;
            const halfHeight = TARGET_HEIGHT / 2;

            // Depth spread based on height (smaller dimension for 16:9)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            // Optimization: Pre-calculate constants outside loops
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance to anchor the depth at z=0
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // Calculate luminance
                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            console.log('🔍 Analyse de création des particules:');
            console.log(`   🎚️ DENSITÉ demandée: ${particleDensity}X`);
            console.log(`   📏 step: ${step}, TARGET: ${TARGET_WIDTH}x${TARGET_HEIGHT}`);
            console.log(`   🔢 Pixels à scanner: ~${Math.floor((TARGET_WIDTH / step) * (TARGET_HEIGHT / step))}`);
            console.log(`   🛡️ Cap MAX_PARTICLES: ${MAX_PARTICLES.toLocaleString()}`);
            console.log(`   🎨 hideBlack: ${hideBlack}, blackThreshold: ${blackThreshold}`);
            console.log(`   🖼️ hideBackground: ${hideBackground}, bgThreshold: ${bgThreshold || 'N/A'}`);
            console.log(`   💡 minLuminance trouvée: ${minLuminance.toFixed(3)}`);

            let totalPixelsScanned = 0;
            let pixelsWithAlpha = 0;
            let pixelsFilteredByBlack = 0;
            let pixelsFilteredByBackground = 0;
            let pixelsAdded = 0;
            let capReached = false;

            // SECOND PASS: Create particles with depth anchored to minimum luminance
            outerLoop: for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    totalPixelsScanned++;
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    // Only create particle if pixel is visible
                    if (alpha > 30) {
                        pixelsWithAlpha++;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip black particles if hideBlack is enabled
                        if (hideBlack && maxColor < blackThreshold) {
                            pixelsFilteredByBlack++;
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                pixelsFilteredByBackground++;
                                continue; // Skip this particle, it's part of the background
                            }
                        }

                        // Safety cap: prevent performance issues
                        if (pixelsAdded >= MAX_PARTICLES) {
                            capReached = true;
                            break outerLoop;
                        }

                        // Position (centered in 16:9 aspect ratio)
                        const px = (x - halfWidth) * scaleFactor;
                        const py = -(y - halfHeight) * scaleFactor;

                        // v1.3.1 — Luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;

                        positions.push(px, py, pz);
                        initialZ.push(pz);
                        pixelsAdded++;

                        // v1.3.1 — Apply contrast and saturation effects (Optimized)
                        let rNorm = r * 0.00392156862745098; // r / 255
                        let gNorm = g * 0.00392156862745098; // g / 255
                        let bNorm = b * 0.00392156862745098; // b / 255

                        // Apply contrast (0.5 = gray, 1.0 = normal, 2.0+ = high contrast)
                        if (useContrast) {
                            rNorm = (rNorm - 0.5) * contrast + 0.5;
                            gNorm = (gNorm - 0.5) * contrast + 0.5;
                            bNorm = (bNorm - 0.5) * contrast + 0.5;
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Apply saturation (0.0 = B&W, 1.0 = normal, 2.0 = oversaturated)
                        if (useSaturation) {
                            const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                            rNorm = gray + saturation * (rNorm - gray);
                            gNorm = gray + saturation * (gNorm - gray);
                            bNorm = gray + saturation * (bNorm - gray);
                            rNorm = Math.max(0, Math.min(1, rNorm));
                            gNorm = Math.max(0, Math.min(1, gNorm));
                            bNorm = Math.max(0, Math.min(1, bNorm));
                        }

                        // Color with brightness boost
                        colors.push(
                            Math.min(1.0, rNorm * brightness),
                            Math.min(1.0, gNorm * brightness),
                            Math.min(1.0, bNorm * brightness)
                        );
                    }
                }
            }

            console.log('📊 Résultats de la génération:');
            console.log(`   📏 Pixels scannés: ${totalPixelsScanned}`);
            console.log(`   ✅ Pixels avec alpha > 30: ${pixelsWithAlpha}`);
            console.log(`   ⚫ Filtrés par hideBlack: ${pixelsFilteredByBlack}`);
            console.log(`   🖼️ Filtrés par hideBackground: ${pixelsFilteredByBackground}`);
            console.log(`   ✨ Particules AJOUTÉES: ${pixelsAdded.toLocaleString()}`);
            console.log(`   📦 positions.length: ${positions.length} (${(positions.length / 3).toLocaleString()} particules)`);
            if (capReached) {
                console.warn(`   ⚠️ CAP ATTEINT! Limite MAX_PARTICLES (${MAX_PARTICLES.toLocaleString()}) appliquée pour éviter lag.`);
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < initialZ.length; i++) {
                    minZ = Math.min(minZ, initialZ[i]);
                    maxZ = Math.max(maxZ, initialZ[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < initialZ.length; i++) {
                        const z = initialZ[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            colors[i * 3] = 0;
                            colors[i * 3 + 1] = 0;
                            colors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            if (particles) {
                screensGroup.remove(particles);
                if (particles.geometry) particles.geometry.dispose();
                if (particles.material) {
                    if (videoTexture) videoTexture.dispose();
                    particles.material.dispose();
                }
            }

            // CRITICAL: Preserve custom shapes (>21) before clearing
            const customShapesToPreserve = {};
            if (allScreens) {
                Object.keys(allScreens).forEach(key => {
                    const num = parseInt(key);
                    if (num > 21) {
                        customShapesToPreserve[num] = allScreens[num];
                        // Remove from screensGroup temporarily to avoid disposal
                        if (allScreens[num].parent === screensGroup) {
                            screensGroup.remove(allScreens[num]);
                        }
                    }
                });
            }
            console.log('💾 Formes personnalisées préservées (>21):', Object.keys(customShapesToPreserve));

            // CRITICAL: Detach transform controls before clearing to avoid "object must be part of scene graph" error
            const wasScreenSelected = selectedScreen;
            if (transformControls && selectedScreen) {
                transformControls.detach();
            }

            console.log('🧹 Nettoyage du groupe d\'écrans...');
            // Clear group before adding new screens (only default screens 1-7 now)
            screensGroup.clear();
            console.log('✅ Groupe nettoyé');

            console.log(`🎨 Mode de rendu: ${is3DMode ? '3D (InstancedMesh)' : '2D (Points)'}`);
            console.log(`📊 Nombre de particules: ${positions.length / 3}`);

            if (is3DMode) {
                console.log('🔷 Création des particules en mode 3D...');
                // 3D Mode: Use InstancedMesh with real 3D geometries
                const count = positions.length / 3;
                console.log(`   Count: ${count}`);
                let baseGeometry;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    flatShading: true,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0xffffff, // Couleur émissive = blanc pour prendre la couleur des particules
                    emissiveIntensity: glowIntensity // Intensité contrôlée par le slider
                });

                particles = new THREE.InstancedMesh(baseGeometry, material, count);
                particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                console.log('✅ InstancedMesh créé:', particles);

                const instanceColors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    instanceColors[i * 3] = colors[i * 3];
                    instanceColors[i * 3 + 1] = colors[i * 3 + 1];
                    instanceColors[i * 3 + 2] = colors[i * 3 + 2];
                }
                particles.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);

                // Optimization: reuse matrix and color objects
                for (let i = 0; i < count; i++) {
                    reusableMatrix.setPosition(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    particles.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    particles.setColorAt(i, reusableColor);
                }

                particles.instanceMatrix.needsUpdate = true;

                particles.userData.initialZ = initialZ;
                particles.userData.positions = positions;
                particles.userData.is3D = true;

            } else {
                // 2D Mode: Use Points with VIDEO texture
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('initialZ', new THREE.Float32BufferAttribute(initialZ, 1));

                // Create video texture
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const shapeTexture = getShapeTexture(currentShape);

                console.log('🔸 Création des particules en mode 2D...');
                material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    map: shapeTexture
                });

                particles = new THREE.Points(geometry, material);
                console.log('✅ Points créés:', particles);
            }

            // Volumétrie unilatérale : les particules sombres restent à z=0 (point fixe)
            // Seules les particules lumineuses sortent vers z positif
            // Position fixe des écrans : z=0 invariant au DEPTH SPREAD

            // Écran 1 - Position de base
            particles.position.set(0, 0, 0);
            particles.rotation.set(0, 0, 0);

            // Add first screen to group
            console.log('➕ Ajout des particules au screensGroup...');
            screensGroup.add(particles);
            console.log('✅ Particules ajoutées au groupe');

            // Calculate screen dimensions from 16:9 grid (invariant to depth spread)
            const screenW = TARGET_WIDTH * scaleFactor;
            const screenH = TARGET_HEIGHT * scaleFactor;
            const wallBottomY = -screenH / 2;

            // === ÉCRAN 2: Generate from video_02.mp4 if available (multi-video system) ===
            let particlesRight;
            if (screenVideos[2] && screenVideos[2] !== video) {
                console.log('🎬 Génération écran 2 depuis video_02.mp4');
                const screen2Data = createParticleDataFromVideo(screenVideos[2]);

                if (is3DMode) {
                    const count2 = screen2Data.positions.length / 3;
                    let baseGeometry2;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry2 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry2 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry2 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry2 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    particlesRight = new THREE.InstancedMesh(baseGeometry2, material, count2);
                    particlesRight.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors2 = new Float32Array(count2 * 3);
                    for (let i = 0; i < count2; i++) {
                        instanceColors2[i * 3] = screen2Data.colors[i * 3];
                        instanceColors2[i * 3 + 1] = screen2Data.colors[i * 3 + 1];
                        instanceColors2[i * 3 + 2] = screen2Data.colors[i * 3 + 2];
                    }
                    particlesRight.instanceColor = new THREE.InstancedBufferAttribute(instanceColors2, 3);

                    for (let i = 0; i < count2; i++) {
                        reusableMatrix.setPosition(
                            screen2Data.positions[i * 3],
                            screen2Data.positions[i * 3 + 1],
                            screen2Data.positions[i * 3 + 2]
                        );
                        particlesRight.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen2Data.colors[i * 3], screen2Data.colors[i * 3 + 1], screen2Data.colors[i * 3 + 2]);
                        particlesRight.setColorAt(i, reusableColor);
                    }

                    particlesRight.instanceMatrix.needsUpdate = true;
                    particlesRight.userData.initialZ = screen2Data.initialZ;
                    particlesRight.userData.positions = screen2Data.positions;
                    particlesRight.userData.is3D = true;
                } else {
                    const geometry2 = new THREE.BufferGeometry();
                    geometry2.setAttribute('position', new THREE.Float32BufferAttribute(screen2Data.positions, 3));
                    geometry2.setAttribute('color', new THREE.Float32BufferAttribute(screen2Data.colors, 3));
                    geometry2.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen2Data.initialZ, 1));

                    particlesRight = new THREE.Points(geometry2, material);
                }
            } else {
                // Fallback: Clone screen 1 if video_02.mp4 not available
                console.log('🎬 Écran 2: Clonage de l\'écran 1 (video_02.mp4 non disponible)');
                particlesRight = particles.clone();
                particlesRight.geometry = particles.geometry;
                particlesRight.material = particles.material;
            }

            // Écran 2 - Position de base
            particlesRight.position.set(400, 0, 0);
            particlesRight.rotation.set(0, 0, 0);

            // Add second screen to group
            screensGroup.add(particlesRight);

            // === ÉCRAN 3: SOL RECTANGLE (surface doublée sans scale) ===
            // Créer une géométrie rectangulaire : largeur complète, hauteur réduite de moitié
            // Positions multipliées x2 : largeur finale = 800, hauteur = 225, surface doublée
            const screen3Positions = [];
            const screen3Colors = [];
            const screen3InitialZ = [];

            // Dimensions du rectangle : Largeur complète (toutes les particules), hauteur réduite de moitié
            const halfH = screenH / 2; // Demi-hauteur pour centrage (112.5)
            const halfH_screen3 = halfH / 2; // Hauteur réduite pour écran 3 (56.25)

            // Filtrer les particules : TOUTES en largeur (pas de filtre sur X), hauteur réduite de moitié
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];

                // Rectangle : TOUTE la largeur (pas de condition sur X), hauteur réduite de moitié
                if (y >= -halfH_screen3 && y <= halfH_screen3) {
                    // Multiplier X et Y par 2 pour surface doublée SANS scale (évite distorsion depth)
                    screen3Positions.push(x * 2, y * 2, z);
                    screen3Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    screen3InitialZ.push(initialZ[i]);
                }
            }

            let screen3;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du rectangle
                const count3 = screen3Positions.length / 3;
                let baseGeometry3;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry3 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry3 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry3 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry3 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen3 = new THREE.InstancedMesh(baseGeometry3, material, count3);
                screen3.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors3 = new Float32Array(count3 * 3);
                for (let i = 0; i < count3; i++) {
                    instanceColors3[i * 3] = screen3Colors[i * 3];
                    instanceColors3[i * 3 + 1] = screen3Colors[i * 3 + 1];
                    instanceColors3[i * 3 + 2] = screen3Colors[i * 3 + 2];
                }
                screen3.instanceColor = new THREE.InstancedBufferAttribute(instanceColors3, 3);

                for (let i = 0; i < count3; i++) {
                    reusableMatrix.setPosition(
                        screen3Positions[i * 3],
                        screen3Positions[i * 3 + 1],
                        screen3Positions[i * 3 + 2]
                    );
                    screen3.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen3Colors[i * 3], screen3Colors[i * 3 + 1], screen3Colors[i * 3 + 2]);
                    screen3.setColorAt(i, reusableColor);
                }

                screen3.instanceMatrix.needsUpdate = true;
                screen3.userData.initialZ = screen3InitialZ;
                screen3.userData.positions = screen3Positions;
                screen3.userData.is3D = true;
                screen3.userData.screenNumber = 5; // Renuméroté: était 3 → 5

            } else {
                // Mode 2D : créer Points avec les particules du rectangle
                const geometry3 = new THREE.BufferGeometry();
                geometry3.setAttribute('position', new THREE.Float32BufferAttribute(screen3Positions, 3));
                geometry3.setAttribute('color', new THREE.Float32BufferAttribute(screen3Colors, 3));
                geometry3.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen3InitialZ, 1));

                screen3 = new THREE.Points(geometry3, material);
                screen3.userData.screenNumber = 5; // Renuméroté: était 3 → 5
            }

            // Position et orientation de base
            screen3.position.set(200.858, -112.500, 112.500);
            screen3.rotation.set(1.570796, 0.000000, 0.000000); // 90° sur X
            screen3.scale.set(1, 1, 1); // Pas de scale (positions déjà multipliées x2)

            screensGroup.add(screen3);

            // --- Opposite wall (in front of right wall), hinged to the floor end ---

            // === ÉCRAN 5: Generate from video_05.mp4 if available ===
            let wallOppA;
            if (screenVideos[5]) {
                console.log('🎬 Génération écran 5 depuis video_05.mp4');
                const screen5Data = createParticleDataFromVideo(screenVideos[5]);

                if (is3DMode) {
                    const count5 = screen5Data.positions.length / 3;
                    let baseGeometry5;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry5 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry5 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry5 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry5 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppA = new THREE.InstancedMesh(baseGeometry5, material, count5);
                    wallOppA.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors5 = new Float32Array(count5 * 3);
                    for (let i = 0; i < count5; i++) {
                        instanceColors5[i * 3] = screen5Data.colors[i * 3];
                        instanceColors5[i * 3 + 1] = screen5Data.colors[i * 3 + 1];
                        instanceColors5[i * 3 + 2] = screen5Data.colors[i * 3 + 2];
                    }
                    wallOppA.instanceColor = new THREE.InstancedBufferAttribute(instanceColors5, 3);

                    for (let i = 0; i < count5; i++) {
                        reusableMatrix.setPosition(
                            screen5Data.positions[i * 3],
                            screen5Data.positions[i * 3 + 1],
                            screen5Data.positions[i * 3 + 2]
                        );
                        wallOppA.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen5Data.colors[i * 3], screen5Data.colors[i * 3 + 1], screen5Data.colors[i * 3 + 2]);
                        wallOppA.setColorAt(i, reusableColor);
                    }

                    wallOppA.instanceMatrix.needsUpdate = true;
                    wallOppA.userData.initialZ = screen5Data.initialZ;
                    wallOppA.userData.positions = screen5Data.positions;
                    wallOppA.userData.is3D = true;
                    wallOppA.userData.screenNumber = 6; // Renuméroté: anciennement 4 → 6
                } else {
                    const geometry5 = new THREE.BufferGeometry();
                    geometry5.setAttribute('position', new THREE.Float32BufferAttribute(screen5Data.positions, 3));
                    geometry5.setAttribute('color', new THREE.Float32BufferAttribute(screen5Data.colors, 3));
                    geometry5.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen5Data.initialZ, 1));

                    wallOppA = new THREE.Points(geometry5, material);
                }
            } else {
                // Fallback: Clone screen 1
                console.log('🎬 Écran 5: Clonage de l\'écran 1 (video_05.mp4 non disponible)');
                wallOppA = particles.clone();
                wallOppA.geometry = particles.geometry;
                wallOppA.material = particles.material;
            }

            // Écran 5 - Position de base
            wallOppA.position.set(0, 0, 225);
            wallOppA.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppA.userData.screenNumber) wallOppA.userData.screenNumber = 6; // Renuméroté: anciennement 4 → 6

            screensGroup.add(wallOppA);

            // === ÉCRAN 6: Generate from video_06.mp4 if available ===
            let wallOppB;
            if (screenVideos[6]) {
                console.log('🎬 Génération écran 6 depuis video_06.mp4');
                const screen6Data = createParticleDataFromVideo(screenVideos[6]);

                if (is3DMode) {
                    const count6 = screen6Data.positions.length / 3;
                    let baseGeometry6;
                    const size = pointSize * 3;

                    switch(currentShape) {
                        case 'square':
                            baseGeometry6 = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'circle':
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                            break;
                        case 'diamond':
                            baseGeometry6 = new THREE.OctahedronGeometry(size * 0.5);
                            break;
                        case 'star':
                            baseGeometry6 = new THREE.TetrahedronGeometry(size * 0.6);
                            break;
                        default:
                            baseGeometry6 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                    }

                    wallOppB = new THREE.InstancedMesh(baseGeometry6, material, count6);
                    wallOppB.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    const instanceColors6 = new Float32Array(count6 * 3);
                    for (let i = 0; i < count6; i++) {
                        instanceColors6[i * 3] = screen6Data.colors[i * 3];
                        instanceColors6[i * 3 + 1] = screen6Data.colors[i * 3 + 1];
                        instanceColors6[i * 3 + 2] = screen6Data.colors[i * 3 + 2];
                    }
                    wallOppB.instanceColor = new THREE.InstancedBufferAttribute(instanceColors6, 3);

                    for (let i = 0; i < count6; i++) {
                        reusableMatrix.setPosition(
                            screen6Data.positions[i * 3],
                            screen6Data.positions[i * 3 + 1],
                            screen6Data.positions[i * 3 + 2]
                        );
                        wallOppB.setMatrixAt(i, reusableMatrix);
                        reusableColor.setRGB(screen6Data.colors[i * 3], screen6Data.colors[i * 3 + 1], screen6Data.colors[i * 3 + 2]);
                        wallOppB.setColorAt(i, reusableColor);
                    }

                    wallOppB.instanceMatrix.needsUpdate = true;
                    wallOppB.userData.initialZ = screen6Data.initialZ;
                    wallOppB.userData.positions = screen6Data.positions;
                    wallOppB.userData.is3D = true;
                    wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4
                } else {
                    const geometry6 = new THREE.BufferGeometry();
                    geometry6.setAttribute('position', new THREE.Float32BufferAttribute(screen6Data.positions, 3));
                    geometry6.setAttribute('color', new THREE.Float32BufferAttribute(screen6Data.colors, 3));
                    geometry6.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen6Data.initialZ, 1));

                    wallOppB = new THREE.Points(geometry6, material);
                }
            } else {
                // Fallback: Clone screen 2
                console.log('🎬 Écran 6: Clonage de l\'écran 2 (video_06.mp4 non disponible)');
                wallOppB = particlesRight.clone();
                wallOppB.geometry = particles.geometry;
                wallOppB.material = particles.material;
            }

            // Écran 6 - Position de base
            wallOppB.position.set(400, 0, 225);
            wallOppB.rotation.set(-Math.PI, 0, -Math.PI); // Rotation 180° pour faire face vers -Z
            if (!wallOppB.userData.screenNumber) wallOppB.userData.screenNumber = 4; // Renuméroté: anciennement 5 → 4

            screensGroup.add(wallOppB);

            // === ÉCRAN 7: panneau latéral CARRÉ - Generate from video_07.mp4 if available ===
            let screen7Positions, screen7Colors, screen7InitialZ;
            let useVideo7 = false;

            if (screenVideos[7]) {
                // Use video_07.mp4
                console.log('🎬 Génération écran 7 depuis video_07.mp4');
                const screen7Data = createParticleDataFromVideo(screenVideos[7]);
                screen7Positions = screen7Data.positions;
                screen7Colors = screen7Data.colors;
                screen7InitialZ = screen7Data.initialZ;
                useVideo7 = true;
            } else {
                // Fallback: Filter from screen 1 video to create square
                console.log('🎬 Écran 7: Filtrage depuis l\'écran 1 (video_07.mp4 non disponible)');
                screen7Positions = [];
                screen7Colors = [];
                screen7InitialZ = [];

                // Réutilise halfH déjà déclaré pour l'écran 3 (screenH / 2 = 112.5)
                // Filtrer les particules pour faire un carré : X et Y entre -halfH et +halfH
                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];

                    // Carré centré : -112.5 <= X <= 112.5 ET -112.5 <= Y <= 112.5
                    if (x >= -halfH && x <= halfH && y >= -halfH && y <= halfH) {
                        screen7Positions.push(x, y, z);
                        screen7Colors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                        screen7InitialZ.push(initialZ[i]);
                    }
                }
            }

            let screen7;
            if (is3DMode) {
                // Mode 3D : créer InstancedMesh avec les particules du carré
                const count7 = screen7Positions.length / 3;
                let baseGeometry7;
                const size = pointSize * 3;

                switch(currentShape) {
                    case 'square':
                        baseGeometry7 = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'circle':
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                        break;
                    case 'diamond':
                        baseGeometry7 = new THREE.OctahedronGeometry(size * 0.5);
                        break;
                    case 'star':
                        baseGeometry7 = new THREE.TetrahedronGeometry(size * 0.6);
                        break;
                    default:
                        baseGeometry7 = new THREE.SphereGeometry(size * 0.5, 8, 6);
                }

                screen7 = new THREE.InstancedMesh(baseGeometry7, material, count7);
                screen7.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const instanceColors7 = new Float32Array(count7 * 3);
                for (let i = 0; i < count7; i++) {
                    instanceColors7[i * 3] = screen7Colors[i * 3];
                    instanceColors7[i * 3 + 1] = screen7Colors[i * 3 + 1];
                    instanceColors7[i * 3 + 2] = screen7Colors[i * 3 + 2];
                }
                screen7.instanceColor = new THREE.InstancedBufferAttribute(instanceColors7, 3);

                for (let i = 0; i < count7; i++) {
                    reusableMatrix.setPosition(
                        screen7Positions[i * 3],
                        screen7Positions[i * 3 + 1],
                        screen7Positions[i * 3 + 2]
                    );
                    screen7.setMatrixAt(i, reusableMatrix);
                    reusableColor.setRGB(screen7Colors[i * 3], screen7Colors[i * 3 + 1], screen7Colors[i * 3 + 2]);
                    screen7.setColorAt(i, reusableColor);
                }

                screen7.instanceMatrix.needsUpdate = true;
                screen7.userData.initialZ = screen7InitialZ;
                screen7.userData.positions = screen7Positions;
                screen7.userData.is3D = true;
                screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            } else {
                // Mode 2D : créer Points avec les particules du carré
                const geometry7 = new THREE.BufferGeometry();
                geometry7.setAttribute('position', new THREE.Float32BufferAttribute(screen7Positions, 3));
                geometry7.setAttribute('color', new THREE.Float32BufferAttribute(screen7Colors, 3));
                geometry7.setAttribute('initialZ', new THREE.Float32BufferAttribute(screen7InitialZ, 1));

                screen7 = new THREE.Points(geometry7, material);
            }

            // Position et orientation de base (coordonnées ajustées par l'utilisateur)
            screen7.position.set(599.938, -0.064, 112.546);
            screen7.rotation.set(0, -1.570796, 0); // -90° en Y
            screen7.scale.set(1, 1, 1); // IMPORTANT: pas de scale, l'image garde sa taille normale
            if (!screen7.userData.screenNumber) screen7.userData.screenNumber = 3; // Renuméroté: anciennement 6 → 3

            screensGroup.add(screen7);

            // ======================
            // ============================================================
            // HELPER: Matériau avec shader subtil pour MURS-FORMES uniquement
            // (gradient + dithering - amélioration qualité visuelle)
            // ============================================================
            function createWallFormMaterial(baseColorHex, gradientStrength = 0.03) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        baseColor: { value: new THREE.Color(baseColorHex) },
                        gradientStrength: { value: gradientStrength }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 baseColor;
                        uniform float gradientStrength;
                        varying vec2 vUv;

                        // Dithering Bayer 4x4 ultra subtil
                        float bayerDither4x4(vec2 screenPos) {
                            int x = int(mod(screenPos.x, 4.0));
                            int y = int(mod(screenPos.y, 4.0));
                            int index = x + y * 4;
                            float bayer[16];
                            bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                            bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                            bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                            bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                            return bayer[index];
                        }

                        void main() {
                            // Gradient vertical subtil (du haut vers le bas)
                            float gradient = vUv.y * gradientStrength;

                            // Dithering ultra fin (opacité 0.006)
                            float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                            // Couleur finale
                            vec3 finalColor = baseColor + vec3(gradient + dither);
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    side: THREE.DoubleSide
                });
            }

            // SCREEN 4: Custom shape (color surface) - white panel
            // ======================
            const width4 = 964.573;
            const height4 = 228.534;
            const geometry4 = new THREE.PlaneGeometry(width4, height4);

            // CubeCamera pour capturer l'environnement en temps réel
            const cubeRenderTarget4 = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter
            });
            const cubeCamera4 = new THREE.CubeCamera(1, 10000, cubeRenderTarget4);

            const material4 = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,  // Noir profond pour mieux capter les reflets
                metalness: 0.3,   // Légèrement métallique
                roughness: 0.6,   // Surface mate (pas miroir)
                envMap: cubeRenderTarget4.texture,  // Texture de l'environnement capturé
                envMapIntensity: 2.5,  // Intensité des réflexions
                side: THREE.DoubleSide
            });
            const screen4 = new THREE.Mesh(geometry4, material4);

            // Position et orientation (from user JSON)
            screen4.position.set(132.131, 109.022, 112.031);
            screen4.rotation.set(1.570796, 0, 0); // 90° on X
            screen4.scale.set(1, 1, 1);

            // Positionner la CubeCamera à l'emplacement de l'écran
            cubeCamera4.position.copy(screen4.position);
            scene.add(cubeCamera4);

            // Mark as color surface
            screen4.userData.screenNumber = 7; // Renuméroté: 4 → 7
            screen4.userData.isColorSurface = true;
            screen4.userData.color = 0x000000;
            screen4.userData.cubeCamera = cubeCamera4;  // Référence pour la mise à jour

            screensGroup.add(screen4);

            // ======================
            // SCREEN 8: Custom shape (color surface) - beige/pink panel
            // ======================
            const width8 = 983.983;
            const height8 = 231.29;
            const geometry8 = new THREE.PlaneGeometry(width8, height8);
            const material8 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen8 = new THREE.Mesh(geometry8, material8);

            // Position et orientation (from user JSON)
            screen8.position.set(137.097, -6.589, -0.072);
            screen8.rotation.set(0, 0, 0);
            screen8.scale.set(1, 1, 1);

            // Mark as color surface
            screen8.userData.screenNumber = 8;
            screen8.userData.isColorSurface = true;
            screen8.userData.color = 0x000000;

            screensGroup.add(screen8);

            // ======================
            // SCREEN 9: Custom shape (color surface) - gray panel back
            // ======================
            const width9 = 983.983;
            const height9 = 231.29;
            const geometry9 = new THREE.PlaneGeometry(width9, height9);
            const material9 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen9 = new THREE.Mesh(geometry9, material9);
            screen9.position.set(137.097, -6.589, 226.306);
            screen9.rotation.set(0, 0, 0);
            screen9.scale.set(1, 1, 1);
            screen9.userData.screenNumber = 9;
            screen9.userData.isColorSurface = true;
            screen9.userData.color = 0x000000;
            screensGroup.add(screen9);

            // ======================
            // SCREEN 10: Custom shape (glassmorphisme) - transparent glass floor panel
            // ======================
            const width10 = 804.246;
            const height10 = 228.534;
            const geometry10 = new THREE.PlaneGeometry(width10, height10);
            const material10 = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: fpsSettings.glassMetalness,
                roughness: fpsSettings.glassRoughness,
                opacity: fpsSettings.glassOpacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 1.0
            });
            const screen10 = new THREE.Mesh(geometry10, material10);
            screen10.position.set(205.307, -111.773, 112.611);
            screen10.rotation.set(1.570796, 0, 0);
            screen10.scale.set(1, 1, 1);
            screen10.userData.screenNumber = 10;
            screen10.userData.isColorSurface = true;
            screen10.userData.isGlass = true; // Marquer comme verre
            screen10.userData.color = 0xaaaaaa;
            screen10.visible = true; // Écran 10 visible
            screen10.renderOrder = 1000; // Rendre après les objets opaques
            screensGroup.add(screen10);

            // ======================
            // SCREEN 11: Custom shape (color surface) - dark green small panel (sol avec ombre fake)
            // ======================
            const width11 = 155.945;
            const height11 = 228.534;
            const geometry11 = new THREE.PlaneGeometry(width11, height11);

            // Shader spécial pour sol avec ombre fake mur-sol (dégradé radial subtil)
            const material11 = new THREE.ShaderMaterial({
                uniforms: {
                    baseColor: { value: new THREE.Color(0x0A0A0A) },
                    gradientStrength: { value: 0.03 },
                    shadowStrength: { value: 0.025 } // 2.5% assombrissement aux bords
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float gradientStrength;
                    uniform float shadowStrength;
                    varying vec2 vUv;

                    float bayerDither4x4(vec2 screenPos) {
                        int x = int(mod(screenPos.x, 4.0));
                        int y = int(mod(screenPos.y, 4.0));
                        int index = x + y * 4;
                        float bayer[16];
                        bayer[0] = 0.0/16.0; bayer[1] = 8.0/16.0; bayer[2] = 2.0/16.0; bayer[3] = 10.0/16.0;
                        bayer[4] = 12.0/16.0; bayer[5] = 4.0/16.0; bayer[6] = 14.0/16.0; bayer[7] = 6.0/16.0;
                        bayer[8] = 3.0/16.0; bayer[9] = 11.0/16.0; bayer[10] = 1.0/16.0; bayer[11] = 9.0/16.0;
                        bayer[12] = 15.0/16.0; bayer[13] = 7.0/16.0; bayer[14] = 13.0/16.0; bayer[15] = 5.0/16.0;
                        return bayer[index];
                    }

                    void main() {
                        // Gradient vertical
                        float gradient = vUv.y * gradientStrength;

                        // Ombre fake mur-sol : dégradé radial depuis les bords
                        vec2 center = vec2(0.5, 0.5);
                        float distFromCenter = distance(vUv, center);
                        float shadow = smoothstep(0.3, 0.7, distFromCenter) * shadowStrength;

                        // Dithering
                        float dither = (bayerDither4x4(gl_FragCoord.xy) - 0.5) * 0.006;

                        // Couleur finale (assombrie aux bords)
                        vec3 finalColor = baseColor + vec3(gradient + dither) - vec3(shadow);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const screen11 = new THREE.Mesh(geometry11, material11);
            screen11.position.set(-274.876, -111.773, 112.79);
            screen11.rotation.set(1.570796, 0, 0);
            screen11.scale.set(1, 1, 1);
            screen11.userData.screenNumber = 11;
            screen11.userData.isColorSurface = true;
            screen11.userData.color = 0x0A0A0A;
            screensGroup.add(screen11);

            // ======================
            // SCREEN 12: Custom shape (color surface) - dark green vertical panel
            // ======================
            const width12 = 235.076;
            const height12 = 231.29;
            const geometry12 = new THREE.PlaneGeometry(width12, height12);
            const material12 = createWallFormMaterial(0x060606); // Shader subtil pour mur-forme
            const screen12 = new THREE.Mesh(geometry12, material12);
            screen12.position.set(-348.048, -6.589, 115.234);
            screen12.rotation.set(0, 1.570796, 0);
            screen12.scale.set(1, 1, 1);
            screen12.userData.screenNumber = 12;
            screen12.userData.isColorSurface = true;
            screen12.userData.color = 0x060606;
            screensGroup.add(screen12);

            // ======================
            // SCREEN 14: Custom shape (color surface) - dark green thin panel
            // ======================
            const width14 = 96.102;
            const height14 = 231.29;
            const geometry14 = new THREE.PlaneGeometry(width14, height14);
            const material14 = createWallFormMaterial(0x0A0A0A); // Shader subtil pour mur-forme
            const screen14 = new THREE.Mesh(geometry14, material14);
            screen14.position.set(-197.183, 3.851, 178.672);
            screen14.rotation.set(0, 1.570796, 0);
            screen14.scale.set(1, 1, 1);
            screen14.userData.screenNumber = 13; // Renuméroté: 14 → 13
            screen14.userData.isColorSurface = true;
            screen14.userData.color = 0x0A0A0A;
            screensGroup.add(screen14);

            // ======================
            // SCREEN 15: Custom shape (color surface) - dark green thin panel
            // ======================
            const width15 = 96.102;
            const height15 = 231.29;
            const geometry15 = new THREE.PlaneGeometry(width15, height15);
            const material15 = createWallFormMaterial(0x0A0A0A); // Shader subtil pour mur-forme
            const screen15 = new THREE.Mesh(geometry15, material15);
            screen15.position.set(-197.107, 3.769, 47.768);
            screen15.rotation.set(0, 1.570796, 0);
            screen15.scale.set(1, 1, 1);
            screen15.userData.screenNumber = 14; // Renuméroté: 15 → 14
            screen15.userData.isColorSurface = true;
            screen15.userData.color = 0x0A0A0A;
            screensGroup.add(screen15);

            // ======================
            // SCREEN 16: Custom shape (color surface) - dark green horizontal panel
            // ======================
            const width16 = 163.506;
            const height16 = 239.079;
            const geometry16 = new THREE.PlaneGeometry(width16, height16);
            const material16 = createWallFormMaterial(0x0A0A0A); // Shader subtil pour mur-forme
            const screen16 = new THREE.Mesh(geometry16, material16);
            screen16.position.set(-197.04, 27.158, 110.291);
            screen16.rotation.set(1.570796, 1.570796, 0);
            screen16.scale.set(1, 1, 1);
            screen16.userData.screenNumber = 15; // Renuméroté: 16 → 15
            screen16.userData.isColorSurface = true;
            screen16.userData.color = 0x0A0A0A;
            screensGroup.add(screen16);

            // ======================
            // SCREEN 17: Custom shape (color surface) - gray thin panel
            // ======================
            const width17 = 96.102;
            const height17 = 231.29;
            const geometry17 = new THREE.PlaneGeometry(width17, height17);
            const material17 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen17 = new THREE.Mesh(geometry17, material17);
            screen17.position.set(-200.877, -6.116, 47.768);
            screen17.rotation.set(0, 1.570796, 0);
            screen17.scale.set(1, 1, 1);
            screen17.userData.screenNumber = 16; // Renuméroté: 17 → 16
            screen17.userData.isColorSurface = true;
            screen17.userData.color = 0x000000;
            screensGroup.add(screen17);

            // ======================
            // SCREEN 18: Custom shape (color surface) - gray thin panel
            // ======================
            const width18 = 96.102;
            const height18 = 231.29;
            const geometry18 = new THREE.PlaneGeometry(width18, height18);
            const material18 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen18 = new THREE.Mesh(geometry18, material18);
            screen18.position.set(-200.734, -0.471, 178.493);
            screen18.rotation.set(0, 1.570796, 0);
            screen18.scale.set(1, 1, 1);
            screen18.userData.screenNumber = 17; // Renuméroté: 18 → 17
            screen18.userData.isColorSurface = true;
            screen18.userData.color = 0x000000;
            screensGroup.add(screen18);

            // ======================
            // SCREEN 19: Custom shape (color surface) - gray thin panel
            // ======================
            const width19 = 96.102;
            const height19 = 231.29;
            const geometry19 = new THREE.PlaneGeometry(width19, height19);
            const material19 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen19 = new THREE.Mesh(geometry19, material19);
            screen19.position.set(-200.877, -6.116, 47.768);
            screen19.rotation.set(0, 1.570796, 0);
            screen19.scale.set(1, 1, 1);
            screen19.userData.screenNumber = 18; // Renuméroté: 19 → 18
            screen19.userData.isColorSurface = true;
            screen19.userData.color = 0x000000;
            screensGroup.add(screen19);

            // ======================
            // SCREEN 21: Custom shape (color surface) - gray horizontal panel
            // ======================
            const width21 = 163.506;
            const height21 = 239.079;
            const geometry21 = new THREE.PlaneGeometry(width21, height21);
            const material21 = createWallFormMaterial(0x000000); // Shader subtil pour mur-forme
            const screen21 = new THREE.Mesh(geometry21, material21);
            screen21.position.set(-200.871, 27.391, 110.392);
            screen21.rotation.set(1.570796, 1.570796, 0);
            screen21.scale.set(1, 1, 1);
            screen21.userData.screenNumber = 19; // Renuméroté: 21 → 19
            screen21.userData.isColorSurface = true;
            screen21.userData.color = 0x000000;
            screensGroup.add(screen21);

            // Restore custom shapes (>21) - both in allScreens and screensGroup
            console.log('🔄 Restauration des formes personnalisées (>21):', Object.keys(customShapesToPreserve));
            Object.keys(customShapesToPreserve).forEach(key => {
                const shape = customShapesToPreserve[key];
                screensGroup.add(shape); // Re-add to scene
                allScreens[key] = shape; // CRITICAL: Re-add to allScreens to prevent orphaning
                console.log(`  ✓ Forme #${key} réajoutée à la scène et à allScreens`);
            });

            // Update volumetric screens & shapes - RENUMÉROTÉS SANS TROUS (1-19)
            // ÉCRANS volumétriques: 1-6 | FORMES: 7-19
            allScreens = {
                1: particles,           // ÉCRAN: Wall back left (volumetric)
                2: particlesRight,      // ÉCRAN: Wall back right (volumetric)
                3: screen7,             // ÉCRAN: Side panel (volumetric) - était 6
                4: wallOppB,            // ÉCRAN: Wall front right (volumetric) - était 5
                5: screen3,             // ÉCRAN: Floor rectangle (volumetric) - était 3
                6: wallOppA,            // ÉCRAN: Wall front left (volumetric) - était 4
                7: screen4,             // FORME: Ceiling gray panel - était 4
                8: screen8,             // FORME: Center gray panel
                9: screen9,             // FORME: Back gray panel
                10: screen10,           // FORME: Floor lighter green panel
                11: screen11,           // FORME: Small dark green panel
                12: screen12,           // FORME: Dark green vertical panel
                13: screen14,           // FORME: Dark green thin panel 1 - était 14
                14: screen15,           // FORME: Dark green thin panel 2 - était 15
                15: screen16,           // FORME: Dark green horizontal panel - était 16
                16: screen17,           // FORME: Gray thin panel 1 - était 17
                17: screen18,           // FORME: Gray thin panel 2 - était 18
                18: screen19,           // FORME: Gray thin panel 3 - était 19
                19: screen21,           // FORME: Gray horizontal panel - était 21
                ...customShapesToPreserve // Restore custom shapes (>19)
            };
            console.log('✅ Tous les écrans renumérotés (1-19 + custom):', Object.keys(allScreens));

            // CRITICAL: Update screen list UI immediately after allScreens is populated
            updateScreenList();
            console.log('🎨 Interface de gestion des écrans mise à jour');

            // Update screen number labels for volumetric screens (Admin mode only)
            updateScreenLabels();
            console.log('🔢 Numéros des écrans volumétriques mis à jour');

            // CRITICAL: Reattach transform controls to the same screen after regeneration
            if (transformControls && wasScreenSelected && allScreens[wasScreenSelected]) {
                selectedScreen = wasScreenSelected;
                transformControls.attach(allScreens[wasScreenSelected]);
            }

            console.log('');
            console.log('=== CONTRÔLES 3D DISPONIBLES ===');
            console.log('Touches 1-9 : Sélectionner un écran/forme');
            console.log('G : Mode Translation');
            console.log('R : Mode Rotation');
            console.log('E : Mode Scale');
            console.log('Maj enfoncé : rotation 15°, translation 1000');
            console.log('Échap : Désélectionner');
            console.log('Ctrl+Z : Annuler | Ctrl+Shift+Z : Refaire');
            console.log('S : Sauvegarder positions');
            console.log('Magnétisme auto à 0/90/180/270°');
            console.log('================================');

            // Initialize flow offsets - random circular movement for each particle
            const particleCount = positions.length / 3;
            flowOffsets = [];
            for (let i = 0; i < particleCount; i++) {
                flowOffsets.push({
                    phaseX: Math.random() * Math.PI * 2,  // Random starting phase for X
                    phaseY: Math.random() * Math.PI * 2,  // Random starting phase for Y
                    speedX: 0.3 + Math.random() * 0.7,    // Random speed multiplier X (0.3-1.0)
                    speedY: 0.3 + Math.random() * 0.7,    // Random speed multiplier Y (0.3-1.0)
                    radiusX: 2 + Math.random() * 8,       // Random radius X (2-10)
                    radiusY: 2 + Math.random() * 8        // Random radius Y (2-10)
                });
            }

            console.log('🏁 generate() terminé - allScreens final:', Object.keys(allScreens));
        }

        function applySettings() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }

            generate(currentVideo);
        }

        function resetToDefaults() {
            document.getElementById('size').value = 0.39;
            document.getElementById('density').value = 13;
            document.getElementById('depth').value = 0.1;
            document.getElementById('breath').value = 0.0;
            document.getElementById('brightness').value = 1.8;
            document.getElementById('glow').value = 0.3;
            document.getElementById('flow').value = 0.0;
            document.getElementById('blackThreshold').value = 30;
            document.getElementById('hide-black').checked = false;
            hideBlack = false;

            // New v1.3.1 parameters
            document.getElementById('depthCullPower').value = 0.4;
            document.getElementById('contrast').value = 1.1;
            document.getElementById('saturation').value = 0.80;
            document.getElementById('bgThreshold').value = 40;
            document.getElementById('enable-depth-cull').checked = false;
            document.getElementById('hide-background').checked = false;
            enableDepthCull = false;
            depthCullPower = 0.4;
            contrast = 1.1;
            saturation = 0.80;
            hideBackground = false;
            bgThreshold = 40;
            glowIntensity = 0.3;

            updateValueDisplay('size');
            updateValueDisplay('density');
            updateValueDisplay('depth');
            updateValueDisplay('breath');
            updateValueDisplay('brightness');
            updateValueDisplay('glow');
            updateValueDisplay('flow');
            updateValueDisplay('blackThreshold');
            updateValueDisplay('depthCullPower');
            updateValueDisplay('contrast');
            updateValueDisplay('saturation');
            updateValueDisplay('bgThreshold');

            if (currentVideo) {
                generate(currentVideo);
            }
        }

        function resetCamera() {
            camera.position.set(0, 0, 300);
            camera.rotation.set(0, 0, 0);
            if (screensGroup) {
                screensGroup.rotation.set(0, 0, 0);
            }
        }

        function changeVideo() {
            document.getElementById('file-input').click();
        }

        // Update particle colors and luminance-based depth from current video frame
        function updateColorsFromVideo() {
            if (!currentVideo || !videoSamplingCanvas || !videoSamplingData || !particles) return;

            // Optimization: Throttle updates to reduce CPU load
            const now = performance.now();
            if (now - lastVideoUpdateTime < VIDEO_UPDATE_INTERVAL) return;
            lastVideoUpdateTime = now;

            // Optimization: Skip if video is paused (no need to update)
            // Show visual indicator to user
            const pausedIndicator = document.getElementById('video-paused-indicator');
            if (currentVideo.paused) {
                if (pausedIndicator && !pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.add('visible');
                }
                return;
            } else {
                if (pausedIndicator && pausedIndicator.classList.contains('visible')) {
                    pausedIndicator.classList.remove('visible');
                }
            }

            const { step, TARGET_WIDTH, TARGET_HEIGHT, scaleFactor, halfWidth, halfHeight, depthMultiplier } = videoSamplingData;

            // Draw current video frame to canvas with cover behavior (16:9)
            const videoWidth = currentVideo.videoWidth;
            const videoHeight = currentVideo.videoHeight;
            const videoAspect = videoWidth / videoHeight;
            const targetAspect = 16 / 9; // 16:9 aspect ratio

            let sourceWidth, sourceHeight, offsetX, offsetY;

            if (videoAspect > targetAspect) {
                // Video is wider, fit to height and crop sides
                sourceHeight = videoHeight;
                sourceWidth = videoHeight * targetAspect;
                offsetX = (videoWidth - sourceWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller, fit to width and crop top/bottom
                sourceWidth = videoWidth;
                sourceHeight = videoWidth / targetAspect;
                offsetX = 0;
                offsetY = (videoHeight - sourceHeight) / 2;
            }

            videoSamplingCtx.drawImage(currentVideo, offsetX, offsetY, sourceWidth, sourceHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const imageData = videoSamplingCtx.getImageData(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            const data = imageData.data;

            // Calculate depth spread (same as in generate)
            const depthSpread = TARGET_HEIGHT * scaleFactor * depthMultiplier;

            let particleIndex = 0;

            // Optimization: Pre-calculate constants outside loop
            const rgbToLumFactor = 1 / (3 * 255);
            const useContrast = contrast !== 1.0;
            const useSaturation = saturation !== 1.0;

            // v1.3.1 — Detect background color from edges if hideBackground is enabled
            let bgR = 0, bgG = 0, bgB = 0;
            if (hideBackground) {
                const edgeSamples = [];
                const sampleSize = 20; // Sample 20 pixels from each edge

                // Top and bottom edges
                for (let x = 0; x < TARGET_WIDTH; x += Math.floor(TARGET_WIDTH / sampleSize)) {
                    // Top edge
                    const iTop = x * 4;
                    edgeSamples.push([data[iTop], data[iTop + 1], data[iTop + 2]]);
                    // Bottom edge
                    const iBottom = ((TARGET_HEIGHT - 1) * TARGET_WIDTH + x) * 4;
                    edgeSamples.push([data[iBottom], data[iBottom + 1], data[iBottom + 2]]);
                }

                // Left and right edges
                for (let y = 0; y < TARGET_HEIGHT; y += Math.floor(TARGET_HEIGHT / sampleSize)) {
                    // Left edge
                    const iLeft = (y * TARGET_WIDTH) * 4;
                    edgeSamples.push([data[iLeft], data[iLeft + 1], data[iLeft + 2]]);
                    // Right edge
                    const iRight = (y * TARGET_WIDTH + (TARGET_WIDTH - 1)) * 4;
                    edgeSamples.push([data[iRight], data[iRight + 1], data[iRight + 2]]);
                }

                // Calculate average background color
                edgeSamples.forEach(sample => {
                    bgR += sample[0];
                    bgG += sample[1];
                    bgB += sample[2];
                });
                bgR = Math.floor(bgR / edgeSamples.length);
                bgG = Math.floor(bgG / edgeSamples.length);
                bgB = Math.floor(bgB / edgeSamples.length);
            }

            // FIRST PASS: Find minimum luminance
            let minLuminance = Infinity;
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        const luminance = (r + g + b) * rgbToLumFactor;
                        minLuminance = Math.min(minLuminance, luminance);
                    }
                }
            }

            // If no particles found, set minLuminance to 0
            if (minLuminance === Infinity) minLuminance = 0;

            // SECOND PASS: Collect new colors and depths
            const newColors = [];
            const newDepths = [];
            for (let y = 0; y < TARGET_HEIGHT; y += step) {
                for (let x = 0; x < TARGET_WIDTH; x += step) {
                    const i = (y * TARGET_WIDTH + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 30) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const maxColor = Math.max(r, g, b);

                        // Skip if hideBlack and below threshold
                        if (hideBlack && maxColor < blackThreshold) {
                            continue;
                        }

                        // v1.3.1 — Skip background particles if hideBackground is enabled
                        if (hideBackground) {
                            const colorDist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                            if (colorDist < bgThreshold) {
                                continue;
                            }
                        }

                        // v1.3.1 — Update luminance-based depth anchored to minimum
                        // Particules les moins lumineuses restent à z=0 (point fixe)
                        const luminance = (r + g + b) * rgbToLumFactor;
                        const pz = (luminance - minLuminance) * depthSpread;
                        newDepths.push(pz);

                        // Calculate colors with effects
                        {
                            // v1.3.1 — Apply contrast and saturation effects (optimized)
                            let rNorm = r * 0.00392156862745098; // r / 255
                            let gNorm = g * 0.00392156862745098; // g / 255
                            let bNorm = b * 0.00392156862745098; // b / 255

                            // Apply contrast (optimized with pre-check)
                            if (useContrast) {
                                rNorm = (rNorm - 0.5) * contrast + 0.5;
                                gNorm = (gNorm - 0.5) * contrast + 0.5;
                                bNorm = (bNorm - 0.5) * contrast + 0.5;
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply saturation (optimized with pre-check)
                            if (useSaturation) {
                                const gray = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
                                rNorm = gray + saturation * (rNorm - gray);
                                gNorm = gray + saturation * (gNorm - gray);
                                bNorm = gray + saturation * (bNorm - gray);
                                rNorm = Math.max(0, Math.min(1, rNorm));
                                gNorm = Math.max(0, Math.min(1, gNorm));
                                bNorm = Math.max(0, Math.min(1, bNorm));
                            }

                            // Apply brightness boost
                            let finalR = rNorm * brightness;
                            let finalG = gNorm * brightness;
                            let finalB = bNorm * brightness;

                            // Professional emissive effect: brighter particles glow more (non-linear power curve)
                            if (glowIntensity > 0) {
                                // Calculate luminance of the pixel
                                const pixelLuminance = 0.299 * finalR + 0.587 * finalG + 0.114 * finalB;

                                // Power curve: bright pixels get boosted more (quadratic for smooth glow)
                                const emissiveBoost = Math.pow(pixelLuminance, 2.0) * glowIntensity;

                                // Add emissive glow to bright particles
                                finalR += emissiveBoost * finalR;
                                finalG += emissiveBoost * finalG;
                                finalB += emissiveBoost * finalB;
                            }

                            // Update color with brightness + emissive
                            newColors.push(
                                Math.min(1.0, finalR),
                                Math.min(1.0, finalG),
                                Math.min(1.0, finalB)
                            );
                        }
                    }
                }
            }

            // v1.3.1 — Apply depth culling if enabled (make particles truly invisible)
            if (enableDepthCull && depthCullPower > 0 && newDepths.length > 0) {
                // Find min and max Z values
                let minZ = Infinity;
                let maxZ = -Infinity;
                for (let i = 0; i < newDepths.length; i++) {
                    minZ = Math.min(minZ, newDepths[i]);
                    maxZ = Math.max(maxZ, newDepths[i]);
                }

                const zRange = maxZ - minZ;
                // Prevent division by zero or invalid culling when all particles have same depth
                if (zRange > 0) {
                    const cullThreshold = minZ + zRange * depthCullPower;

                    // Remove particles below threshold (make them black = invisible)
                    for (let i = 0; i < newDepths.length; i++) {
                        const z = newDepths[i];
                        if (z < cullThreshold) {
                            // Set to pure black = invisible
                            newColors[i * 3] = 0;
                            newColors[i * 3 + 1] = 0;
                            newColors[i * 3 + 2] = 0;
                        }
                    }
                }
            }

            // Update colors and depths based on mode
            if (is3DMode && particles.instanceColor) {
                // 3D Mode: Update instance colors and initial depths
                const colors = particles.instanceColor.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                particles.instanceColor.needsUpdate = true;

                // Update initialZ for depth animation with smoothing
                if (particles.userData.initialZ) {
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = particles.userData.initialZ[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            particles.userData.initialZ[i] = newDepth;
                        }
                        // else: keep old depth (reduces micro-movements/noise)
                    }
                }

                // CRITICAL: Also update screen 7 if it exists (3D mode) - now at position 3
                if (allScreens[3] && allScreens[3].instanceColor) {
                    const screen7 = allScreens[3];
                    const colors7 = screen7.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen7.userData.initialZ) {
                                        const oldDepth = screen7.userData.initialZ[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen7.userData.initialZ[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen7.instanceColor.needsUpdate = true;
                }

                // CRITICAL: Also update screen 3 if it exists (3D mode) - now at position 5
                if (allScreens[5] && allScreens[5].instanceColor) {
                    const screen3 = allScreens[5];
                    const colors3 = screen3.instanceColor.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur réduite pour écran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (screen3.userData.initialZ) {
                                        const oldDepth = screen3.userData.initialZ[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            screen3.userData.initialZ[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    screen3.instanceColor.needsUpdate = true;
                }

            } else if (geometry && geometry.attributes.color) {
                // 2D Mode: Update vertex colors and initial depths
                const colors = geometry.attributes.color.array;
                for (let i = 0; i < newColors.length; i++) {
                    colors[i] = newColors[i];
                }
                geometry.attributes.color.needsUpdate = true;

                // Update initialZ attribute for depth animation with smoothing
                if (geometry.attributes.initialZ) {
                    const initialZArray = geometry.attributes.initialZ.array;
                    for (let i = 0; i < newDepths.length; i++) {
                        const oldDepth = initialZArray[i];
                        const newDepth = newDepths[i];
                        const depthDelta = Math.abs(newDepth - oldDepth);

                        // Apply smoothing: only update if change exceeds threshold
                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                            initialZArray[i] = newDepth;
                        }
                    }
                    geometry.attributes.initialZ.needsUpdate = true;
                }

                // CRITICAL: Also update screen 7 if it exists (2D mode) - now at position 3
                if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.color) {
                    const screen7 = allScreens[3];
                    const geom7 = screen7.geometry;
                    const colors7 = geom7.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2

                    // Filter newColors and newDepths for screen 7 square
                    let particleIndex = 0;
                    let screen7Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 7 square
                                if (px >= -halfH && px <= halfH && py >= -halfH && py <= halfH) {
                                    colors7[screen7Index * 3] = newColors[particleIndex * 3];
                                    colors7[screen7Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors7[screen7Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom7.attributes.initialZ) {
                                        const oldDepth = geom7.attributes.initialZ.array[screen7Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom7.attributes.initialZ.array[screen7Index] = newDepth;
                                        }
                                    }
                                    screen7Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom7.attributes.color.needsUpdate = true;
                    if (geom7.attributes.initialZ) {
                        geom7.attributes.initialZ.needsUpdate = true;
                    }
                }

                // CRITICAL: Also update screen 3 if it exists (2D mode) - now at position 5
                if (allScreens[5] && allScreens[5].geometry && allScreens[5].geometry.attributes.color) {
                    const screen3 = allScreens[5];
                    const geom3 = screen3.geometry;
                    const colors3 = geom3.attributes.color.array;
                    const halfH = TARGET_HEIGHT * scaleFactor / 2; // Same as screenH / 2
                    const halfH_screen3 = halfH / 2; // Hauteur réduite pour écran 3

                    // Filter newColors and newDepths for screen 3 rectangle (full width, half height)
                    let particleIndex = 0;
                    let screen3Index = 0;
                    for (let y = 0; y < TARGET_HEIGHT; y += step) {
                        for (let x = 0; x < TARGET_WIDTH; x += step) {
                            const i = (y * TARGET_WIDTH + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 30) {
                                const maxColor = Math.max(data[i], data[i + 1], data[i + 2]);

                                // Calculate particle position
                                const px = (x - halfWidth) * scaleFactor;
                                const py = -(y - halfHeight) * scaleFactor;

                                // Check if this particle is in screen 3 rectangle (NO filter on X, Y reduced by half)
                                if (py >= -halfH_screen3 && py <= halfH_screen3) {
                                    colors3[screen3Index * 3] = newColors[particleIndex * 3];
                                    colors3[screen3Index * 3 + 1] = newColors[particleIndex * 3 + 1];
                                    colors3[screen3Index * 3 + 2] = newColors[particleIndex * 3 + 2];

                                    if (geom3.attributes.initialZ) {
                                        const oldDepth = geom3.attributes.initialZ.array[screen3Index];
                                        const newDepth = newDepths[particleIndex];
                                        const depthDelta = Math.abs(newDepth - oldDepth);

                                        // Apply smoothing: only update if change exceeds threshold
                                        if (depthSmoothing === 0 || depthDelta > depthSmoothing) {
                                            geom3.attributes.initialZ.array[screen3Index] = newDepth;
                                        }
                                    }
                                    screen3Index++;
                                }
                                particleIndex++;
                            }
                        }
                    }
                    geom3.attributes.color.needsUpdate = true;
                    if (geom3.attributes.initialZ) {
                        geom3.attributes.initialZ.needsUpdate = true;
                    }
                }
            }
        }

        // Collision detection function (for FPS mode) - VERSION FINALE
        function checkCollision(newPosition, prevPosition) {
            if (!fpsMode) return false;

            const hitboxWidth = fpsSettings.fpsHitboxWidth / 2; // Demi-largeur
            const hitboxHeight = fpsSettings.fpsHitboxHeight / 2; // Demi-hauteur

            // Collecter tous les murs (pas les sols 3, 10 et 11)
            // Inclut à la fois les écrans volumétriques (1,2,5,6,7) et les surfaces de couleur (4,8-21+)
            const walls = [];
            for (const key in allScreens) {
                if (key === '3' || key === '10' || key === '11') continue; // Skip floors

                const screen = allScreens[key];
                // Include both volumetric screens and color surfaces (all non-floor screens)
                if (screen && screen.visible !== false) {
                    walls.push(screen);
                }
            }

            if (walls.length === 0) return false;

            // OPTIMIZED: Reuse global Box3 objects instead of creating new ones
            reusablePlayerBox.min.set(
                newPosition.x - hitboxWidth,
                newPosition.y - hitboxHeight,
                newPosition.z - hitboxWidth
            );
            reusablePlayerBox.max.set(
                newPosition.x + hitboxWidth,
                newPosition.y + hitboxHeight,
                newPosition.z + hitboxWidth
            );

            // Tester collision avec chaque mur
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                reusableWallBox.setFromObject(wall);

                if (reusablePlayerBox.intersectsBox(reusableWallBox)) {
                    return true; // Collision détectée !
                }
            }

            return false; // Pas de collision
        }

        // Animation with subtle breathing movement and video texture updates
        let animateFrameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // FPS Counter calculation
            fpsFrameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - fpsLastTime;

            if (deltaTime >= fpsUpdateInterval) {
                fpsCurrentFPS = Math.round((fpsFrameCount * 1000) / deltaTime);
                fpsFrameCount = 0;
                fpsLastTime = currentTime;

                // OPTIMIZED: Use cached DOM elements instead of querying
                if (fpsDOMCache.value && fpsDOMCache.counter) {
                    fpsDOMCache.value.textContent = fpsCurrentFPS;

                    // Color coding based on performance
                    fpsDOMCache.counter.classList.remove('low-fps', 'critical-fps');
                    if (fpsCurrentFPS < 30) {
                        fpsDOMCache.counter.classList.add('critical-fps');
                    } else if (fpsCurrentFPS < 50) {
                        fpsDOMCache.counter.classList.add('low-fps');
                    }
                }
            }

            animateFrameCount++;
            if (animateFrameCount === 1) {
                console.log('🎬 ANIMATE() - Première frame');
            } else if (animateFrameCount % 60 === 0) {
                console.log(`🎬 ANIMATE() - Frame ${animateFrameCount} (${(animateFrameCount/60).toFixed(0)}s)`);
            }

            time += 0.001 * breathSpeed;

            // Update particle colors from current video frame (both 2D and 3D modes)
            if (currentVideo) {
                updateColorsFromVideo();
            }

            // Update video texture
            if (videoTexture && currentVideo) {
                videoTexture.needsUpdate = true;
            }

            if (particles && flowOffsets) {
                if (particles.userData && particles.userData.is3D) {
                    // 3D Mode: Update instance matrices for breathing and flow animation
                    const initialZs = particles.userData.initialZ;
                    const positions = particles.userData.positions;

                    if (initialZs && positions && initialZs.length > 0) {
                        // Optimization: reuse matrix object instead of creating new one
                        const epsilon = 0.3 * breathSpeed;

                        for (let i = 0; i < initialZs.length; i++) {
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                            const newZ = initialZs[i] + breathOffset;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            reusableMatrix.setPosition(
                                positions[i * 3] + flowX,
                                positions[i * 3 + 1] + flowY,
                                newZ
                            );
                            particles.setMatrixAt(i, reusableMatrix);
                        }
                        particles.instanceMatrix.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 7 if it has its own geometry (3D mode) - now at position 3
                    if (allScreens[3] && allScreens[3].userData && allScreens[3].userData.is3D) {
                        const screen7 = allScreens[3];
                        const initialZs7 = screen7.userData.initialZ;
                        const positions7 = screen7.userData.positions;

                        if (initialZs7 && positions7 && initialZs7.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs7.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs7[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions7[i * 3] + flowX,
                                    positions7[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen7.setMatrixAt(i, reusableMatrix);
                            }
                            screen7.instanceMatrix.needsUpdate = true;
                        }
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (3D mode) - now at position 5
                    if (allScreens[5] && allScreens[5].userData && allScreens[5].userData.is3D) {
                        const screen3 = allScreens[5];
                        const initialZs3 = screen3.userData.initialZ;
                        const positions3 = screen3.userData.positions;

                        if (initialZs3 && positions3 && initialZs3.length > 0) {
                            const epsilon = 0.3 * breathSpeed;

                            for (let i = 0; i < initialZs3.length; i++) {
                                const breathOffset = Math.sin(time + i * 0.01) * epsilon;
                                const newZ = initialZs3[i] + breathOffset;

                                // Flow movement - circular organic motion
                                let flowX = 0, flowY = 0;
                                if (flowIntensity > 0 && flowOffsets[i]) {
                                    const offset = flowOffsets[i];
                                    flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                    flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                                }

                                reusableMatrix.setPosition(
                                    positions3[i * 3] + flowX,
                                    positions3[i * 3 + 1] + flowY,
                                    newZ
                                );
                                screen3.setMatrixAt(i, reusableMatrix);
                            }
                            screen3.instanceMatrix.needsUpdate = true;
                        }
                    }

                } else if (geometry && geometry.attributes.position) {
                    // 2D Mode: Update position attribute for breathing and flow animation
                    const positions = geometry.attributes.position.array;
                    const initialZs = geometry.attributes.initialZ.array;

                    // Store initial positions if not already stored
                    if (!geometry.userData.initialPositions) {
                        geometry.userData.initialPositions = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i++) {
                            geometry.userData.initialPositions[i] = positions[i];
                        }
                    }

                    const initialPositions = geometry.userData.initialPositions;

                    for (let i = 0; i < positions.length / 3; i++) {
                        const epsilon = 0.3 * breathSpeed;
                        const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                        // Flow movement - circular organic motion
                        let flowX = 0, flowY = 0;
                        if (flowIntensity > 0 && flowOffsets[i]) {
                            const offset = flowOffsets[i];
                            flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                            flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                        }

                        positions[i * 3] = initialPositions[i * 3] + flowX;
                        positions[i * 3 + 1] = initialPositions[i * 3 + 1] + flowY;
                        positions[i * 3 + 2] = initialZs[i] + breathOffset;
                    }

                    geometry.attributes.position.needsUpdate = true;

                    // CRITICAL: Also update screen 7 if it has its own geometry (2D mode) - now at position 3
                    if (allScreens[3] && allScreens[3].geometry && allScreens[3].geometry.attributes.position) {
                        const screen7 = allScreens[3];
                        const geom7 = screen7.geometry;
                        const positions7 = geom7.attributes.position.array;
                        const initialZs7 = geom7.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom7.userData.initialPositions) {
                            geom7.userData.initialPositions = new Float32Array(positions7.length);
                            for (let i = 0; i < positions7.length; i++) {
                                geom7.userData.initialPositions[i] = positions7[i];
                            }
                        }

                        const initialPositions7 = geom7.userData.initialPositions;

                        for (let i = 0; i < positions7.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions7[i * 3] = initialPositions7[i * 3] + flowX;
                            positions7[i * 3 + 1] = initialPositions7[i * 3 + 1] + flowY;
                            positions7[i * 3 + 2] = initialZs7[i] + breathOffset;
                        }

                        geom7.attributes.position.needsUpdate = true;
                    }

                    // CRITICAL: Also update screen 3 if it has its own geometry (2D mode) - now at position 5
                    if (allScreens[5] && allScreens[5].geometry && allScreens[5].geometry.attributes.position) {
                        const screen3 = allScreens[5];
                        const geom3 = screen3.geometry;
                        const positions3 = geom3.attributes.position.array;
                        const initialZs3 = geom3.attributes.initialZ.array;

                        // Store initial positions if not already stored
                        if (!geom3.userData.initialPositions) {
                            geom3.userData.initialPositions = new Float32Array(positions3.length);
                            for (let i = 0; i < positions3.length; i++) {
                                geom3.userData.initialPositions[i] = positions3[i];
                            }
                        }

                        const initialPositions3 = geom3.userData.initialPositions;

                        for (let i = 0; i < positions3.length / 3; i++) {
                            const epsilon = 0.3 * breathSpeed;
                            const breathOffset = Math.sin(time + i * 0.01) * epsilon;

                            // Flow movement - circular organic motion
                            let flowX = 0, flowY = 0;
                            if (flowIntensity > 0 && flowOffsets[i]) {
                                const offset = flowOffsets[i];
                                flowX = Math.sin(time * offset.speedX + offset.phaseX) * offset.radiusX * flowIntensity;
                                flowY = Math.cos(time * offset.speedY + offset.phaseY) * offset.radiusY * flowIntensity;
                            }

                            positions3[i * 3] = initialPositions3[i * 3] + flowX;
                            positions3[i * 3 + 1] = initialPositions3[i * 3 + 1] + flowY;
                            positions3[i * 3 + 2] = initialZs3[i] + breathOffset;
                        }

                        geom3.attributes.position.needsUpdate = true;
                    }
                }
            }

            // Free camera rotation (apply yaw and pitch)
            if (freeCameraEnabled && camera) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;
            }

            // Camera movement (only when no screen selected and free camera enabled)
            if (!selectedScreen && freeCameraEnabled && camera) {
                // OPTIMIZED: Reuse global Vector3 objects
                camera.getWorldDirection(reusableForward);
                reusableForward.y = 0; // Mouvement horizontal uniquement
                reusableForward.normalize();

                reusableRight.crossVectors(reusableForward, reusableUp);
                reusableRight.normalize();

                // Check if any movement key is pressed
                const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;

                if (fpsMode) {
                    // ===== MODE FPS: Vitesse graduée avec accélération =====

                    if (isMoving) {
                        // Accélération progressive
                        currentSpeed = Math.min(currentSpeed + fpsSettings.fpsAcceleration, fpsSettings.fpsMaxSpeed);
                        if (cameraKeys.sprint) {
                            currentSpeed = Math.min(currentSpeed, fpsSettings.fpsMaxSpeed * 1.5); // Sprint limité
                        }
                    } else {
                        // Décélération
                        currentSpeed = Math.max(currentSpeed - fpsSettings.fpsDeceleration, MIN_SPEED);
                    }

                    // OPTIMIZED: Reuse global Vector3 for previous position
                    reusablePrevPosition.copy(camera.position);

                    // Apply movement
                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, currentSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -currentSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -currentSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, currentSpeed);
                    }

                    // Check collisions
                    if (checkCollision(camera.position, reusablePrevPosition)) {
                        camera.position.copy(reusablePrevPosition);
                    }
                } else {
                    // ===== MODE NORMAL: Vitesse fixe, pas de collision =====

                    const normalSpeed = cameraKeys.sprint ? CAMERA_SPEED * CAMERA_SPRINT_MULTIPLIER : CAMERA_SPEED;

                    if (cameraKeys.forward) {
                        camera.position.addScaledVector(reusableForward, normalSpeed);
                    }
                    if (cameraKeys.backward) {
                        camera.position.addScaledVector(reusableForward, -normalSpeed);
                    }
                    if (cameraKeys.left) {
                        camera.position.addScaledVector(reusableRight, -normalSpeed);
                    }
                    if (cameraKeys.right) {
                        camera.position.addScaledVector(reusableRight, normalSpeed);
                    }
                }

                if (fpsMode) {
                    // ===== MODE FPS: Gravité et marche sur le sol =====

                    // OPTIMIZED: Reuse global raycaster instead of creating new one
                    reusableRaycaster.set(camera.position, downVector);

                    const floorScreens = [];
                    if (allScreens[5]) floorScreens.push(allScreens[5]); // screen3 (floor) is now at position 5
                    if (allScreens[10]) floorScreens.push(allScreens[10]);
                    if (allScreens[11]) floorScreens.push(allScreens[11]);

                    const intersects = reusableRaycaster.intersectObjects(floorScreens, false);

                    if (intersects.length > 0) {
                        const groundY = intersects[0].point.y + fpsSettings.fpsPlayerHeight;
                        const distanceToGround = camera.position.y - groundY;

                        if (distanceToGround <= 1) {
                            // On est au sol - fixer Y et annuler vélocité
                            camera.position.y = groundY;
                            playerVelocityY = 0;
                            isOnGround = true;
                        } else {
                            // On est en l'air - appliquer gravité
                            isOnGround = false;
                            playerVelocityY += fpsSettings.fpsGravity;
                            camera.position.y += playerVelocityY;
                        }
                    } else {
                        // Pas de sol détecté - tomber
                        isOnGround = false;
                        playerVelocityY += fpsSettings.fpsGravity;
                        camera.position.y += playerVelocityY;
                    }

                    // Head bobbing effect when moving
                    const isMoving = cameraKeys.forward || cameraKeys.backward || cameraKeys.left || cameraKeys.right;
                    if (isMoving && playerVelocityY === 0) { // Only bob when on ground
                        headBobTimer += HEAD_BOB_SPEED * (cameraKeys.sprint ? 1.5 : 1);
                        const bobOffset = Math.sin(headBobTimer) * HEAD_BOB_AMOUNT;
                        camera.position.y += bobOffset;
                    } else {
                        headBobTimer *= 0.9;
                    }

                    // FOV kick during sprint
                    targetFOV = cameraKeys.sprint ? DEFAULT_FOV + SPRINT_FOV_INCREASE : DEFAULT_FOV;

                    // Visualisation de la hitbox
                    if (showHitbox) {
                        // Créer ou mettre à jour le helper
                        if (!hitboxHelper) {
                            // Créer un wireframe box pour visualiser la hitbox
                            const hitboxGeometry = new THREE.BoxGeometry(1, 1, 1); // Base size
                            const hitboxMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00ff00,
                                wireframe: true,
                                transparent: true,
                                opacity: 0.5
                            });
                            hitboxHelper = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                            scene.add(hitboxHelper);
                        }

                        // Mettre à jour la position et la taille de la hitbox dynamiquement
                        hitboxHelper.position.copy(camera.position);
                        hitboxHelper.scale.set(
                            fpsSettings.fpsHitboxWidth,
                            fpsSettings.fpsHitboxHeight,
                            fpsSettings.fpsHitboxWidth
                        );
                        hitboxHelper.visible = true;
                    } else if (hitboxHelper) {
                        hitboxHelper.visible = false;
                    }

                } else {
                    // ===== MODE NORMAL: Déplacement libre avec O/L =====

                    if (cameraKeys.up) {
                        camera.position.y += currentSpeed;
                    }
                    if (cameraKeys.down) {
                        camera.position.y -= currentSpeed;
                    }

                    // Pas de collision en mode normal (mode édition)
                    targetFOV = DEFAULT_FOV;
                }
            }

            // Smooth FOV transition
            if (camera && Math.abs(currentFOV - targetFOV) > 0.1) {
                currentFOV += (targetFOV - currentFOV) * 0.1;
                camera.fov = currentFOV;
                camera.updateProjectionMatrix();
            }

            // OPTIMIZED: Throttle CubeCamera updates (expensive: renders scene 6 times)
            if (allScreens && allScreens[4] && allScreens[4].userData.cubeCamera) {
                cubeCameraUpdateCounter++;
                if (cubeCameraUpdateCounter >= CUBE_CAMERA_UPDATE_INTERVAL) {
                    cubeCameraUpdateCounter = 0;
                    const screen4 = allScreens[4];
                    const cubeCamera = screen4.userData.cubeCamera;
                    screen4.visible = false;  // Cacher l'écran pour éviter auto-réflexion
                    cubeCamera.update(renderer, scene);  // Capturer l'environnement
                    screen4.visible = true;  // Réafficher l'écran
                }
            }

            // Update game instructions visibility based on Y position
            // Floor 11 is at Y=-111.773, with eye height 25, camera should be at Y≈-86.773
            const instructionsElement = document.getElementById('game-instructions');
            if (instructionsElement) {
                // Show instructions ONLY in FPS mode when on floor 11
                if (fpsMode && !isPaused) {
                    const FLOOR_11_Y = -111.773;
                    const expectedCameraY = FLOOR_11_Y + fpsSettings.fpsPlayerHeight;
                    const tolerance = 8;

                    const isOnFloor11 = Math.abs(camera.position.y - expectedCameraY) < tolerance;

                    if (isOnFloor11 && !instructionsHidden) {
                        // Show instructions until user interacts enough
                        instructionsElement.classList.remove('hidden');
                    } else {
                        instructionsElement.classList.add('hidden');
                    }
                } else {
                    // Hide instructions in admin mode or when paused
                    instructionsElement.classList.add('hidden');
                }
            }

            if (animateFrameCount === 1) {
                console.log('🖼️ RENDER() - Premier rendu de la scène');
            }
            renderer.render(scene, camera);
        }

        // Resize
        window.onresize = function() {
            // Only resize if camera and renderer are initialized
            if (!camera || !renderer) return;

            // Utiliser la taille complète de la fenêtre (pas de ratio forcé)
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const aspectRatio = canvasWidth / canvasHeight;

            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        };

        // Shape selector event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.shape-btn[data-shape]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    if (currentVideo) {
                        generate(currentVideo);
                    }
                });
            });

            // 3D Mode toggle
            document.getElementById('mode-3d-btn').addEventListener('click', function() {
                is3DMode = !is3DMode;
                this.classList.toggle('active');

                const mark2D = document.getElementById('size-mark-2d');
                const mark3D = document.getElementById('size-mark-3d');
                if (is3DMode) {
                    mark2D.style.display = 'none';
                    mark3D.style.display = 'block';
                } else {
                    mark2D.style.display = 'block';
                    mark3D.style.display = 'none';
                }

                if (currentVideo) {
                    generate(currentVideo);
                }
            });

            // Hide black checkbox
            document.getElementById('hide-black').addEventListener('change', function() {
                hideBlack = this.checked;
                scheduleRegenerate();
            });

            // Depth culling checkbox
            document.getElementById('enable-depth-cull').addEventListener('change', function() {
                enableDepthCull = this.checked;
                if (currentVideo) generate(currentVideo);
            });

            // Hide background checkbox
            document.getElementById('hide-background').addEventListener('change', function() {
                hideBackground = this.checked;
                scheduleRegenerate();
            });

            // Version selector
            const VERSION = "1.3.1";
            const versionSelector = document.getElementById('version-selector');
            const versionMenu = document.getElementById('version-menu');

            versionSelector.addEventListener('click', function(e) {
                e.stopPropagation();
                versionMenu.classList.toggle('show');
            });

            document.addEventListener('click', function() {
                versionMenu.classList.remove('show');
            });

            document.querySelectorAll('.version-item').forEach(item => {
                if (item.dataset.version === VERSION) {
                    item.classList.add('current');
                }

                item.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const file = this.dataset.file;
                    if (file && file !== 'dispersed-volume_v1.3.1.html') {
                        window.location.href = file;
                    }
                });
            });
        });

        // Start
        // Timeline click to seek
        document.getElementById('timeline').addEventListener('click', seekVideo);

        // Update glass material for screen 10
        function updateGlassMaterial() {
            if (allScreens[10] && allScreens[10].userData.isGlass) {
                const mat = allScreens[10].material;
                mat.metalness = fpsSettings.glassMetalness;
                mat.roughness = fpsSettings.glassRoughness;
                mat.opacity = fpsSettings.glassOpacity;
                mat.needsUpdate = true;
                console.log('🔄 Matériau verre mis à jour:', {
                    opacity: fpsSettings.glassOpacity,
                    metalness: fpsSettings.glassMetalness,
                    roughness: fpsSettings.glassRoughness
                });
            } else {
                console.warn('⚠️ Écran 10 pas encore créé ou pas marqué comme verre');
            }
        }

        // FPS Settings Panel Management
        function setupFPSSettings() {
            const panel = document.getElementById('fps-settings-panel');
            const sliders = {
                'fps-speed': { var: 'fpsMaxSpeed', display: 'val-fps-speed', decimals: 2 },
                'fps-scroll': { var: 'fpsScrollSpeed', display: 'val-fps-scroll', decimals: 1 },
                'fps-accel': { var: 'fpsAcceleration', display: 'val-fps-accel', decimals: 2 },
                'fps-decel': { var: 'fpsDeceleration', display: 'val-fps-decel', decimals: 2 },
                'fps-height': { var: 'fpsCameraHeight', display: 'val-fps-height', decimals: 0 },
                'fps-gravity': { var: 'fpsGravity', display: 'val-fps-gravity', decimals: 2 },
                'fps-eye': { var: 'fpsPlayerHeight', display: 'val-fps-eye', decimals: 0 },
                'fps-mouse': { var: 'fpsMouseSensitivity', display: 'val-fps-mouse', decimals: 4 },
                'fps-hitbox-width': { var: 'fpsHitboxWidth', display: 'val-fps-hitbox-width', decimals: 1 },
                'fps-hitbox-height': { var: 'fpsHitboxHeight', display: 'val-fps-hitbox-height', decimals: 0 },
                'glass-opacity': { var: 'glassOpacity', display: 'val-glass-opacity', decimals: 2, callback: updateGlassMaterial },
                'glass-roughness': { var: 'glassRoughness', display: 'val-glass-roughness', decimals: 2, callback: updateGlassMaterial },
                'glass-metalness': { var: 'glassMetalness', display: 'val-glass-metalness', decimals: 2, callback: updateGlassMaterial }
            };

            // Setup sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const config = sliders[sliderId];

                // Skip if slider doesn't exist in DOM
                if (!slider) {
                    console.warn(`⚠️ Slider "${sliderId}" not found in HTML`);
                    return;
                }

                slider.addEventListener('input', function() {
                    const value = parseFloat(this.value);

                    // Update variable in fpsSettings
                    fpsSettings[config.var] = value;

                    // Update display
                    const displayValue = value.toFixed(config.decimals);
                    document.getElementById(config.display).textContent = displayValue;

                    console.log(`✅ ${config.var} = ${displayValue}`);

                    // Call callback if provided
                    if (config.callback) {
                        config.callback();
                    }

                    // Log hitbox changes specifically
                    if (config.var === 'fpsHitboxWidth' || config.var === 'fpsHitboxHeight') {
                        console.log('🎯 Hitbox mise à jour:', {
                            largeur: fpsSettings.fpsHitboxWidth,
                            hauteur: fpsSettings.fpsHitboxHeight
                        });
                    }
                });
            });

            // Export button
            document.getElementById('fps-export-btn').addEventListener('click', exportFPSSettings);

            // Ctrl+S to export
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.code === 'KeyS') {
                    e.preventDefault();
                    exportFPSSettings();
                }
            });
        }

        function exportFPSSettings() {
            console.clear();
            console.log('═════════════════════════════════════════════');
            console.log('📋 PARAMÈTRES FPS - EXPORT');
            console.log('═════════════════════════════════════════════');
            console.log('');
            console.log('Copie ces valeurs pour intégration:');
            console.log('');
            console.log('fpsMaxSpeed = ' + fpsSettings.fpsMaxSpeed + ';');
            console.log('fpsScrollSpeed = ' + fpsSettings.fpsScrollSpeed + ';');
            console.log('fpsAcceleration = ' + fpsSettings.fpsAcceleration + ';');
            console.log('fpsDeceleration = ' + fpsSettings.fpsDeceleration + ';');
            console.log('fpsCameraHeight = ' + fpsSettings.fpsCameraHeight + ';');
            console.log('fpsCollisionRadius = ' + fpsSettings.fpsCollisionRadius + ';');
            console.log('fpsGravity = ' + fpsSettings.fpsGravity + ';');
            console.log('fpsPlayerHeight = ' + fpsSettings.fpsPlayerHeight + ';');
            console.log('fpsMouseSensitivity = ' + fpsSettings.fpsMouseSensitivity + ';');
            console.log('');
            console.log('═════════════════════════════════════════════');
            console.log('✅ Paramètres exportés dans la console!');
            console.log('   Appuie sur Ctrl+S pour ré-exporter');
            console.log('═════════════════════════════════════════════');

            // Also copy to clipboard
            const exportText = Object.entries(fpsSettings)
                .map(([key, value]) => `${key} = ${value};`)
                .join('\n');

            navigator.clipboard.writeText(exportText).then(() => {
                console.log('📋 Copié dans le presse-papier!');
            }).catch(err => {
                console.warn('Impossible de copier dans le presse-papier:', err);
            });
        }

        // Toggle FPS panel with F key (Admin mode only)
        document.addEventListener('keydown', function(e) {
            if (e.code === 'KeyF' && !e.ctrlKey && !e.shiftKey && !e.altKey && !fpsMode) {
                const panel = document.getElementById('fps-settings-panel');
                panel.classList.toggle('hidden');
                console.log(panel.classList.contains('hidden') ? '🔧 FPS Settings cachés (F pour afficher)' : '🔧 FPS Settings affichés (F pour cacher)');
            }
        });

        // Draggable panels system
        function makeDraggable(element) {
            if (!element) return;

            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                // Don't drag if clicking on interactive elements
                const tagName = e.target.tagName;
                const classList = e.target.classList;

                // Exclude interactive elements
                if (tagName === 'BUTTON' || tagName === 'INPUT' || tagName === 'SELECT' ||
                    tagName === 'VIDEO' || tagName === 'A' || tagName === 'TEXTAREA') {
                    return;
                }

                // Exclude specific classes
                if (classList.contains('screen-list') || classList.contains('slider') ||
                    classList.contains('param-row') || classList.contains('slider-wrapper') ||
                    classList.contains('video-controls') || classList.contains('timeline-container') ||
                    classList.contains('preview') || classList.contains('arrow-btn') ||
                    classList.contains('value')) {
                    return;
                }

                // Only drag from the title or empty areas
                // Allow drag from h2, h3, or the main container background
                const isTitle = tagName === 'H2' || tagName === 'H3';
                const isContainer = e.target === element;

                if (!isTitle && !isContainer) {
                    return;
                }

                e.preventDefault();
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                element.style.cursor = 'grabbing';
            }

            function elementDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                const newTop = element.offsetTop - pos2;
                const newLeft = element.offsetLeft - pos1;

                // Keep within viewport bounds
                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;

                element.style.top = Math.max(0, Math.min(newTop, maxY)) + "px";
                element.style.left = Math.max(0, Math.min(newLeft, maxX)) + "px";
                element.style.bottom = "auto";
                element.style.right = "auto";
            }

            function closeDragElement() {
                isDragging = false;
                document.onmouseup = null;
                document.onmousemove = null;
                element.style.cursor = 'move';
            }
        }

        // Audio system with progressive fade
        let backgroundMusic = null;
        let footstepSound = null;
        let isPaused = false;

        // Instructions timer (hide after 5 seconds)
        // Track keyboard interactions instead of time
        let uniqueKeysPressed = new Set();
        let instructionsHidden = false;
        const REQUIRED_UNIQUE_KEYS = 2;  // Au moins 2 touches distinctes
        const KEY_HOLD_DURATION = 1000;  // Ou 1 touche maintenue ≥ 1 seconde
        let keyHoldTimer = null;
        let keyHoldStartTime = null;

        // Legacy audio variables (for backward compatibility)
        let targetVolume = 0.7;
        let currentVolume = 0.7;
        let volumeFadeInterval = null;
        let isMuted = false;

        // ═══════════════════════════════════════════════════════════════
        // AUDIO MANAGER - Professional audio system
        // ═══════════════════════════════════════════════════════════════
        const AudioManager = {
            // State
            music: null,
            clickSound: null,
            audioContext: null,
            masterVolume: 0.7,
            currentMusicVolume: 0.7,
            isMuted: false,
            fadeInterval: null,

            // Initialize audio system
            init() {
                // Background music
                this.music = new Audio('son/Teimo.mp3');
                this.music.loop = true;
                this.music.volume = this.masterVolume;
                this.currentMusicVolume = this.masterVolume;

                // Click sound effect
                this.clickSound = new Audio('son/immersivecontrol-button-click-sound-463065.mp3');
                this.clickSound.volume = 0.5; // Base volume for click sound

                // Web Audio Context for UI sounds (fallback)
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.warn('Web Audio API not supported');
                }

                console.log('🔊 AudioManager initialized');
            },

            // Play background music
            playMusic() {
                if (!this.music) return;

                this.music.play().catch(err => {
                    console.warn('⚠️ Autoplay blocked:', err);
                });
                this.fadeMusicTo(this.masterVolume, 500);
            },

            // Pause background music
            pauseMusic() {
                if (!this.music) return;

                this.fadeMusicTo(0, 500);
                setTimeout(() => {
                    if (this.music) this.music.pause();
                }, 500);
            },

            // Fade music volume
            fadeMusicTo(targetVolume, duration = 800) {
                if (this.fadeInterval) clearInterval(this.fadeInterval);

                const steps = 30;
                const stepDuration = duration / steps;
                const volumeDelta = (targetVolume - this.currentMusicVolume) / steps;

                let step = 0;
                this.fadeInterval = setInterval(() => {
                    step++;
                    this.currentMusicVolume += volumeDelta;

                    if (!this.isMuted && this.music) {
                        this.music.volume = Math.max(0, Math.min(1, this.currentMusicVolume));
                    }

                    if (step >= steps) {
                        clearInterval(this.fadeInterval);
                        this.fadeInterval = null;
                        this.currentMusicVolume = targetVolume;
                    }
                }, stepDuration);
            },

            // Set master volume
            setVolume(volume) {
                this.masterVolume = volume;
                if (!this.isMuted && this.music) {
                    this.music.volume = volume;
                    this.currentMusicVolume = volume;
                }
            },

            // Toggle mute
            toggleMute() {
                this.isMuted = !this.isMuted;

                const soundWaves = document.getElementById('sound-waves');
                const muteSlash = document.getElementById('mute-slash');

                if (this.isMuted) {
                    // Mute everything
                    if (this.music) this.music.volume = 0;
                    soundWaves.style.display = 'none';
                    muteSlash.style.display = 'block';
                } else {
                    // Unmute
                    if (this.music) this.music.volume = this.currentMusicVolume;
                    soundWaves.style.display = 'block';
                    muteSlash.style.display = 'none';

                    // Play confirmation sound
                    this.playClick();
                }
            },

            // Play click sound (using audio file)
            playClick() {
                if (this.isMuted || !this.clickSound) return;

                try {
                    // Reset to start and play immediately (no delay)
                    this.clickSound.currentTime = 0;
                    this.clickSound.volume = 0.5 * this.masterVolume;
                    this.clickSound.play().catch(err => {
                        console.warn('Click sound playback error:', err);
                    });
                } catch(e) {
                    console.warn('Click sound error:', e);
                }
            }
        };

        // Legacy function wrappers (for backward compatibility)
        function initAudio() {
            AudioManager.init();
            backgroundMusic = AudioManager.music;
        }

        function playClickSound() {
            AudioManager.playClick();
        }

        function playAudio() {
            AudioManager.playMusic();
        }

        function pauseAudio() {
            AudioManager.pauseMusic();
        }

        function fadeVolume(target, duration = 800) {
            AudioManager.fadeMusicTo(target, duration);
        }

        function updateVolume(value) {
            const volumePercent = parseInt(value);

            const newVolume = volumePercent / 100;
            AudioManager.setVolume(newVolume);

            // Update legacy variables
            targetVolume = newVolume;
            currentVolume = newVolume;
        }

        function toggleMute() {
            AudioManager.toggleMute();
            isMuted = AudioManager.isMuted;
        }

        // Footstep sounds (trigger when moving)
        let footstepTimer = 0;
        let isMoving = false;
        function playFootsteps() {
            // Placeholder - add footstep sound file if you have one
            // if (footstepSound && fpsMode) {
            //     footstepSound.currentTime = 0;
            //     footstepSound.play().catch(err => {});
            // }
        }

        // Welcome screen functions
        function handlePlayClick() {
            playClickSound(); // Click feedback

            // Passer en état clickedPlay
            document.body.classList.remove('hoverPlay');
            document.body.classList.add('clickedPlay');

            // Activer le logo animé
            const logoVideo = document.getElementById('welcome-logo-video');
            if (logoVideo) {
                logoVideo.classList.add('active');
                logoVideo.play();
            }

            // Attendre la fin des animations avant de démarrer l'expérience
            setTimeout(() => {
                startExperience();
            }, 600);
        }

        // Gérer le hover sur le bouton play
        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('mouseenter', () => {
                document.body.classList.add('hoverPlay');
            });

            playButton.addEventListener('mouseleave', () => {
                if (!document.body.classList.contains('clickedPlay')) {
                    document.body.classList.remove('hoverPlay');
                }
            });
        }

        function startExperience() {
            const welcomeScreen = document.getElementById('welcome-screen');
            const loadingScreen = document.getElementById('loading-screen');

            // Hide welcome screen
            welcomeScreen.classList.add('hidden');

            // Show loading screen IMMEDIATELY
            loadingScreen.classList.add('active');
            loadingScreen.classList.remove('hidden');

            // Immediately hide cursor - user should enter FPS mode directly
            document.body.style.cursor = 'none';

            // Start the auto-load sequence after welcome screen
            setTimeout(() => {
                welcomeScreen.style.display = 'none';
                init();
                setupFPSSettings();

                // Make panels draggable
                makeDraggable(document.getElementById('screen-manager-panel'));
                makeDraggable(document.getElementById('fps-settings-panel'));
                makeDraggable(document.getElementById('ui'));

                // Setup pause screen click handler (click anywhere to resume)
                document.getElementById('pause-screen').addEventListener('click', function(e) {
                    // Only resume if clicking on the background (not on controls)
                    if (e.target.id === 'pause-screen') {
                        resumeExperience();
                    }
                });

                autoLoadSequence();
            }, 100);
        }

        // Pause screen functions
        function showPauseScreen() {
            if (!fpsMode) return; // Only in Spectator mode

            isPaused = true;
            document.getElementById('pause-screen').classList.add('active');

            // Progressive fade down (not complete pause)
            fadeVolume(0.1, 800); // Fade to 10% volume

            // Note: Pointer lock is automatically released by ESC key before this function is called
        }

        function resumeExperience() {
            playClickSound(); // Satisfying click feedback

            isPaused = false;
            document.getElementById('pause-screen').classList.remove('active');

            // Progressive fade up
            fadeVolume(0.7, 800); // Fade back to 70% volume

            // CRITICAL: Request pointer lock immediately to avoid intermediate cursor state
            if (fpsMode && renderer && renderer.domElement) {
                renderer.domElement.requestPointerLock();
            }
        }

        window.onload = function() {
            // Don't auto-start - wait for user interaction on welcome screen
            initAudio();
            console.log('═══════════════════════════════════════════════════════');
            console.log('📦 WINDOW.ONLOAD - Page chargée');
            console.log('💡 Cliquez sur PLAY pour démarrer');
            console.log('═══════════════════════════════════════════════════════');

            // Handle background video loading
            const welcomeVideo = document.getElementById('welcome-video-bg');
            if (welcomeVideo) {
                welcomeVideo.addEventListener('canplaythrough', function() {
                    welcomeVideo.classList.add('loaded');
                    console.log('✅ Vidéo d\'arrière-plan chargée');
                });

                welcomeVideo.addEventListener('error', function() {
                    console.log('⚠️ Vidéo d\'arrière-plan non disponible - fond noir utilisé');
                    welcomeVideo.style.display = 'none';
                });
            }
        };

        // Auto-load sequence: Load default video → Activate FPS → Show UI → Apply
        async function autoLoadSequence() {
            const loadingScreen = document.getElementById('loading-screen');

            try {
                // Step 1: Load videos for all volumetric screens
                console.log('🎬 AUTO-LOAD: Chargement des vidéos multi-écrans...');
                await loadVolumetricScreenVideos();

                // Fallback: also load default video for backward compatibility
                await loadDefaultVideo();
                await sleep(500);

                // Step 2: Activate FPS mode (Spectator mode)
                console.log('🎮 AUTO-LOAD: Activation du mode SPECTATEUR...');
                fpsMode = true;

                // Hide all interfaces in Spectator mode
                document.getElementById('ui')?.classList.add('hidden');
                document.getElementById('screen-manager-panel')?.classList.add('hidden');
                document.getElementById('shape-selector')?.classList.add('hidden');
                document.getElementById('fps-settings-panel')?.classList.add('hidden');
                document.getElementById('fps-counter')?.classList.add('hidden');

                // Play background music in Spectator mode
                playAudio();
                await sleep(300);

                // Step 3: Apply settings
                console.log('⚙️ AUTO-LOAD: Application des paramètres...');
                applySettings();
                await sleep(500);

                // Step 5: Hide loading screen
                console.log('✅ AUTO-LOAD: Séquence terminée!');
                await sleep(500);

                loadingScreen.classList.add('hidden');

                // Remove from DOM after transition
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);

                // CRITICAL: Request pointer lock immediately to avoid intermediate cursor state
                // Wait a bit for the loading screen to disappear, then request pointer lock
                setTimeout(() => {
                    if (fpsMode && renderer && renderer.domElement) {
                        console.log('🔒 Demande de pointer lock automatique...');
                        renderer.domElement.requestPointerLock();
                    }
                }, 800);

            } catch (error) {
                console.error('❌ AUTO-LOAD: Erreur:', error);

                // Hide loading screen anyway after 2s
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 2000);
            }
        }

        // Helper function to load default video
        function loadDefaultVideo() {
            return new Promise((resolve, reject) => {
                const videoElement = document.getElementById('video-source');
                const videoPath = 'videos/test_01.mp4';

                videoElement.src = videoPath;
                videoElement.load();

                videoElement.onloadeddata = function() {
                    console.log('✅ Vidéo chargée:', videoPath);
                    currentVideo = videoElement;

                    // CRITICAL: Start playing the source video
                    videoElement.muted = true;
                    videoElement.loop = true;
                    videoElement.play().catch(err => {
                        console.warn('⚠️ Autoplay vidéo source bloqué:', err);
                    });

                    // Show preview
                    document.getElementById('preview').innerHTML = '<video src="' + videoPath + '" muted loop playsinline style="max-width:100%;max-height:100%;"></video>';
                    document.getElementById('preview').classList.add('loaded');
                    const previewVideo = document.getElementById('preview').querySelector('video');
                    if (previewVideo) previewVideo.play();

                    // Auto-apply after loading
                    console.log('🎬 Apply automatique après chargement vidéo...');
                    applySettings();

                    // Second apply pass (like in original code)
                    setTimeout(() => {
                        console.log('🎬 Apply automatique (2ème passe)...');
                        applySettings();
                        resolve();
                    }, 100);
                };

                videoElement.onerror = function(error) {
                    console.error('❌ Erreur chargement vidéo:', error);
                    reject(error);
                };

                // Timeout fallback
                setTimeout(() => {
                    if (!currentVideo) {
                        reject(new Error('Timeout loading video'));
                    }
                }, 5000);
            });
        }

        // Multi-video system: Load videos for all volumetric screens
        async function loadVolumetricScreenVideos() {
            console.log('🎬 Chargement des vidéos pour écrans volumétriques...');

            const loadPromises = VOLUMETRIC_SCREENS.map(screenNum => {
                return new Promise((resolve, reject) => {
                    // Create hidden video element for this screen
                    const videoElement = document.createElement('video');
                    videoElement.id = `video-screen-${screenNum}`;
                    videoElement.muted = true;
                    videoElement.loop = true;
                    videoElement.playsinline = true;
                    videoElement.style.display = 'none';
                    document.body.appendChild(videoElement);

                    // Load video file with zero-padded number (video_01.mp4, video_02.mp4, etc.)
                    const videoPath = `videos/video_${screenNum.toString().padStart(2, '0')}.mp4`;
                    videoElement.src = videoPath;
                    videoElement.load();

                    videoElement.onloadeddata = function() {
                        console.log(`✅ Vidéo chargée pour écran ${screenNum}:`, videoPath);
                        screenVideos[screenNum] = videoElement;

                        // Start playing
                        videoElement.play().catch(err => {
                            console.warn(`⚠️ Autoplay bloqué pour écran ${screenNum}:`, err);
                        });

                        resolve(screenNum);
                    };

                    videoElement.onerror = function(error) {
                        console.warn(`⚠️ Vidéo non trouvée pour écran ${screenNum}:`, videoPath);
                        // Don't reject, just skip this screen
                        resolve(null);
                    };

                    // Timeout fallback
                    setTimeout(() => {
                        if (!screenVideos[screenNum]) {
                            console.warn(`⏱️ Timeout chargement vidéo écran ${screenNum}`);
                            resolve(null);
                        }
                    }, 3000);
                });
            });

            await Promise.all(loadPromises);
            console.log(`✅ ${Object.keys(screenVideos).length} vidéos chargées sur ${VOLUMETRIC_SCREENS.length} écrans`);
        }

        // Helper sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
